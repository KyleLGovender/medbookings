datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Add this new generator configuration
generator zod {
  provider               = "zod-prisma-types"
  output                 = "./zod"
  relationModel          = true
  modelCase              = "camelCase"
  modelSuffix            = "Schema"
  prismaJsonNullability  = true
  // Add these options
  useDecimalJs           = false // This will make Decimals serialize as numbers
  dateTimeAsDate         = false // This will make Dates serialize as strings
  addInputTypeValidation = true
  // Add custom transformer configuration
  decimalType            = "number" // This will make Decimals use number type
}

// Base User model and auth
model User {
  id                       String                          @id @default(cuid())
  name                     String?
  email                    String?                         @unique
  emailVerified            DateTime?
  phone                    String?
  phoneVerified            DateTime?
  whatsapp                 String?
  whatsappVerified         DateTime?
  password                 String?
  image                    String?
  role                     UserRole                        @default(USER)
  // Relations
  accounts                 Account[]
  serviceProvider          ServiceProvider?
  bookingsCreated          Booking[]                       @relation("BookedBy")
  bookingsAsClient         Booking[]                       @relation("BookingClient")
  notificationPreferences  NotificationPreference[]
  organizationMemberships  OrganizationMembership[]
  membershipHistoryChanges OrganizationMembershipHistory[]
  createdAt                DateTime                        @default(now())
  updatedAt                DateTime                        @updatedAt
  reviews                  Review[]
  validatedRequirements    RequirementSubmission[]         @relation("ValidatedBy")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// Provider Type and Requirements
model ServiceProviderType {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String?
  requirements     RequirementType[] // Keep as array - one ServiceProviderType can have many RequirementTypes
  services         Service[]
  serviceProviders ServiceProvider[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
}

// Service Provider
model ServiceProvider {
  id                     String                      @id @default(cuid())
  name                   String
  user                   User                        @relation(fields: [userId], references: [id])
  userId                 String                      @unique
  serviceProviderType    ServiceProviderType         @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId  String
  bio                    String?                     @db.Text
  email                  String                      @default("default@example.com")
  whatsapp               String                      @default("+1234567890")
  services               Service[]
  requirementSubmissions RequirementSubmission[]
  availabilities         Availability[]
  bookings               Booking[]
  calendarIntegration    CalendarIntegration?
  status                 ServiceProviderStatus       @default(PENDING)
  verifiedAt             DateTime?
  timezone               String                      @default("UTC")
  createdAt              DateTime                    @default(now())
  updatedAt              DateTime                    @updatedAt
  trialStarted           DateTime?
  trialEnded             DateTime?
  googlePlaceId          String? // Google Business Profile ID
  googleBusinessAccount  String? // Google Business Account ID
  averageRating          Float? // Cached average rating
  totalReviews           Int                         @default(0)
  reviews                Review[]
  image                  String // URL to provider's image in Vercel Blob
  languages              Languages[] // Array of languages spoken
  billingType            BillingType                 @default(PRIVATE_ONLY)
  website                String?                     @db.Text // Must be a valid URL
  availabilityConfigs    ServiceAvailabilityConfig[]

  // Provider connections to organizations
  providerConnections OrganizationProviderConnection[]

  // Direct organization/location (for simple cases)
  organization   Organization? @relation(fields: [organizationId], references: [id])
  organizationId String?
  location       Location?     @relation(fields: [locationId], references: [id])
  locationId     String?

  // Individual subscription (always available)
  subscriptions Subscription[]

  // Permissions
  canBeBookedByOrg Boolean @default(false) // Whether org admins can book on their behalf
}

enum ServiceProviderStatus {
  PENDING // Initial signup
  TRIAL // In free trial period
  TRIAL_EXPIRED // Trial ended, needs to subscribe
  APPROVED // Requirements validated & paid
  ACTIVE // Subscription active
  SUSPENDED // Payment failed
  CANCELLED // Subscription cancelled
  REJECTED // Application rejected
}

enum Languages {
  English
  IsiZulu
  IsiXhosa
  Afrikaans
  Sepedi
  Setswana
  Sesotho
  IsiNdebele
  SiSwati
  Tshivenda
  Xitsonga
  Portuguese
  French
  Hindi
  German
  Mandarin
}

enum BillingType {
  MEDICAL_AID_ONLY // Only accepts medical aid
  PRIVATE_ONLY // Only accepts private payments
  MEDICAL_AID_AND_PRIVATE // Accepts both medical aid and private payments
  ALL // Accepts all payment types
}

// New model for requirement types
model RequirementType {
  id                    String                    @id @default(cuid())
  name                  String
  description           String?
  isRequired            Boolean                   @default(true)
  validationType        RequirementValidationType
  validationConfig      Json? // Store validation-specific configuration
  displayPriority       Int                       @default(0) // Added field
  serviceProviderType   ServiceProviderType       @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  submissions           RequirementSubmission[]
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
}

enum RequirementValidationType {
  BOOLEAN // Yes/No or True/False answers
  DOCUMENT // Document upload required
  TEXT // Free text input
  DATE // Regular date input
  FUTURE_DATE // Date that must be in the future (e.g., expiry dates)
  PAST_DATE // Date that must be in the past (e.g., graduation date)
  NUMBER // Numeric input
  PREDEFINED_LIST // Selection from a predefined list of options
}

// Merged Requirement and RequirementValidation into RequirementSubmission
model RequirementSubmission {
  id                String                       @id @default(cuid())
  requirementType   RequirementType              @relation(fields: [requirementTypeId], references: [id])
  requirementTypeId String
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  status            RequirementsValidationStatus @default(PENDING)
  documentUrl       String? // URL to uploaded document in Vercel Blob
  documentMetadata  Json? // Store actual metadata values
  expiresAt         DateTime? // Generic expiration date
  notes             String? // Admin notes about validation/rejection
  validatedAt       DateTime?
  validatedBy       User?                        @relation("ValidatedBy", fields: [validatedById], references: [id])
  validatedById     String?
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([requirementTypeId, serviceProviderId])
}

enum RequirementsValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Modified Service model to include duration and price defaults
model Service {
  id                    String                       @id @default(cuid())
  name                  String
  description           String?
  serviceProviderType   ServiceProviderType          @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  displayPriority       Int                          @default(0)
  defaultDuration       Int // Default duration in minutes
  defaultPrice          Decimal                      @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  providers             ServiceProvider[]
  availabilityConfigs   ServiceAvailabilityConfig[]
  calculatedSlots       CalculatedAvailabilitySlot[]
  bookings              Booking[]
  createdAt             DateTime                     @default(now())
  updatedAt             DateTime                     @updatedAt

  @@index([serviceProviderTypeId, displayPriority])
}

// New model for service-specific availability configurations
model ServiceAvailabilityConfig {
  id                String                       @id @default(cuid())
  service           Service                      @relation(fields: [serviceId], references: [id])
  serviceId         String
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  duration          Int // Duration in minutes
  price             Decimal                      @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  isOnlineAvailable Boolean                      @default(false)
  isInPerson        Boolean                      @default(false)
  location          String?
  availabilities    Availability[]
  calculatedSlots   CalculatedAvailabilitySlot[]
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([serviceId, serviceProviderId])
  @@index([serviceProviderId])
}

// Modified Availability model
model Availability {
  id                String                       @id @default(cuid())
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  startTime         DateTime
  endTime           DateTime
  availableServices ServiceAvailabilityConfig[]
  calculatedSlots   CalculatedAvailabilitySlot[]
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@index([serviceProviderId, startTime, endTime])
}

// Modified CalculatedAvailabilitySlot model
model CalculatedAvailabilitySlot {
  id              String                    @id @default(cuid())
  availability    Availability              @relation(fields: [availabilityId], references: [id])
  availabilityId  String
  service         Service                   @relation(fields: [serviceId], references: [id])
  serviceId       String
  serviceConfig   ServiceAvailabilityConfig @relation(fields: [serviceConfigId], references: [id])
  serviceConfigId String
  startTime       DateTime
  endTime         DateTime
  status          SlotStatus                @default(AVAILABLE)
  booking         Booking? // One-to-one relation with booking
  lastCalculated  DateTime // When this slot was last recalculated

  // Add billing relationship
  billedToSubscription   Subscription? @relation(name: "BilledSlots", fields: [billedToSubscriptionId], references: [id])
  billedToSubscriptionId String? // Which subscription this slot is billed to

  @@index([availabilityId, serviceId, startTime, status])
  @@index([startTime, status, serviceId])
  @@index([billedToSubscriptionId]) // For billing queries
}

enum SlotStatus {
  AVAILABLE
  BOOKED
  BLOCKED // For breaks or administrative purposes
  INVALID // Used when a slot becomes invalid due to other bookings
}

// Modified Booking model
model Booking {
  id     String                      @id @default(cuid())
  slot   CalculatedAvailabilitySlot? @relation(fields: [slotId], references: [id])
  slotId String?                     @unique // One booking per slot

  // Who created the booking
  bookedBy   User?   @relation("BookedBy", fields: [bookedById], references: [id])
  bookedById String?

  // Client Information
  client        User?   @relation("BookingClient", fields: [clientId], references: [id])
  clientId      String? // Null for guest bookings
  guestName     String? // Required for guest bookings
  guestEmail    String? // Optional contact for guests
  guestPhone    String? // Optional contact for guests
  guestWhatsapp String? // Optional contact for guests

  // Service Provider and Service details
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  service           Service         @relation(fields: [serviceId], references: [id])
  serviceId         String

  // Booking details
  startTime     DateTime
  endTime       DateTime
  duration      Int // in minutes
  price         Decimal           @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  isOnline      Boolean
  isInPerson    Boolean           @default(false)
  status        BookingStatus     @default(PENDING)
  notes         String?           @db.Text
  notifications NotificationLog[]
  review        Review?
  meetSession   MeetSession?

  // Add these fields
  meetLink        String? // Store Google Meet link
  calendarEventId String? // Store Google Calendar event ID

  // Location and organization context
  location             Location?               @relation(fields: [locationId], references: [id])
  locationId           String?
  bookedByOrgMember    OrganizationMembership? @relation("BookedByOrgMember", fields: [bookedByMembershipId], references: [id])
  bookedByMembershipId String? // When booked by organization staff

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

// Notifications
model NotificationPreference {
  id             String   @id @default(cuid())
  user           User     @relation(fields: [userId], references: [id])
  userId         String
  email          Boolean  @default(true)
  sms            Boolean  @default(false)
  whatsapp       Boolean  @default(false)
  phoneNumber    String?
  whatsappNumber String?
  reminderHours  Int      @default(24) // Hours before appointment
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model NotificationLog {
  id                  String              @id @default(cuid())
  booking             Booking?            @relation(fields: [bookingId], references: [id])
  bookingId           String?
  bookingReference    String? // Store original booking ID
  serviceProviderName String? // Store provider name at time of notification
  clientName          String? // Store client name at time of notification
  serviceName         String? // Store service name at time of notification
  appointmentTime     DateTime? // Store the appointment time
  type                NotificationType
  channel             NotificationChannel
  content             String              @db.Text
  status              String // SENT, DELIVERED, FAILED
  sentAt              DateTime            @default(now())
  deliveredAt         DateTime?
}

enum NotificationType {
  BOOKING_CONFIRMATION
  BOOKING_REMINDER
  BOOKING_CANCELLATION
  BOOKING_MODIFICATION
}

enum NotificationChannel {
  EMAIL
  SMS
  WHATSAPP
}

// Calendar Integration
model CalendarIntegration {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String          @unique
  provider          String // GOOGLE, OUTLOOK, etc.
  accessToken       String          @db.Text
  refreshToken      String          @db.Text
  expiresAt         DateTime
  calendarId        String?
  syncEnabled       Boolean         @default(true)
  lastSyncedAt      DateTime?
  // Add these fields
  googleEmail       String? // The Google email account used
  grantedScopes     String[] // Array of granted OAuth scopes
  meetSettings      Json? // Store Meet preferences (default duration, etc.)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
}

model MeetSession {
  id        String            @id @default(cuid())
  booking   Booking           @relation(fields: [bookingId], references: [id])
  bookingId String            @unique
  meetLink  String
  eventId   String // Google Calendar event ID
  joinCode  String? // Optional meeting code
  status    MeetSessionStatus @default(SCHEDULED)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
}

enum MeetSessionStatus {
  SCHEDULED
  STARTED
  ENDED
  CANCELLED
}

// ORGANIZATION MODELS
model Organization {
  id                   String  @id @default(cuid())
  name                 String
  description          String? @db.Text
  email                String?
  phone                String?
  website              String? @db.Text
  logo                 String? // URL to logo in Vercel Blob
  businessRegistration String? // Company registration number
  taxNumber            String? // Tax/VAT number
  billingAddress       String? @db.Text

  // Billing configuration
  billingModel OrganizationBillingModel @default(CONSOLIDATED) // How this org handles billing

  // Relations
  locations           Location[]
  serviceProviders    ServiceProvider[]
  memberships         OrganizationMembership[]
  subscriptions       Subscription[] // For consolidated billing
  providerConnections OrganizationProviderConnection[]

  // Settings
  timezone             String  @default("UTC")
  defaultBookingWindow Int     @default(30) // Days in advance bookings can be made
  requiresApproval     Boolean @default(false) // Whether new providers need approval

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

enum OrganizationBillingModel {
  CONSOLIDATED // One subscription for entire organization
  PER_LOCATION // Each location has its own subscription
  HYBRID // Mix of consolidated and per-location
}

model OrganizationMembership {
  id             String                   @id @default(cuid())
  organization   Organization             @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String
  user           User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  role           OrganizationRole
  permissions    OrganizationPermission[]

  // Invitation management
  invitedBy  String? // User ID who sent the invitation
  invitedAt  DateTime?
  acceptedAt DateTime?
  status     MembershipStatus @default(ACTIVE)

  // Relations
  bookingsCreated Booking[]                       @relation("BookedByOrgMember")
  history         OrganizationMembershipHistory[] // Back-reference for membership history

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([organizationId, userId])
  @@index([userId])
}

enum OrganizationRole {
  OWNER // Full control, billing responsibility
  ADMIN // Operational control, can manage providers and bookings
  MANAGER // Limited admin rights, can manage specific locations/providers
  STAFF // Basic operational access
}

enum OrganizationPermission {
  MANAGE_PROVIDERS // Add/remove/edit service providers
  MANAGE_BOOKINGS // Create/modify/cancel bookings on behalf of providers
  MANAGE_LOCATIONS // Add/edit locations
  MANAGE_STAFF // Invite/remove staff members
  VIEW_ANALYTICS // Access to reports and analytics
  MANAGE_BILLING // Access to billing and subscription
  RESPOND_TO_MESSAGES // Respond to patient messages
  MANAGE_AVAILABILITY // Set availability for providers
}

enum MembershipStatus {
  PENDING // Invitation sent but not accepted
  ACTIVE // Active member
  SUSPENDED // Temporarily suspended
  INACTIVE // Left or removed
}

// Add audit trail for organization membership changes
model OrganizationMembershipHistory {
  id           String                 @id @default(cuid())
  membership   OrganizationMembership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  membershipId String

  // What changed
  changeType     MembershipChangeType
  oldRole        OrganizationRole? // Previous role (null for new memberships)
  newRole        OrganizationRole? // New role (null for deletions)
  oldPermissions OrganizationPermission[] // Previous permissions
  newPermissions OrganizationPermission[] // New permissions
  oldStatus      MembershipStatus? // Previous status
  newStatus      MembershipStatus? // New status

  // Who and when
  changedBy    User    @relation(fields: [changedById], references: [id])
  changedById  String
  changeReason String? @db.Text // Optional reason for the change

  // Context
  ipAddress String? // IP address of the person making the change
  userAgent String? @db.Text // Browser/app info

  createdAt DateTime @default(now())

  @@index([membershipId, createdAt])
  @@index([changedById, createdAt])
  @@index([changeType, createdAt])
}

enum MembershipChangeType {
  CREATED // New membership created
  ROLE_CHANGED // Role was modified
  PERMISSIONS_CHANGED // Permissions were modified
  STATUS_CHANGED // Status changed (activated, suspended, etc.)
  DELETED // Membership was removed
  INVITATION_SENT // Invitation was sent
  INVITATION_ACCEPTED // User accepted invitation
  INVITATION_REJECTED // User rejected invitation
}

// LOCATION MODEL
model Location {
  id             String       @id @default(cuid())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String

  // Location details
  name       String // e.g., "Downtown Clinic", "Main Branch"
  address    String  @db.Text
  city       String
  state      String?
  postalCode String?
  country    String  @default("South Africa")

  // Contact information
  phone String?
  email String?

  // Operational details
  operatingHours    Json? // Store operating hours as JSON
  timezone          String? // Override organization timezone if needed
  capacity          Int? // Maximum concurrent appointments
  facilities        String[] // Array of available facilities
  accessibilityInfo String?  @db.Text

  // Google integration
  googlePlaceId String? // Google Places API ID
  coordinates   Json? // Store lat/lng coordinates

  // Relations
  serviceProviders ServiceProvider[]
  bookings         Booking[]
  subscriptions    Subscription[] // For per-location billing

  // Status
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([city, isActive])
}

// ORGANIZATION-PROVIDER CONNECTIONS
// Simple connection model to establish relationships between organizations and providers
model OrganizationProviderConnection {
  id                String          @id @default(cuid())
  organization      Organization    @relation(fields: [organizationId], references: [id])
  organizationId    String
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String

  status ConnectionStatus @default(PENDING)

  // Billing preference (can be changed per availability)
  defaultBilledBy BillingEntity @default(ORGANIZATION)

  requestedAt DateTime  @default(now())
  acceptedAt  DateTime?

  @@unique([organizationId, serviceProviderId])
  @@index([serviceProviderId])
  @@index([organizationId])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
  SUSPENDED
}

enum BillingEntity {
  ORGANIZATION // Organization pays for bookings
  LOCATION // Location pays for bookings  
  PROVIDER // Provider pays for their own subscription
}

// SUBSCRIPTIONS
model Subscription {
  id String @id @default(cuid())

  // Polymorphic relations - only one should be set
  organization      Organization?    @relation(fields: [organizationId], references: [id])
  organizationId    String?
  location          Location?        @relation(fields: [locationId], references: [id])
  locationId        String?
  serviceProvider   ServiceProvider? @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String?

  // Subscription details
  status SubscriptionStatus
  plan   SubscriptionPlan   @relation(fields: [planId], references: [id])
  planId String

  // Trial management
  trialStart DateTime?
  trialEnd   DateTime?

  // Subscription lifecycle
  startDate    DateTime
  endDate      DateTime?
  cancelledAt  DateTime?
  cancelReason String?

  // Stripe integration
  stripeCustomerId     String?
  stripeSubscriptionId String?

  // Usage tracking for tiered pricing
  currentMonthSlots Int      @default(0) // Changed from bookings to slots
  billingCycleStart DateTime // When current billing cycle started
  billingCycleEnd   DateTime // When current billing cycle ends

  // Relations
  payments     Payment[]
  usageRecords UsageRecord[] // Track slot usage for billing
  billedSlots  CalculatedAvailabilitySlot[] @relation("BilledSlots") // Slots billed to this subscription

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Replace existing SubscriptionPlan model
model SubscriptionPlan {
  id          String  @id @default(cuid())
  name        String
  description String?

  // Base pricing
  basePrice Decimal         @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive()) // e.g., R300
  currency  String          @default("ZAR")
  interval  BillingInterval

  // Tiered slot pricing
  includedSlots Int   @default(30) // Free slots included in base price
  tierPricing   Json // Store tiered pricing structure as JSON
  // Plan features and limits
  features      Json? // Store plan features as JSON
  maxProviders  Int? // Max providers (for org/location plans)
  maxLocations  Int? // Max locations (for org plans)

  // Plan status
  isActive      Boolean @default(true)
  stripePriceId String? // Base price ID in Stripe

  // Relations
  subscriptions Subscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// New model: Track usage for tiered billing
model UsageRecord {
  id             String       @id @default(cuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  // Usage details - linked to availability slot
  slotId       String // Reference to CalculatedAvailabilitySlot
  slotDate     DateTime // When the slot occurred (for billing cycle)
  slotStatus   SlotStatus // Track what happened to the slot
  billingCycle String // e.g., "2024-01" for Jan 2024

  // Provider and service context
  serviceProviderId String // Which provider this slot belongs to
  serviceId         String // Which service this slot was for

  // Pricing applied
  tierUsed     Int // Which tier this slot fell into
  priceCharged Decimal @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())

  // Tracking
  processed   Boolean   @default(false) // Whether this has been billed
  processedAt DateTime?

  createdAt DateTime @default(now())

  @@index([subscriptionId, billingCycle])
  @@index([processed, billingCycle])
  @@index([slotId]) // For quick slot lookups
}

// Update Payment model
model Payment {
  id             String       @id @default(cuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  // Payment details
  amount      Decimal  @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  baseAmount  Decimal? @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive()) // Base subscription fee
  usageAmount Decimal? @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive()) // Usage-based charges
  currency    String

  // Payment status
  status          PaymentStatus
  stripePaymentId String?
  stripeInvoiceId String?
  paidAt          DateTime?
  failureReason   String?

  // Billing period this payment covers
  billingPeriodStart DateTime?
  billingPeriodEnd   DateTime?
  slotsCovered       Int? // Number of slots this payment covers

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([subscriptionId, billingPeriodStart])
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
  TRIALING
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model Review {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  client            User            @relation(fields: [clientId], references: [id])
  clientId          String
  booking           Booking         @relation(fields: [bookingId], references: [id])
  bookingId         String          @unique // One review per booking
  rating            Int // 1-5 stars
  comment           String?         @db.Text
  response          String?         @db.Text // Provider's response
  isPublic          Boolean         @default(true)
  googleReviewId    String? // Reference to Google review if synced
  status            ReviewStatus    @default(PENDING)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum ReviewStatus {
  PENDING // Awaiting moderation
  PUBLISHED // Visible to public
  HIDDEN // Hidden by admin
  FLAGGED // Flagged for review
  SYNCED // Synced with Google
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}
