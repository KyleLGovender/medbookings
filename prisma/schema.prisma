datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Add this new generator configuration
generator zod {
  provider = "zod-prisma-types"
  output   = "./zod" // This will create a /zod directory in your prisma folder
}

// Base User model and auth
model User {
  id                      String                   @id @default(cuid())
  name                    String?
  email                   String?                  @unique
  emailVerified           DateTime?
  phone                   String?
  phoneVerified           DateTime?
  whatsapp                String?
  whatsappVerified        DateTime?
  password                String?
  image                   String?
  role                    UserRole                 @default(USER)
  // Relations
  accounts                Account[]
  serviceProvider         ServiceProvider?
  bookingsCreated         Booking[]                @relation("BookedBy")
  bookingsAsClient        Booking[]                @relation("BookingClient")
  notificationPreferences NotificationPreference[]
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  reviews                 Review[]
  validatedRequirements   RequirementSubmission[]  @relation("ValidatedBy")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// Provider Type and Requirements
model ServiceProviderType {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String?
  requirements     RequirementType[] // Keep as array - one ServiceProviderType can have many RequirementTypes
  services         Service[]
  serviceProviders ServiceProvider[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
}

// Service Provider
model ServiceProvider {
  id                     String                  @id @default(cuid())
  name                   String
  user                   User                    @relation(fields: [userId], references: [id])
  userId                 String                  @unique
  serviceProviderType    ServiceProviderType     @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId  String
  bio                    String?                 @db.Text
  services               Service[]
  requirementSubmissions RequirementSubmission[]
  availabilities         Availability[]
  bookings               Booking[]
  calendarIntegration    CalendarIntegration?
  status                 ServiceProviderStatus    @default(PENDING)
  verifiedAt             DateTime?
  timezone               String                  @default("UTC")
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
  trialStarted           DateTime?
  trialEnded             DateTime?
  subscription           Subscription?
  googlePlaceId          String? // Google Business Profile ID
  googleBusinessAccount  String? // Google Business Account ID
  averageRating          Float? // Cached average rating
  totalReviews           Int                     @default(0)
  reviews                Review[]
  image                  String // URL to provider's image in Vercel Blob
  languages              Languages[] // Array of languages spoken
  billingType            BillingType             @default(PRIVATE_ONLY)
  website                String?                 @db.Text // Must be a valid URL
}

enum ServiceProviderStatus {
  PENDING // Initial signup
  TRIAL // In free trial period
  TRIAL_EXPIRED // Trial ended, needs to subscribe
  APPROVED // Requirements validated & paid
  ACTIVE // Subscription active
  SUSPENDED // Payment failed
  CANCELLED // Subscription cancelled
  REJECTED // Application rejected
}

enum Languages {
  English
  IsiZulu
  IsiXhosa
  Afrikaans
  Sepedi
  Setswana
  Sesotho
  IsiNdebele
  SiSwati
  Tshivenda
  Xitsonga
  Portuguese
  French
  Hindi
  German
  Mandarin
}

enum BillingType {
  MEDICAL_AID_ONLY // Only accepts medical aid
  PRIVATE_ONLY // Only accepts private payments
  MEDICAL_AID_AND_PRIVATE // Accepts both medical aid and private payments
  ALL // Accepts all payment types
}

// New model for requirement types
model RequirementType {
  id                    String                    @id @default(cuid())
  name                  String
  description           String?
  isRequired            Boolean                   @default(true)
  validationType        RequirementValidationType
  validationConfig      Json? // Store validation-specific configuration
  displayPriority       Int                       @default(0) // Added field
  serviceProviderType   ServiceProviderType       @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  submissions           RequirementSubmission[]
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
}

enum RequirementValidationType {
  BOOLEAN // Yes/No or True/False answers
  DOCUMENT // Document upload required
  TEXT // Free text input
  DATE // Regular date input
  FUTURE_DATE // Date that must be in the future (e.g., expiry dates)
  PAST_DATE // Date that must be in the past (e.g., graduation date)
  NUMBER // Numeric input
  PREDEFINED_LIST // Selection from a predefined list of options
}

// Merged Requirement and RequirementValidation into RequirementSubmission
model RequirementSubmission {
  id                String                       @id @default(cuid())
  requirementType   RequirementType              @relation(fields: [requirementTypeId], references: [id])
  requirementTypeId String
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  status            RequirementsValidationStatus @default(PENDING)
  documentUrl       String? // URL to uploaded document in Vercel Blob
  documentMetadata  Json? // Store actual metadata values
  expiresAt         DateTime? // Generic expiration date
  notes             String? // Admin notes about validation/rejection
  validatedAt       DateTime?
  validatedBy       User?                        @relation("ValidatedBy", fields: [validatedById], references: [id])
  validatedById     String?
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([requirementTypeId, serviceProviderId])
}

enum RequirementsValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Modified Service model
model Service {
  id                    String              @id @default(cuid())
  name                  String
  description           String?
  serviceProviderType   ServiceProviderType @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  displayPriority       Int                 @default(0)
  providers             ServiceProvider[] // Many-to-many relation with providers who offer this service
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt

  @@index([serviceProviderTypeId, displayPriority])
}

// Calendar and Booking Management
model Availability {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  startTime         DateTime
  endTime           DateTime
  isRecurring       Boolean         @default(false)
  recurringDays     Int[] // Array of days (0-6 for Sunday-Saturday)
  recurrenceEndDate DateTime? // End date for recurring availability

  // Consultation configuration
  duration            Int // Duration in minutes
  price               Decimal @db.Decimal(10, 2)
  isOnlineAvailable   Boolean @default(false)
  isInPersonAvailable Boolean @default(false)
  location            String? // For in-person consultations

  maxBookings    Int       @default(1) // For group sessions
  remainingSpots Int
  bookings       Booking[]
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([serviceProviderId, startTime, endTime])
}

enum BookingCreatorType {
  GUEST
  USER
  SERVICE_PROVIDER
  ADMIN
}

enum BookingRelationType {
  SELF // Booking for self
  DEPENDENT // e.g., Parent booking for child
  GUEST // Booking for a guest/friend
  PROFESSIONAL // Service provider or admin booking
}

model Booking {
  id String @id @default(cuid())

  // Add these fields
  bookedBy   User?    @relation("BookedBy", fields: [bookedById], references: [id])
  bookedById String?

  // Client Information (either user or guest)
  client         User?   @relation("BookingClient", fields: [clientId], references: [id])
  clientId       String? // Null for guest bookings
  guestName      String? // Required for guest bookings
  guestEmail     String? // Optional contact for guests
  guestPhone     String? // Optional contact for guests
  guestWhatsapp  String? // Optional contact for guests

  // Service Provider
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String

  // Booking details
  availability   Availability      @relation(fields: [availabilityId], references: [id])
  availabilityId String
  startTime      DateTime
  endTime        DateTime
  duration       Int // in minutes
  price          Decimal          @db.Decimal(10, 2)
  isOnline       Boolean
  isInPerson     Boolean          @default(false)
  location       String?
  status         BookingStatus    @default(PENDING)
  notes          String?          @db.Text
  notifications  NotificationLog[]
  review         Review?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

// Notifications
model NotificationPreference {
  id             String   @id @default(cuid())
  user           User     @relation(fields: [userId], references: [id])
  userId         String
  email          Boolean  @default(true)
  sms            Boolean  @default(false)
  whatsapp       Boolean  @default(false)
  phoneNumber    String?
  whatsappNumber String?
  reminderHours  Int      @default(24) // Hours before appointment
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model NotificationLog {
  id          String              @id @default(cuid())
  booking     Booking             @relation(fields: [bookingId], references: [id])
  bookingId   String
  type        NotificationType
  channel     NotificationChannel
  content     String              @db.Text
  status      String // SENT, DELIVERED, FAILED
  sentAt      DateTime            @default(now())
  deliveredAt DateTime?
}

enum NotificationType {
  BOOKING_CONFIRMATION
  BOOKING_REMINDER
  BOOKING_CANCELLATION
  BOOKING_MODIFICATION
}

enum NotificationChannel {
  EMAIL
  SMS
  WHATSAPP
}

// Calendar Integration
model CalendarIntegration {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String          @unique
  provider          String // GOOGLE, OUTLOOK, etc.
  accessToken       String          @db.Text
  refreshToken      String          @db.Text
  expiresAt         DateTime
  calendarId        String?
  syncEnabled       Boolean         @default(true)
  lastSyncedAt      DateTime?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
}

model Subscription {
  id                   String             @id @default(cuid())
  serviceProvider      ServiceProvider    @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId    String             @unique
  status               SubscriptionStatus
  plan                 SubscriptionPlan   @relation(fields: [planId], references: [id])
  planId               String
  trialStart           DateTime?
  trialEnd             DateTime?
  startDate            DateTime
  endDate              DateTime?
  cancelledAt          DateTime?
  cancelReason         String?
  stripeCustomerId     String?
  stripeSubscriptionId String?
  payments             Payment[]
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
  TRIALING
}

model SubscriptionPlan {
  id            String          @id @default(cuid())
  name          String
  description   String?
  price         Decimal         @db.Decimal(10, 2)
  interval      BillingInterval
  currency      String          @default("USD")
  isActive      Boolean         @default(true)
  stripePriceId String? // Stripe price ID
  subscriptions Subscription[]
  features      Json? // Store plan features as JSON
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model Payment {
  id              String        @id @default(cuid())
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id])
  subscriptionId  String
  amount          Decimal       @db.Decimal(10, 2)
  currency        String
  status          PaymentStatus
  stripePaymentId String?
  stripeInvoiceId String?
  paidAt          DateTime?
  failureReason   String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

model Review {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  client            User            @relation(fields: [clientId], references: [id])
  clientId          String
  booking           Booking         @relation(fields: [bookingId], references: [id])
  bookingId         String          @unique // One review per booking
  rating            Int // 1-5 stars
  comment           String?         @db.Text
  response          String?         @db.Text // Provider's response
  isPublic          Boolean         @default(true)
  googleReviewId    String? // Reference to Google review if synced
  status            ReviewStatus    @default(PENDING)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum ReviewStatus {
  PENDING // Awaiting moderation
  PUBLISHED // Visible to public
  HIDDEN // Hidden by admin
  FLAGGED // Flagged for review
  SYNCED // Synced with Google
}
