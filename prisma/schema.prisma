datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Add this new generator configuration
generator zod {
  provider              = "zod-prisma-types"
  output               = "./zod"
  relationModel        = true
  modelCase            = "camelCase"
  modelSuffix          = "Schema"
  prismaJsonNullability = true
  // Add these options
  useDecimalJs         = false  // This will make Decimals serialize as numbers
  dateTimeAsDate      = false  // This will make Dates serialize as strings
  addInputTypeValidation = true
  // Add custom transformer configuration
  decimalType         = "number"  // This will make Decimals use number type
}

// Base User model and auth
model User {
  id                      String                   @id @default(cuid())
  name                    String?
  email                   String?                  @unique
  emailVerified           DateTime?
  phone                   String?
  phoneVerified           DateTime?
  whatsapp                String?
  whatsappVerified        DateTime?
  password                String?
  image                   String?
  role                    UserRole                 @default(USER)
  // Relations
  accounts                Account[]
  serviceProvider         ServiceProvider?
  bookingsCreated         Booking[]                @relation("BookedBy")
  bookingsAsClient        Booking[]                @relation("BookingClient")
  notificationPreferences NotificationPreference[]
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  reviews                 Review[]
  validatedRequirements   RequirementSubmission[]  @relation("ValidatedBy")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// Provider Type and Requirements
model ServiceProviderType {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String?
  requirements     RequirementType[] // Keep as array - one ServiceProviderType can have many RequirementTypes
  services         Service[]
  serviceProviders ServiceProvider[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
}

// Service Provider
model ServiceProvider {
  id                     String                      @id @default(cuid())
  name                   String
  user                   User                        @relation(fields: [userId], references: [id])
  userId                 String                      @unique
  serviceProviderType    ServiceProviderType         @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId  String
  bio                    String?                     @db.Text
  services               Service[]
  requirementSubmissions RequirementSubmission[]
  availabilities         Availability[]
  bookings               Booking[]
  calendarIntegration    CalendarIntegration?
  status                 ServiceProviderStatus       @default(PENDING)
  verifiedAt             DateTime?
  timezone               String                      @default("UTC")
  createdAt              DateTime                    @default(now())
  updatedAt              DateTime                    @updatedAt
  trialStarted           DateTime?
  trialEnded             DateTime?
  subscription           Subscription?
  googlePlaceId          String? // Google Business Profile ID
  googleBusinessAccount  String? // Google Business Account ID
  averageRating          Float? // Cached average rating
  totalReviews           Int                         @default(0)
  reviews                Review[]
  image                  String // URL to provider's image in Vercel Blob
  languages              Languages[] // Array of languages spoken
  billingType            BillingType                 @default(PRIVATE_ONLY)
  website                String?                     @db.Text // Must be a valid URL
  availabilityConfigs    ServiceAvailabilityConfig[]
}

enum ServiceProviderStatus {
  PENDING // Initial signup
  TRIAL // In free trial period
  TRIAL_EXPIRED // Trial ended, needs to subscribe
  APPROVED // Requirements validated & paid
  ACTIVE // Subscription active
  SUSPENDED // Payment failed
  CANCELLED // Subscription cancelled
  REJECTED // Application rejected
}

enum Languages {
  English
  IsiZulu
  IsiXhosa
  Afrikaans
  Sepedi
  Setswana
  Sesotho
  IsiNdebele
  SiSwati
  Tshivenda
  Xitsonga
  Portuguese
  French
  Hindi
  German
  Mandarin
}

enum BillingType {
  MEDICAL_AID_ONLY // Only accepts medical aid
  PRIVATE_ONLY // Only accepts private payments
  MEDICAL_AID_AND_PRIVATE // Accepts both medical aid and private payments
  ALL // Accepts all payment types
}

// New model for requirement types
model RequirementType {
  id                    String                    @id @default(cuid())
  name                  String
  description           String?
  isRequired            Boolean                   @default(true)
  validationType        RequirementValidationType
  validationConfig      Json? // Store validation-specific configuration
  displayPriority       Int                       @default(0) // Added field
  serviceProviderType   ServiceProviderType       @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  submissions           RequirementSubmission[]
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
}

enum RequirementValidationType {
  BOOLEAN // Yes/No or True/False answers
  DOCUMENT // Document upload required
  TEXT // Free text input
  DATE // Regular date input
  FUTURE_DATE // Date that must be in the future (e.g., expiry dates)
  PAST_DATE // Date that must be in the past (e.g., graduation date)
  NUMBER // Numeric input
  PREDEFINED_LIST // Selection from a predefined list of options
}

// Merged Requirement and RequirementValidation into RequirementSubmission
model RequirementSubmission {
  id                String                       @id @default(cuid())
  requirementType   RequirementType              @relation(fields: [requirementTypeId], references: [id])
  requirementTypeId String
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  status            RequirementsValidationStatus @default(PENDING)
  documentUrl       String? // URL to uploaded document in Vercel Blob
  documentMetadata  Json? // Store actual metadata values
  expiresAt         DateTime? // Generic expiration date
  notes             String? // Admin notes about validation/rejection
  validatedAt       DateTime?
  validatedBy       User?                        @relation("ValidatedBy", fields: [validatedById], references: [id])
  validatedById     String?
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([requirementTypeId, serviceProviderId])
}

enum RequirementsValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Modified Service model to include duration and price defaults
model Service {
  id                    String                       @id @default(cuid())
  name                  String
  description           String?
  serviceProviderType   ServiceProviderType          @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  displayPriority       Int                          @default(0)
  defaultDuration       Int // Default duration in minutes
  defaultPrice          Decimal                      @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  providers             ServiceProvider[]
  availabilityConfigs   ServiceAvailabilityConfig[]
  calculatedSlots       CalculatedAvailabilitySlot[]
  bookings              Booking[]
  createdAt             DateTime                     @default(now())
  updatedAt             DateTime                     @updatedAt

  @@index([serviceProviderTypeId, displayPriority])
}

// New model for service-specific availability configurations
model ServiceAvailabilityConfig {
  id                String                       @id @default(cuid())
  service           Service         @relation(fields: [serviceId], references: [id])
  serviceId         String
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  duration          Int // Duration in minutes
  price             Decimal         @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  isOnlineAvailable Boolean         @default(false)
  isInPerson        Boolean         @default(false)
  location          String?
  availabilities    Availability[]
  calculatedSlots   CalculatedAvailabilitySlot[]
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([serviceId, serviceProviderId])
  @@index([serviceProviderId])
}

// Modified Availability model
model Availability {
  id                String                       @id @default(cuid())
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  startTime         DateTime
  endTime           DateTime
  availableServices ServiceAvailabilityConfig[]
  calculatedSlots   CalculatedAvailabilitySlot[]
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@index([serviceProviderId, startTime, endTime])
}

// Modified CalculatedAvailabilitySlot model
model CalculatedAvailabilitySlot {
  id                String                   @id @default(cuid())
  availability      Availability             @relation(fields: [availabilityId], references: [id])
  availabilityId    String
  service           Service                  @relation(fields: [serviceId], references: [id])
  serviceId         String
  serviceConfig     ServiceAvailabilityConfig @relation(fields: [serviceConfigId], references: [id])
  serviceConfigId   String
  startTime         DateTime
  endTime           DateTime
  status            SlotStatus               @default(AVAILABLE)
  booking           Booking?                 // One-to-one relation with booking
  lastCalculated    DateTime                 // When this slot was last recalculated

  @@index([availabilityId, serviceId, startTime, status])
  @@index([startTime, status, serviceId])
}

enum SlotStatus {
  AVAILABLE
  BOOKED
  BLOCKED // For breaks or administrative purposes
  INVALID // Used when a slot becomes invalid due to other bookings
}

// Modified Booking model
model Booking {
  id     String                      @id @default(cuid())
  slot   CalculatedAvailabilitySlot? @relation(fields: [slotId], references: [id])
  slotId String?                     @unique // One booking per slot

  // Who created the booking
  bookedBy   User?   @relation("BookedBy", fields: [bookedById], references: [id])
  bookedById String?

  // Client Information
  client        User?   @relation("BookingClient", fields: [clientId], references: [id])
  clientId      String? // Null for guest bookings
  guestName     String? // Required for guest bookings
  guestEmail    String? // Optional contact for guests
  guestPhone    String? // Optional contact for guests
  guestWhatsapp String? // Optional contact for guests

  // Service Provider and Service details
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  service           Service         @relation(fields: [serviceId], references: [id])
  serviceId         String

  // Booking details
  startTime     DateTime
  endTime       DateTime
  duration      Int // in minutes
  price         Decimal           @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  isOnline      Boolean
  isInPerson    Boolean           @default(false)
  location      String?
  status        BookingStatus     @default(PENDING)
  notes         String?           @db.Text
  notifications NotificationLog[]
  review        Review?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

// Notifications
model NotificationPreference {
  id             String   @id @default(cuid())
  user           User     @relation(fields: [userId], references: [id])
  userId         String
  email          Boolean  @default(true)
  sms            Boolean  @default(false)
  whatsapp       Boolean  @default(false)
  phoneNumber    String?
  whatsappNumber String?
  reminderHours  Int      @default(24) // Hours before appointment
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model NotificationLog {
  id                 String              @id @default(cuid())
  booking            Booking?            @relation(fields: [bookingId], references: [id])
  bookingId          String?
  bookingReference   String?             // Store original booking ID
  serviceProviderName String?            // Store provider name at time of notification
  clientName         String?             // Store client name at time of notification
  serviceName        String?             // Store service name at time of notification
  appointmentTime    DateTime?           // Store the appointment time
  type               NotificationType
  channel            NotificationChannel
  content            String              @db.Text
  status             String              // SENT, DELIVERED, FAILED
  sentAt             DateTime            @default(now())
  deliveredAt        DateTime?
}

enum NotificationType {
  BOOKING_CONFIRMATION
  BOOKING_REMINDER
  BOOKING_CANCELLATION
  BOOKING_MODIFICATION
}

enum NotificationChannel {
  EMAIL
  SMS
  WHATSAPP
}

// Calendar Integration
model CalendarIntegration {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String          @unique
  provider          String // GOOGLE, OUTLOOK, etc.
  accessToken       String          @db.Text
  refreshToken      String          @db.Text
  expiresAt         DateTime
  calendarId        String?
  syncEnabled       Boolean         @default(true)
  lastSyncedAt      DateTime?
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
}

model Subscription {
  id                   String             @id @default(cuid())
  serviceProvider      ServiceProvider    @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId    String             @unique
  status               SubscriptionStatus
  plan                 SubscriptionPlan   @relation(fields: [planId], references: [id])
  planId               String
  trialStart           DateTime?
  trialEnd             DateTime?
  startDate            DateTime
  endDate              DateTime?
  cancelledAt          DateTime?
  cancelReason         String?
  stripeCustomerId     String?
  stripeSubscriptionId String?
  payments             Payment[]
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
  TRIALING
}

model SubscriptionPlan {
  id            String          @id @default(cuid())
  name          String
  description   String?
  price         Decimal         @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  interval      BillingInterval
  currency      String          @default("USD")
  isActive      Boolean         @default(true)
  stripePriceId String? // Stripe price ID
  subscriptions Subscription[]
  features      Json? // Store plan features as JSON
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model Payment {
  id              String        @id @default(cuid())
  subscription    Subscription  @relation(fields: [subscriptionId], references: [id])
  subscriptionId  String
  amount          Decimal       @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  currency        String
  status          PaymentStatus
  stripePaymentId String?
  stripeInvoiceId String?
  paidAt          DateTime?
  failureReason   String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}

model Review {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  client            User            @relation(fields: [clientId], references: [id])
  clientId          String
  booking           Booking         @relation(fields: [bookingId], references: [id])
  bookingId         String          @unique // One review per booking
  rating            Int // 1-5 stars
  comment           String?         @db.Text
  response          String?         @db.Text // Provider's response
  isPublic          Boolean         @default(true)
  googleReviewId    String? // Reference to Google review if synced
  status            ReviewStatus    @default(PENDING)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum ReviewStatus {
  PENDING // Awaiting moderation
  PUBLISHED // Visible to public
  HIDDEN // Hidden by admin
  FLAGGED // Flagged for review
  SYNCED // Synced with Google
}
