datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// Add this new generator configuration
generator zod {
  provider               = "zod-prisma-types"
  output                 = "./zod"
  relationModel          = true
  modelCase              = "camelCase"
  modelSuffix            = "Schema"
  prismaJsonNullability  = true
  // Add these options
  useDecimalJs           = false // This will make Decimals serialize as numbers
  dateTimeAsDate         = false // This will make Dates serialize as strings
  addInputTypeValidation = true
  // Add custom transformer configuration
  decimalType            = "number" // This will make Decimals use number type
}

// Base User model and auth
model User {
  id                       String                          @id @default(cuid())
  name                     String?
  email                    String?                         @unique
  emailVerified            DateTime?
  phone                    String?
  phoneVerified            DateTime?
  whatsapp                 String?
  whatsappVerified         DateTime?
  password                 String?
  image                    String?
  role                     UserRole                        @default(USER)
  // Relations
  accounts                 Account[]
  serviceProvider          ServiceProvider?
  bookingsCreated          Booking[]                       @relation("BookedByUser") // Bookings created by individual users
  bookingsAsClient         Booking[]                       @relation("BookingClient")
  notificationPreferences  NotificationPreference[]
  organizationMemberships  OrganizationMembership[]
  membershipHistoryChanges OrganizationMembershipHistory[]
  availabilitiesCreated    Availability[] // Availabilities created by this user
  createdAt                DateTime                        @default(now())
  updatedAt                DateTime                        @updatedAt
  reviews                  Review[]
  validatedRequirements    RequirementSubmission[]         @relation("ValidatedBy")
}

enum UserRole {
  USER
  ADMIN
  SUPER_ADMIN
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

// Provider Type and Requirements
model ServiceProviderType {
  id               String            @id @default(cuid())
  name             String            @unique
  description      String?
  requirements     RequirementType[] // Keep as array - one ServiceProviderType can have many RequirementTypes
  services         Service[]
  serviceProviders ServiceProvider[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
}

// Service Provider
model ServiceProvider {
  id                     String                           @id @default(cuid())
  name                   String
  user                   User                             @relation(fields: [userId], references: [id])
  userId                 String                           @unique
  serviceProviderType    ServiceProviderType              @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId  String
  bio                    String?                          @db.Text
  email                  String                           @default("default@example.com")
  whatsapp               String                           @default("+1234567890")
  services               Service[]
  requirementSubmissions RequirementSubmission[]
  availabilities         Availability[]
  calendarIntegration    CalendarIntegration?
  status                 ServiceProviderStatus            @default(PENDING)
  verifiedAt             DateTime?
  timezone               String                           @default("UTC")
  createdAt              DateTime                         @default(now())
  updatedAt              DateTime                         @updatedAt
  trialStarted           DateTime?
  trialEnded             DateTime?
  googlePlaceId          String? // Google Business Profile ID
  googleBusinessAccount  String? // Google Business Account ID
  averageRating          Float? // Cached average rating
  totalReviews           Int                              @default(0)
  reviews                Review[]
  image                  String // URL to provider's image in Vercel Blob
  languages              Languages[] // Array of languages spoken
  billingType            BillingType                      @default(PRIVATE_ONLY)
  website                String?                          @db.Text // Must be a valid URL
  availabilityConfigs    ServiceAvailabilityConfig[]
  // Provider connections to organizations
  providerConnections    OrganizationProviderConnection[]
  // Direct organization/location (for simple cases)
  organization           Organization?                    @relation(fields: [organizationId], references: [id])
  organizationId         String?
  location               Location?                        @relation(fields: [locationId], references: [id])
  locationId             String?
  // Individual subscription (always available)
  subscriptions          Subscription[]
  // Permissions
  canBeBookedByOrg       Boolean                          @default(false) // Whether org admins can book on their behalf
}

enum ServiceProviderStatus {
  PENDING // Initial signup
  TRIAL // In free trial period
  TRIAL_EXPIRED // Trial ended, needs to subscribe
  APPROVED // Requirements validated & paid
  ACTIVE // Subscription active
  SUSPENDED // Payment failed
  CANCELLED // Subscription cancelled
  REJECTED // Application rejected
}

enum Languages {
  English
  IsiZulu
  IsiXhosa
  Afrikaans
  Sepedi
  Setswana
  Sesotho
  IsiNdebele
  SiSwati
  Tshivenda
  Xitsonga
  Portuguese
  French
  Hindi
  German
  Mandarin
}

enum BillingType {
  MEDICAL_AID_ONLY // Only accepts medical aid
  PRIVATE_ONLY // Only accepts private payments
  MEDICAL_AID_AND_PRIVATE // Accepts both medical aid and private payments
  ALL // Accepts all payment types
}

// New model for requirement types
model RequirementType {
  id                    String                    @id @default(cuid())
  name                  String
  description           String?
  isRequired            Boolean                   @default(true)
  validationType        RequirementValidationType
  validationConfig      Json? // Store validation-specific configuration
  displayPriority       Int                       @default(0) // Added field
  serviceProviderType   ServiceProviderType       @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  submissions           RequirementSubmission[]
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
}

enum RequirementValidationType {
  BOOLEAN // Yes/No or True/False answers
  DOCUMENT // Document upload required
  TEXT // Free text input
  DATE // Regular date input
  FUTURE_DATE // Date that must be in the future (e.g., expiry dates)
  PAST_DATE // Date that must be in the past (e.g., graduation date)
  NUMBER // Numeric input
  PREDEFINED_LIST // Selection from a predefined list of options
}

// Merged Requirement and RequirementValidation into RequirementSubmission
model RequirementSubmission {
  id                String                       @id @default(cuid())
  requirementType   RequirementType              @relation(fields: [requirementTypeId], references: [id])
  requirementTypeId String
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  status            RequirementsValidationStatus @default(PENDING)
  documentUrl       String? // URL to uploaded document in Vercel Blob
  documentMetadata  Json? // Store actual metadata values
  expiresAt         DateTime? // Generic expiration date
  notes             String? // Admin notes about validation/rejection
  validatedAt       DateTime?
  validatedBy       User?                        @relation("ValidatedBy", fields: [validatedById], references: [id])
  validatedById     String?
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([requirementTypeId, serviceProviderId])
}

enum RequirementsValidationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Modified Service model to include duration and price defaults
model Service {
  id                    String                       @id @default(cuid())
  name                  String
  description           String?
  serviceProviderType   ServiceProviderType          @relation(fields: [serviceProviderTypeId], references: [id])
  serviceProviderTypeId String
  displayPriority       Int                          @default(0)
  defaultDuration       Int // Default duration in minutes
  defaultPrice          Decimal                      @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  providers             ServiceProvider[]
  availabilityConfigs   ServiceAvailabilityConfig[]
  calculatedSlots       CalculatedAvailabilitySlot[]
  createdAt             DateTime                     @default(now())
  updatedAt             DateTime                     @updatedAt

  @@index([serviceProviderTypeId, displayPriority])
}

// New model for service-specific availability configurations
model ServiceAvailabilityConfig {
  id                String                       @id @default(cuid())
  service           Service                      @relation(fields: [serviceId], references: [id])
  serviceId         String
  serviceProvider   ServiceProvider              @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  duration          Int // Duration in minutes
  price             Decimal                      @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  isOnlineAvailable Boolean                      @default(false)
  isInPerson        Boolean                      @default(false)
  location          String?
  availabilities    Availability[]
  calculatedSlots   CalculatedAvailabilitySlot[]
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@unique([serviceId, serviceProviderId])
  @@index([serviceProviderId])
}

// Modified Availability model
model Availability {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String

  // Organization context - who created this availability
  organization   Organization? @relation(fields: [organizationId], references: [id])
  organizationId String?
  location       Location?     @relation(fields: [locationId], references: [id])
  locationId     String?

  // Reference to the connection (if created by organization)
  providerConnection OrganizationProviderConnection? @relation(fields: [connectionId], references: [id])
  connectionId       String?

  // Availability details
  startTime DateTime
  endTime   DateTime

  // Status for organization-created availability
  status      AvailabilityStatus @default(PENDING)
  createdBy   User?              @relation(fields: [createdById], references: [id])
  createdById String? // Who created this availability (org admin)
  acceptedAt  DateTime? // When provider accepted

  // Billing context - determines who pays for slots from this availability
  billingEntity         BillingEntity? // Who is responsible for billing slots from this availability
  defaultSubscription   Subscription?  @relation(fields: [defaultSubscriptionId], references: [id])
  defaultSubscriptionId String? // Default subscription to bill slots to

  availableServices ServiceAvailabilityConfig[]
  calculatedSlots   CalculatedAvailabilitySlot[]
  createdAt         DateTime                     @default(now())
  updatedAt         DateTime                     @updatedAt

  @@index([serviceProviderId, startTime, endTime])
  @@index([organizationId, status])
  @@index([connectionId])
  @@index([billingEntity, organizationId])
}

enum AvailabilityStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Modified CalculatedAvailabilitySlot model
model CalculatedAvailabilitySlot {
  id                     String                    @id @default(cuid())
  availability           Availability              @relation(fields: [availabilityId], references: [id])
  availabilityId         String
  service                Service                   @relation(fields: [serviceId], references: [id])
  serviceId              String
  serviceConfig          ServiceAvailabilityConfig @relation(fields: [serviceConfigId], references: [id])
  serviceConfigId        String
  startTime              DateTime
  endTime                DateTime
  status                 SlotStatus                @default(AVAILABLE)
  booking                Booking? // One-to-one relation with booking
  lastCalculated         DateTime // When this slot was last recalculated
  // Billing relationship - which subscription this slot is billed to
  billedToSubscription   Subscription?             @relation(name: "BilledSlots", fields: [billedToSubscriptionId], references: [id])
  billedToSubscriptionId String?
  // Calendar blocking - external events that make this slot unavailable
  blockedByCalendarEvent CalendarEvent?            @relation(name: "BlockedByCalendarEvent", fields: [blockedByEventId], references: [id])
  blockedByEventId       String? // If this slot is blocked by an external calendar event

  // Version tracking for optimistic locking during sync operations
  version Int @default(1) // Increment on each update to prevent race conditions

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([availabilityId, serviceId, startTime, status])
  @@index([startTime, status, serviceId])
}

enum SlotStatus {
  AVAILABLE
  BOOKED
  BLOCKED // For breaks or administrative purposes
  INVALID // Used when a slot becomes invalid due to other bookings
}

// Modified Booking model
model Booking {
  id     String                      @id @default(cuid())
  slot   CalculatedAvailabilitySlot? @relation(fields: [slotId], references: [id])
  slotId String?                     @unique // One booking per slot

  // Who created the booking - simplified to single reference
  bookedByMembership   OrganizationMembership? @relation("BookedByOrgMember", fields: [bookedByMembershipId], references: [id])
  bookedByMembershipId String? // When booked by organization staff
  bookedByUser         User?                   @relation("BookedByUser", fields: [bookedByUserId], references: [id])
  bookedByUserId       String? // When booked by individual user (not org staff)

  // Client Information
  client        User?   @relation("BookingClient", fields: [clientId], references: [id])
  clientId      String? // Null for guest bookings
  guestName     String? // Required for guest bookings
  guestEmail    String? // Optional contact for guests
  guestPhone    String? // Optional contact for guests
  guestWhatsapp String? // Optional contact for guests

  // Booking details (price and preferences not in slot)
  price      Decimal       @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  isOnline   Boolean
  isInPerson Boolean       @default(false)
  status     BookingStatus @default(PENDING)
  notes      String?       @db.Text

  // Integration details
  meetLink        String? // Store Google Meet link
  calendarEventId String? // Store Google Calendar event ID

  // Relations
  notifications NotificationLog[]
  review        Review?
  meetSession   MeetSession?

  // Version tracking for optimistic locking during sync operations
  version Int @default(1) // Increment on each update to prevent race conditions

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([slotId, status])
  @@index([clientId, createdAt])
  @@index([bookedByMembershipId])
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

// Notifications
model NotificationPreference {
  id             String   @id @default(cuid())
  user           User     @relation(fields: [userId], references: [id])
  userId         String
  email          Boolean  @default(true)
  sms            Boolean  @default(false)
  whatsapp       Boolean  @default(false)
  phoneNumber    String?
  whatsappNumber String?
  reminderHours  Int      @default(24) // Hours before appointment
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model NotificationLog {
  id                  String              @id @default(cuid())
  booking             Booking?            @relation(fields: [bookingId], references: [id])
  bookingId           String?
  bookingReference    String? // Store original booking ID
  serviceProviderName String? // Store provider name at time of notification
  clientName          String? // Store client name at time of notification
  serviceName         String? // Store service name at time of notification
  appointmentTime     DateTime? // Store the appointment time
  type                NotificationType
  channel             NotificationChannel
  content             String              @db.Text
  status              String // SENT, DELIVERED, FAILED
  sentAt              DateTime            @default(now())
  deliveredAt         DateTime?
}

enum NotificationType {
  BOOKING_CONFIRMATION
  BOOKING_REMINDER
  BOOKING_CANCELLATION
  BOOKING_MODIFICATION
}

enum NotificationChannel {
  EMAIL
  SMS
  WHATSAPP
}

// Calendar Integration
model CalendarIntegration {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String          @unique
  provider          String // GOOGLE, OUTLOOK, etc.
  accessToken       String          @db.Text
  refreshToken      String          @db.Text
  expiresAt         DateTime
  calendarId        String?
  syncEnabled       Boolean         @default(true)
  lastSyncedAt      DateTime?

  // Enhanced sync capabilities
  googleEmail   String? // The Google email account used
  grantedScopes String[] // Array of granted OAuth scopes
  meetSettings  Json? // Store Meet preferences (default duration, etc.)

  // Webhook/Push notification setup
  webhookChannelId  String? // Google Calendar push notification channel ID
  webhookResourceId String? // Google Calendar resource ID for the watch
  webhookExpiresAt  DateTime? // When the webhook expires
  nextSyncToken     String? // For incremental sync from Google Calendar

  // Sync configuration
  syncDirection       CalendarSyncDirection @default(BIDIRECTIONAL)
  blockingEventTypes  String[] // Which event types should block availability
  autoCreateMeetLinks Boolean               @default(true)

  // Background sync tracking
  backgroundSyncEnabled Boolean   @default(true)
  syncIntervalMinutes   Int       @default(15) // How often to run background reconciliation
  lastFullSyncAt        DateTime? // When was the last complete reconciliation
  syncFailureCount      Int       @default(0) // Track consecutive failures

  // Relations
  calendarEvents CalendarEvent[] // Track events synced from external calendar
  syncOperations CalendarSyncOperation[] // Track all sync operations

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Track external calendar events that block availability
model CalendarEvent {
  id                    String              @id @default(cuid())
  calendarIntegration   CalendarIntegration @relation(fields: [calendarIntegrationId], references: [id])
  calendarIntegrationId String

  // External calendar details
  externalEventId    String // Google Calendar event ID
  externalCalendarId String // Which calendar this event is from
  etag               String? // Google Calendar etag for change detection

  // Event details
  title     String
  startTime DateTime
  endTime   DateTime
  isAllDay  Boolean  @default(false)

  // Sync metadata for robust operations
  lastSyncedAt           DateTime                @default(now())
  eventType              String? // meeting, appointment, personal, etc.
  blocksAvailability     Boolean                 @default(true) // Whether this event should block slots
  syncStatus             CalendarEventSyncStatus @default(SYNCED)
  lastModifiedInExternal DateTime? // When the event was last modified in Google Calendar

  // Conflict detection
  hasConflict        Boolean   @default(false)
  conflictDetails    String?   @db.Text // JSON with conflict information
  conflictResolvedAt DateTime?

  // Version tracking for optimistic locking
  version Int @default(1)

  // Relations to blocked slots
  blockedSlots CalculatedAvailabilitySlot[] @relation("BlockedByCalendarEvent")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([calendarIntegrationId, externalEventId])
  @@index([calendarIntegrationId, startTime, endTime])
  @@index([syncStatus, hasConflict])
  @@index([lastSyncedAt])
}

enum CalendarEventSyncStatus {
  SYNCED // Successfully synced
  PENDING_SYNC // Needs to be synced
  SYNC_FAILED // Sync failed, needs retry
  CONFLICT_DETECTED // Conflict detected, needs resolution
  EXTERNAL_DELETED // Event was deleted in external calendar
}

enum CalendarSyncDirection {
  IMPORT_ONLY // Only Google Calendar → MedBookings
  EXPORT_ONLY // Only MedBookings → Google Calendar  
  BIDIRECTIONAL // Both directions
}

// New model for tracking calendar sync operations
model CalendarSyncOperation {
  id                    String              @id @default(cuid())
  calendarIntegration   CalendarIntegration @relation(fields: [calendarIntegrationId], references: [id])
  calendarIntegrationId String

  // Operation details
  operationType CalendarSyncOperationType
  sourceSystem  CalendarSyncSource // Which system initiated the change
  status        CalendarSyncStatus        @default(PENDING)

  // Target details
  entityType      CalendarEntityType // BOOKING, CALENDAR_EVENT, AVAILABILITY_SLOT
  entityId        String? // ID of the entity being synced
  externalEventId String? // Google Calendar event ID

  // Operation metadata
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  retryCount  Int       @default(0)
  maxRetries  Int       @default(3)

  // Error handling
  errorMessage       String?             @db.Text
  conflictResolution ConflictResolution? // How conflicts should be resolved

  // Sync window for background operations
  syncWindowStart DateTime?
  syncWindowEnd   DateTime?
  eventsProcessed Int       @default(0)
  eventsSucceeded Int       @default(0)
  eventsFailed    Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([calendarIntegrationId, status])
  @@index([operationType, startedAt])
  @@index([status, retryCount])
}

enum CalendarSyncOperationType {
  FULL_SYNC // Complete reconciliation of all events
  INCREMENTAL_SYNC // Process changes since last sync
  WEBHOOK_SYNC // Process webhook notification
  MANUAL_SYNC // User-triggered sync
  CONFLICT_RESOLUTION // Resolve detected conflicts
}

enum CalendarSyncSource {
  MEDBOOKINGS // Change originated in MedBookings
  GOOGLE_CALENDAR // Change originated in Google Calendar
  SYSTEM // System-initiated (background sync)
}

enum CalendarSyncStatus {
  PENDING // Operation is queued
  IN_PROGRESS // Currently processing
  SUCCESS // Completed successfully
  FAILED // Failed after retries
  CONFLICT_DETECTED // Conflict needs resolution
  SKIPPED // Skipped due to business rules
}

enum CalendarEntityType {
  BOOKING
  CALENDAR_EVENT
  AVAILABILITY_SLOT
}

enum ConflictResolution {
  GOOGLE_WINS // Prefer Google Calendar version
  MEDBOOKINGS_WINS // Prefer MedBookings version
  MANUAL_REVIEW // Require manual intervention
  LATEST_WINS // Use most recently updated version
}

// Modified MeetSession model
model MeetSession {
  id        String            @id @default(cuid())
  booking   Booking           @relation(fields: [bookingId], references: [id])
  bookingId String            @unique
  meetLink  String
  eventId   String // Google Calendar event ID
  joinCode  String? // Optional meeting code
  status    MeetSessionStatus @default(SCHEDULED)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
}

enum MeetSessionStatus {
  SCHEDULED
  STARTED
  ENDED
  CANCELLED
}

// ORGANIZATION MODELS
model Organization {
  id                   String  @id @default(cuid())
  name                 String
  description          String? @db.Text
  email                String?
  phone                String?
  website              String? @db.Text
  logo                 String? // URL to logo in Vercel Blob
  businessRegistration String? // Company registration number
  taxNumber            String? // Tax/VAT number
  billingAddress       String? @db.Text

  // Billing configuration
  billingModel OrganizationBillingModel @default(CONSOLIDATED) // How this org handles billing

  // Relations
  locations           Location[]
  serviceProviders    ServiceProvider[]
  memberships         OrganizationMembership[]
  subscriptions       Subscription[] // For consolidated billing
  providerConnections OrganizationProviderConnection[]
  availabilities      Availability[] // Availabilities created by this organization

  // Settings
  timezone             String  @default("UTC")
  defaultBookingWindow Int     @default(30) // Days in advance bookings can be made
  requiresApproval     Boolean @default(false) // Whether new providers need approval

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
}

enum OrganizationBillingModel {
  CONSOLIDATED // One subscription for entire organization
  PER_LOCATION // Each location has its own subscription
  HYBRID // Mix of consolidated and per-location
}

model OrganizationMembership {
  id             String                   @id @default(cuid())
  organization   Organization             @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String
  user           User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  role           OrganizationRole
  permissions    OrganizationPermission[]

  // Invitation management
  invitedBy  String? // User ID who sent the invitation
  invitedAt  DateTime?
  acceptedAt DateTime?
  status     MembershipStatus @default(ACTIVE)

  // Relations
  bookingsCreated Booking[]                       @relation("BookedByOrgMember")
  history         OrganizationMembershipHistory[] // Back-reference for membership history

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([organizationId, userId])
  @@index([userId])
}

enum OrganizationRole {
  OWNER // Full control, billing responsibility
  ADMIN // Operational control, can manage providers and bookings
  MANAGER // Limited admin rights, can manage specific locations/providers
  STAFF // Basic operational access
}

enum OrganizationPermission {
  MANAGE_PROVIDERS // Add/remove/edit service providers
  MANAGE_BOOKINGS // Create/modify/cancel bookings on behalf of providers
  MANAGE_LOCATIONS // Add/edit locations
  MANAGE_STAFF // Invite/remove staff members
  VIEW_ANALYTICS // Access to reports and analytics
  MANAGE_BILLING // Access to billing and subscription
  RESPOND_TO_MESSAGES // Respond to patient messages
  MANAGE_AVAILABILITY // Set availability for providers
}

enum MembershipStatus {
  PENDING // Invitation sent but not accepted
  ACTIVE // Active member
  SUSPENDED // Temporarily suspended
  INACTIVE // Left or removed
}

// Add audit trail for organization membership changes
model OrganizationMembershipHistory {
  id           String                 @id @default(cuid())
  membership   OrganizationMembership @relation(fields: [membershipId], references: [id], onDelete: Cascade)
  membershipId String

  // What changed
  changeType     MembershipChangeType
  oldRole        OrganizationRole? // Previous role (null for new memberships)
  newRole        OrganizationRole? // New role (null for deletions)
  oldPermissions OrganizationPermission[] // Previous permissions
  newPermissions OrganizationPermission[] // New permissions
  oldStatus      MembershipStatus? // Previous status
  newStatus      MembershipStatus? // New status

  // Who and when
  changedBy    User    @relation(fields: [changedById], references: [id])
  changedById  String
  changeReason String? @db.Text // Optional reason for the change

  // Context
  ipAddress String? // IP address of the person making the change
  userAgent String? @db.Text // Browser/app info

  createdAt DateTime @default(now())

  @@index([membershipId, createdAt])
  @@index([changedById, createdAt])
  @@index([changeType, createdAt])
}

enum MembershipChangeType {
  CREATED // New membership created
  ROLE_CHANGED // Role was modified
  PERMISSIONS_CHANGED // Permissions were modified
  STATUS_CHANGED // Status changed (activated, suspended, etc.)
  DELETED // Membership was removed
  INVITATION_SENT // Invitation was sent
  INVITATION_ACCEPTED // User accepted invitation
  INVITATION_REJECTED // User rejected invitation
}

// LOCATION MODEL
model Location {
  id             String       @id @default(cuid())
  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  organizationId String

  // Location details
  name       String // e.g., "Downtown Clinic", "Main Branch"
  address    String  @db.Text
  city       String
  state      String?
  postalCode String?
  country    String  @default("South Africa")

  // Contact information
  phone String?
  email String?

  // Operational details
  operatingHours    Json? // Store operating hours as JSON
  timezone          String? // Override organization timezone if needed
  capacity          Int? // Maximum concurrent appointments
  facilities        String[] // Array of available facilities
  accessibilityInfo String?  @db.Text

  // Google integration
  googlePlaceId String? // Google Places API ID
  coordinates   Json? // Store lat/lng coordinates

  // Relations
  serviceProviders ServiceProvider[]
  subscriptions    Subscription[] // For per-location billing
  availabilities   Availability[] // Availabilities at this location

  // Status
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([city, isActive])
}

// ORGANIZATION-PROVIDER CONNECTIONS
// Simple connection model to establish relationships between organizations and providers
model OrganizationProviderConnection {
  id                String          @id @default(cuid())
  organization      Organization    @relation(fields: [organizationId], references: [id])
  organizationId    String
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String

  status ConnectionStatus @default(PENDING)

  // Billing preference (can be changed per availability)
  defaultBilledBy BillingEntity @default(ORGANIZATION)

  // Relations
  availabilities Availability[] // Availabilities created through this connection

  requestedAt DateTime  @default(now())
  acceptedAt  DateTime?

  @@unique([organizationId, serviceProviderId])
  @@index([serviceProviderId])
  @@index([organizationId])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
  SUSPENDED
}

enum BillingEntity {
  ORGANIZATION // Organization pays for bookings
  LOCATION // Location pays for bookings  
  PROVIDER // Provider pays for their own subscription
}

// SUBSCRIPTIONS
model Subscription {
  id String @id @default(cuid())

  // Polymorphic relations - only one should be set
  organization      Organization?    @relation(fields: [organizationId], references: [id])
  organizationId    String?
  location          Location?        @relation(fields: [locationId], references: [id])
  locationId        String?
  serviceProvider   ServiceProvider? @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String?

  // Subscription details
  status SubscriptionStatus
  plan   SubscriptionPlan   @relation(fields: [planId], references: [id])
  planId String

  // Trial management
  trialStart DateTime?
  trialEnd   DateTime?

  // Subscription lifecycle
  startDate    DateTime
  endDate      DateTime?
  cancelledAt  DateTime?
  cancelReason String?

  // Stripe integration
  stripeCustomerId     String?
  stripeSubscriptionId String?

  // Usage tracking for tiered pricing
  currentMonthSlots Int      @default(0) // Changed from bookings to slots
  billingCycleStart DateTime // When current billing cycle started
  billingCycleEnd   DateTime // When current billing cycle ends

  // Relations
  payments                 Payment[]
  usageRecords             UsageRecord[] // Track slot usage for billing
  billedSlots              CalculatedAvailabilitySlot[] @relation("BilledSlots") // Slots billed to this subscription
  defaultForAvailabilities Availability[] // Availabilities that default to this subscription

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId, startDate])
}

// Replace existing SubscriptionPlan model
model SubscriptionPlan {
  id          String  @id @default(cuid())
  name        String
  description String?

  // Base pricing
  basePrice Decimal         @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive()) // e.g., R300
  currency  String          @default("ZAR")
  interval  BillingInterval

  // Tiered slot pricing
  includedSlots Int   @default(30) // Free slots included in base price
  tierPricing   Json // Store tiered pricing structure as JSON
  // Plan features and limits
  features      Json? // Store plan features as JSON
  maxProviders  Int? // Max providers (for org/location plans)
  maxLocations  Int? // Max locations (for org plans)

  // Plan status
  isActive      Boolean @default(true)
  stripePriceId String? // Base price ID in Stripe

  // Relations
  subscriptions Subscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// New model: Track usage for tiered billing
model UsageRecord {
  id             String       @id @default(cuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  // Usage details - linked to availability slot
  slotId       String // Reference to CalculatedAvailabilitySlot
  slotDate     DateTime // When the slot occurred (for billing cycle)
  slotStatus   SlotStatus // Track what happened to the slot
  billingCycle String // e.g., "2024-01" for Jan 2024

  // Provider and service context
  serviceProviderId String // Which provider this slot belongs to
  serviceId         String // Which service this slot was for

  // Pricing applied
  tierUsed     Int // Which tier this slot fell into
  priceCharged Decimal @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())

  // Tracking
  processed   Boolean   @default(false) // Whether this has been billed
  processedAt DateTime?

  createdAt DateTime @default(now())

  @@index([subscriptionId, billingCycle])
  @@index([processed, billingCycle])
  @@index([slotId]) // For quick slot lookups
}

// Update Payment model
model Payment {
  id             String       @id @default(cuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  subscriptionId String

  // Payment details
  amount      Decimal  @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive())
  baseAmount  Decimal? @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive()) // Base subscription fee
  usageAmount Decimal? @db.Decimal(10, 2) /// @zod.custom.use(z.number().positive()) // Usage-based charges
  currency    String

  // Payment status
  status          PaymentStatus
  stripePaymentId String?
  stripeInvoiceId String?
  paidAt          DateTime?
  failureReason   String?

  // Billing period this payment covers
  billingPeriodStart DateTime?
  billingPeriodEnd   DateTime?
  slotsCovered       Int? // Number of slots this payment covers

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([subscriptionId, billingPeriodStart])
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
  TRIALING
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model Review {
  id                String          @id @default(cuid())
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id])
  serviceProviderId String
  client            User            @relation(fields: [clientId], references: [id])
  clientId          String
  booking           Booking         @relation(fields: [bookingId], references: [id])
  bookingId         String          @unique // One review per booking
  rating            Int // 1-5 stars
  comment           String?         @db.Text
  response          String?         @db.Text // Provider's response
  isPublic          Boolean         @default(true)
  googleReviewId    String? // Reference to Google review if synced
  status            ReviewStatus    @default(PENDING)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt

  @@index([serviceProviderId, status])
  @@index([clientId, createdAt])
}

enum ReviewStatus {
  PENDING // Awaiting moderation
  PUBLISHED // Visible to public
  HIDDEN // Hidden by admin
  FLAGGED // Flagged for review
  SYNCED // Synced with Google
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}
