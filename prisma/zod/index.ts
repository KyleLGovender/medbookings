import { Prisma } from '@prisma/client';
import Decimal from 'decimal.js';
import { z } from 'zod';

/////////////////////////////////////////
// HELPER FUNCTIONS
/////////////////////////////////////////

// JSON
//------------------------------------------------------

export type NullableJsonInput =
  | Prisma.JsonValue
  | null
  | 'JsonNull'
  | 'DbNull'
  | Prisma.NullTypes.DbNull
  | Prisma.NullTypes.JsonNull;

export const transformJsonNull = (v?: NullableJsonInput) => {
  if (!v || v === 'DbNull') return Prisma.DbNull;
  if (v === 'JsonNull') return Prisma.JsonNull;
  return v;
};

export const JsonValueSchema: z.ZodType<Prisma.JsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.literal(null),
    z.record(z.lazy(() => JsonValueSchema.optional())),
    z.array(z.lazy(() => JsonValueSchema)),
  ])
);

export type JsonValueType = z.infer<typeof JsonValueSchema>;

export const NullableJsonValue = z
  .union([JsonValueSchema, z.literal('DbNull'), z.literal('JsonNull')])
  .nullable()
  .transform((v) => transformJsonNull(v));

export type NullableJsonValueType = z.infer<typeof NullableJsonValue>;

export const InputJsonValueSchema: z.ZodType<Prisma.InputJsonValue> = z.lazy(() =>
  z.union([
    z.string(),
    z.number(),
    z.boolean(),
    z.object({ toJSON: z.function(z.tuple([]), z.any()) }),
    z.record(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
    z.array(z.lazy(() => z.union([InputJsonValueSchema, z.literal(null)]))),
  ])
);

export type InputJsonValueType = z.infer<typeof InputJsonValueSchema>;

// DECIMAL
//------------------------------------------------------

export const DecimalJsLikeSchema: z.ZodType<Prisma.DecimalJsLike> = z.object({
  d: z.array(z.number()),
  e: z.number(),
  s: z.number(),
  toFixed: z.function(z.tuple([]), z.string()),
});

export const DECIMAL_STRING_REGEX =
  /^(?:-?Infinity|NaN|-?(?:0[bB][01]+(?:\.[01]+)?(?:[pP][-+]?\d+)?|0[oO][0-7]+(?:\.[0-7]+)?(?:[pP][-+]?\d+)?|0[xX][\da-fA-F]+(?:\.[\da-fA-F]+)?(?:[pP][-+]?\d+)?|(?:\d+|\d*\.\d+)(?:[eE][-+]?\d+)?))$/;

export const isValidDecimalInput = (
  v?: null | string | number | Prisma.DecimalJsLike
): v is string | number | Prisma.DecimalJsLike => {
  if (v === undefined || v === null) return false;
  return (
    (typeof v === 'object' && 'd' in v && 'e' in v && 's' in v && 'toFixed' in v) ||
    (typeof v === 'string' && DECIMAL_STRING_REGEX.test(v)) ||
    typeof v === 'number'
  );
};

/////////////////////////////////////////
// ENUMS
/////////////////////////////////////////

export const TransactionIsolationLevelSchema = z.enum([
  'ReadUncommitted',
  'ReadCommitted',
  'RepeatableRead',
  'Serializable',
]);

export const UserScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'email',
  'emailVerified',
  'phone',
  'phoneVerified',
  'whatsapp',
  'whatsappVerified',
  'password',
  'image',
  'role',
  'createdAt',
  'updatedAt',
]);

export const AccountScalarFieldEnumSchema = z.enum([
  'id',
  'userId',
  'type',
  'provider',
  'providerAccountId',
  'refresh_token',
  'access_token',
  'expires_at',
  'token_type',
  'scope',
  'id_token',
  'session_state',
]);

export const ServiceProviderTypeScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'createdAt',
  'updatedAt',
]);

export const ServiceProviderScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'userId',
  'serviceProviderTypeId',
  'bio',
  'image',
  'languages',
  'website',
  'email',
  'whatsapp',
  'status',
  'approvedById',
  'approvedAt',
  'rejectedAt',
  'rejectionReason',
  'createdAt',
  'updatedAt',
  'averageRating',
  'totalReviews',
  'trialStarted',
  'trialEnded',
  'trialStatus',
  'paymentMethodAdded',
  'trialReminderSent',
  'trialConversionDate',
  'selfPaidBookingsEnabled',
]);

export const OrganizationScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'email',
  'phone',
  'website',
  'logo',
  'status',
  'approvedById',
  'approvedAt',
  'rejectedAt',
  'rejectionReason',
  'createdAt',
  'updatedAt',
  'billingModel',
  'trialStarted',
  'trialEnded',
  'trialStatus',
  'paymentMethodAdded',
  'trialReminderSent',
  'trialConversionDate',
]);

export const OrganizationInvitationScalarFieldEnumSchema = z.enum([
  'id',
  'organizationId',
  'email',
  'role',
  'permissions',
  'token',
  'expiresAt',
  'invitedById',
  'status',
  'createdAt',
  'updatedAt',
  'acceptedAt',
  'membershipId',
]);

export const OrganizationMembershipScalarFieldEnumSchema = z.enum([
  'id',
  'organizationId',
  'userId',
  'role',
  'permissions',
  'status',
  'createdAt',
  'updatedAt',
]);

export const OrganizationMembershipHistoryScalarFieldEnumSchema = z.enum([
  'id',
  'membershipId',
  'changeType',
  'oldRole',
  'newRole',
  'oldPermissions',
  'newPermissions',
  'oldStatus',
  'newStatus',
  'changedById',
  'changeReason',
  'ipAddress',
  'userAgent',
  'createdAt',
]);

export const LocationScalarFieldEnumSchema = z.enum([
  'id',
  'organizationId',
  'name',
  'googlePlaceId',
  'formattedAddress',
  'coordinates',
  'addressComponents',
  'city',
  'country',
  'phone',
  'email',
  'createdAt',
  'updatedAt',
]);

export const OrganizationProviderConnectionScalarFieldEnumSchema = z.enum([
  'id',
  'organizationId',
  'serviceProviderId',
  'status',
  'defaultBilledBy',
  'requestedAt',
  'acceptedAt',
]);

export const SubscriptionScalarFieldEnumSchema = z.enum([
  'id',
  'organizationId',
  'locationId',
  'serviceProviderId',
  'status',
  'type',
  'planId',
  'isActive',
  'trialStart',
  'trialEnd',
  'startDate',
  'endDate',
  'cancelledAt',
  'cancelReason',
  'stripeCustomerId',
  'stripeSubscriptionId',
  'currentMonthSlots',
  'billingCycleStart',
  'billingCycleEnd',
  'createdAt',
  'updatedAt',
]);

export const SubscriptionPlanScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'basePrice',
  'currency',
  'interval',
  'includedSlots',
  'tierPricing',
  'features',
  'maxProviders',
  'maxLocations',
  'isActive',
  'stripePriceId',
  'createdAt',
  'updatedAt',
]);

export const UsageRecordScalarFieldEnumSchema = z.enum([
  'id',
  'subscriptionId',
  'slotId',
  'slotDate',
  'slotStatus',
  'billingCycle',
  'serviceProviderId',
  'serviceId',
  'tierUsed',
  'priceCharged',
  'processed',
  'processedAt',
  'createdAt',
]);

export const PaymentScalarFieldEnumSchema = z.enum([
  'id',
  'subscriptionId',
  'amount',
  'baseAmount',
  'usageAmount',
  'currency',
  'status',
  'stripePaymentId',
  'stripeInvoiceId',
  'paidAt',
  'failureReason',
  'billingPeriodStart',
  'billingPeriodEnd',
  'slotsCovered',
  'createdAt',
  'updatedAt',
]);

export const RequirementTypeScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'isRequired',
  'validationType',
  'validationConfig',
  'displayPriority',
  'serviceProviderTypeId',
  'createdAt',
  'updatedAt',
]);

export const RequirementSubmissionScalarFieldEnumSchema = z.enum([
  'id',
  'requirementTypeId',
  'serviceProviderId',
  'status',
  'documentUrl',
  'documentMetadata',
  'expiresAt',
  'notes',
  'validatedAt',
  'validatedById',
  'createdAt',
  'updatedAt',
]);

export const ServiceScalarFieldEnumSchema = z.enum([
  'id',
  'name',
  'description',
  'serviceProviderTypeId',
  'displayPriority',
  'defaultDuration',
  'defaultPrice',
  'createdAt',
  'updatedAt',
]);

export const ServiceAvailabilityConfigScalarFieldEnumSchema = z.enum([
  'id',
  'serviceId',
  'serviceProviderId',
  'duration',
  'price',
  'isOnlineAvailable',
  'isInPerson',
  'location',
  'createdAt',
  'updatedAt',
]);

export const AvailabilityScalarFieldEnumSchema = z.enum([
  'id',
  'serviceProviderId',
  'organizationId',
  'locationId',
  'connectionId',
  'startTime',
  'endTime',
  'createdById',
  'createdByMembershipId',
  'isProviderCreated',
  'status',
  'acceptedById',
  'acceptedAt',
  'requiresConfirmation',
  'billingEntity',
  'defaultSubscriptionId',
  'createdAt',
  'updatedAt',
]);

export const CalculatedAvailabilitySlotScalarFieldEnumSchema = z.enum([
  'id',
  'availabilityId',
  'serviceId',
  'serviceConfigId',
  'startTime',
  'endTime',
  'status',
  'lastCalculated',
  'billedToSubscriptionId',
  'blockedByEventId',
  'version',
  'createdAt',
  'updatedAt',
]);

export const BookingScalarFieldEnumSchema = z.enum([
  'id',
  'slotId',
  'createdById',
  'createdByMembershipId',
  'isProviderCreated',
  'isGuestBooking',
  'isGuestSelfBooking',
  'confirmedById',
  'confirmedAt',
  'clientId',
  'guestName',
  'guestEmail',
  'guestPhone',
  'guestWhatsapp',
  'price',
  'isOnline',
  'isInPerson',
  'status',
  'notes',
  'meetLink',
  'calendarEventId',
  'version',
  'createdAt',
  'updatedAt',
]);

export const CommunicationPreferenceScalarFieldEnumSchema = z.enum([
  'id',
  'userId',
  'email',
  'sms',
  'whatsapp',
  'phoneNumber',
  'whatsappNumber',
  'reminderHours',
  'createdAt',
  'updatedAt',
]);

export const CommunicationLogScalarFieldEnumSchema = z.enum([
  'id',
  'bookingId',
  'bookingReference',
  'serviceProviderName',
  'clientName',
  'serviceName',
  'appointmentTime',
  'type',
  'channel',
  'content',
  'status',
  'sentAt',
  'deliveredAt',
]);

export const CalendarIntegrationScalarFieldEnumSchema = z.enum([
  'id',
  'serviceProviderId',
  'provider',
  'accessToken',
  'refreshToken',
  'expiresAt',
  'calendarId',
  'syncEnabled',
  'lastSyncedAt',
  'googleEmail',
  'grantedScopes',
  'meetSettings',
  'webhookChannelId',
  'webhookResourceId',
  'webhookExpiresAt',
  'nextSyncToken',
  'syncDirection',
  'blockingEventTypes',
  'autoCreateMeetLinks',
  'backgroundSyncEnabled',
  'syncIntervalMinutes',
  'lastFullSyncAt',
  'syncFailureCount',
  'createdAt',
  'updatedAt',
]);

export const CalendarEventScalarFieldEnumSchema = z.enum([
  'id',
  'calendarIntegrationId',
  'externalEventId',
  'externalCalendarId',
  'etag',
  'title',
  'startTime',
  'endTime',
  'isAllDay',
  'lastSyncedAt',
  'eventType',
  'blocksAvailability',
  'syncStatus',
  'lastModifiedInExternal',
  'hasConflict',
  'conflictDetails',
  'conflictResolvedAt',
  'version',
  'createdAt',
  'updatedAt',
]);

export const CalendarSyncOperationScalarFieldEnumSchema = z.enum([
  'id',
  'calendarIntegrationId',
  'operationType',
  'sourceSystem',
  'status',
  'entityType',
  'entityId',
  'externalEventId',
  'startedAt',
  'completedAt',
  'retryCount',
  'maxRetries',
  'errorMessage',
  'conflictResolution',
  'syncWindowStart',
  'syncWindowEnd',
  'eventsProcessed',
  'eventsSucceeded',
  'eventsFailed',
  'createdAt',
  'updatedAt',
]);

export const MeetSessionScalarFieldEnumSchema = z.enum([
  'id',
  'bookingId',
  'meetLink',
  'eventId',
  'joinCode',
  'status',
  'createdAt',
  'updatedAt',
]);

export const ReviewScalarFieldEnumSchema = z.enum([
  'id',
  'serviceProviderId',
  'clientId',
  'bookingId',
  'rating',
  'comment',
  'response',
  'isPublic',
  'googleReviewId',
  'status',
  'createdAt',
  'updatedAt',
]);

export const SortOrderSchema = z.enum(['asc', 'desc']);

export const JsonNullValueInputSchema = z
  .enum(['JsonNull'])
  .transform((value) => (value === 'JsonNull' ? Prisma.JsonNull : value));

export const NullableJsonNullValueInputSchema = z
  .enum(['DbNull', 'JsonNull'])
  .transform((value) =>
    value === 'JsonNull' ? Prisma.JsonNull : value === 'DbNull' ? Prisma.DbNull : value
  );

export const QueryModeSchema = z.enum(['default', 'insensitive']);

export const NullsOrderSchema = z.enum(['first', 'last']);

export const JsonNullValueFilterSchema = z
  .enum(['DbNull', 'JsonNull', 'AnyNull'])
  .transform((value) =>
    value === 'JsonNull'
      ? Prisma.JsonNull
      : value === 'DbNull'
        ? Prisma.JsonNull
        : value === 'AnyNull'
          ? Prisma.AnyNull
          : value
  );

export const UserRoleSchema = z.enum(['USER', 'ADMIN', 'SUPER_ADMIN']);

export type UserRoleType = `${z.infer<typeof UserRoleSchema>}`;

export const ServiceProviderStatusSchema = z.enum([
  'PENDING_APPROVAL',
  'REJECTED',
  'APPROVED',
  'TRIAL',
  'TRIAL_EXPIRED',
  'ACTIVE',
  'PAYMENT_OVERDUE',
  'SUSPENDED',
  'CANCELLED',
]);

export type ServiceProviderStatusType = `${z.infer<typeof ServiceProviderStatusSchema>}`;

export const TrialStatusSchema = z.enum([
  'NOT_STARTED',
  'ACTIVE',
  'EXPIRING_SOON',
  'EXPIRED',
  'CONVERTED',
]);

export type TrialStatusType = `${z.infer<typeof TrialStatusSchema>}`;

export const SubscriptionTypeSchema = z.enum([
  'BASE',
  'WEBSITE_HOSTING',
  'REVIEW_PROMOTION',
  'PREMIUM_ANALYTICS',
  'CUSTOM',
]);

export type SubscriptionTypeType = `${z.infer<typeof SubscriptionTypeSchema>}`;

export const LanguagesSchema = z.enum([
  'English',
  'IsiZulu',
  'IsiXhosa',
  'Afrikaans',
  'Sepedi',
  'Setswana',
  'Sesotho',
  'IsiNdebele',
  'SiSwati',
  'Tshivenda',
  'Xitsonga',
  'Portuguese',
  'French',
  'Hindi',
  'German',
  'Mandarin',
]);

export type LanguagesType = `${z.infer<typeof LanguagesSchema>}`;

export const BillingTypeSchema = z.enum([
  'MEDICAL_AID_ONLY',
  'PRIVATE_ONLY',
  'MEDICAL_AID_AND_PRIVATE',
  'ALL',
]);

export type BillingTypeType = `${z.infer<typeof BillingTypeSchema>}`;

export const OrganizationBillingModelSchema = z.enum(['CONSOLIDATED', 'PER_LOCATION', 'HYBRID']);

export type OrganizationBillingModelType = `${z.infer<typeof OrganizationBillingModelSchema>}`;

export const OrganizationStatusSchema = z.enum([
  'PENDING_APPROVAL',
  'REJECTED',
  'APPROVED',
  'TRIAL',
  'TRIAL_EXPIRED',
  'ACTIVE',
  'PAYMENT_OVERDUE',
  'SUSPENDED',
  'CANCELLED',
]);

export type OrganizationStatusType = `${z.infer<typeof OrganizationStatusSchema>}`;

export const InvitationStatusSchema = z.enum([
  'PENDING',
  'ACCEPTED',
  'DECLINED',
  'EXPIRED',
  'CANCELLED',
]);

export type InvitationStatusType = `${z.infer<typeof InvitationStatusSchema>}`;

export const OrganizationRoleSchema = z.enum(['OWNER', 'ADMIN', 'MANAGER', 'STAFF']);

export type OrganizationRoleType = `${z.infer<typeof OrganizationRoleSchema>}`;

export const OrganizationPermissionSchema = z.enum([
  'MANAGE_PROVIDERS',
  'MANAGE_BOOKINGS',
  'MANAGE_LOCATIONS',
  'MANAGE_STAFF',
  'VIEW_ANALYTICS',
  'MANAGE_BILLING',
  'RESPOND_TO_MESSAGES',
  'MANAGE_AVAILABILITY',
]);

export type OrganizationPermissionType = `${z.infer<typeof OrganizationPermissionSchema>}`;

export const MembershipStatusSchema = z.enum(['PENDING', 'ACTIVE', 'SUSPENDED', 'INACTIVE']);

export type MembershipStatusType = `${z.infer<typeof MembershipStatusSchema>}`;

export const MembershipChangeTypeSchema = z.enum([
  'CREATED',
  'ROLE_CHANGED',
  'PERMISSIONS_CHANGED',
  'STATUS_CHANGED',
  'DELETED',
  'INVITATION_SENT',
  'INVITATION_ACCEPTED',
  'INVITATION_REJECTED',
]);

export type MembershipChangeTypeType = `${z.infer<typeof MembershipChangeTypeSchema>}`;

export const ConnectionStatusSchema = z.enum(['PENDING', 'ACCEPTED', 'REJECTED', 'SUSPENDED']);

export type ConnectionStatusType = `${z.infer<typeof ConnectionStatusSchema>}`;

export const BillingEntitySchema = z.enum(['ORGANIZATION', 'LOCATION', 'PROVIDER']);

export type BillingEntityType = `${z.infer<typeof BillingEntitySchema>}`;

export const PaymentStatusSchema = z.enum(['PENDING', 'SUCCEEDED', 'FAILED', 'REFUNDED']);

export type PaymentStatusType = `${z.infer<typeof PaymentStatusSchema>}`;

export const SubscriptionStatusSchema = z.enum([
  'ACTIVE',
  'PAST_DUE',
  'CANCELLED',
  'EXPIRED',
  'TRIALING',
]);

export type SubscriptionStatusType = `${z.infer<typeof SubscriptionStatusSchema>}`;

export const BillingIntervalSchema = z.enum(['MONTHLY']);

export type BillingIntervalType = `${z.infer<typeof BillingIntervalSchema>}`;

export const RequirementValidationTypeSchema = z.enum([
  'BOOLEAN',
  'DOCUMENT',
  'TEXT',
  'DATE',
  'FUTURE_DATE',
  'PAST_DATE',
  'NUMBER',
  'PREDEFINED_LIST',
]);

export type RequirementValidationTypeType = `${z.infer<typeof RequirementValidationTypeSchema>}`;

export const RequirementsValidationStatusSchema = z.enum(['PENDING', 'APPROVED', 'REJECTED']);

export type RequirementsValidationStatusType =
  `${z.infer<typeof RequirementsValidationStatusSchema>}`;

export const AvailabilityStatusSchema = z.enum(['PENDING', 'ACCEPTED', 'REJECTED']);

export type AvailabilityStatusType = `${z.infer<typeof AvailabilityStatusSchema>}`;

export const SlotStatusSchema = z.enum(['AVAILABLE', 'BOOKED', 'BLOCKED', 'INVALID']);

export type SlotStatusType = `${z.infer<typeof SlotStatusSchema>}`;

export const BookingStatusSchema = z.enum([
  'PENDING',
  'CONFIRMED',
  'CANCELLED',
  'COMPLETED',
  'NO_SHOW',
]);

export type BookingStatusType = `${z.infer<typeof BookingStatusSchema>}`;

export const CommunicationTypeSchema = z.enum([
  'BOOKING_CONFIRMATION',
  'BOOKING_REMINDER',
  'BOOKING_CANCELLATION',
  'BOOKING_MODIFICATION',
]);

export type CommunicationTypeType = `${z.infer<typeof CommunicationTypeSchema>}`;

export const CommunicationChannelSchema = z.enum(['EMAIL', 'SMS', 'WHATSAPP']);

export type CommunicationChannelType = `${z.infer<typeof CommunicationChannelSchema>}`;

export const CalendarEventSyncStatusSchema = z.enum([
  'SYNCED',
  'PENDING_SYNC',
  'SYNC_FAILED',
  'CONFLICT_DETECTED',
  'EXTERNAL_DELETED',
]);

export type CalendarEventSyncStatusType = `${z.infer<typeof CalendarEventSyncStatusSchema>}`;

export const CalendarSyncDirectionSchema = z.enum(['IMPORT_ONLY', 'EXPORT_ONLY', 'BIDIRECTIONAL']);

export type CalendarSyncDirectionType = `${z.infer<typeof CalendarSyncDirectionSchema>}`;

export const CalendarSyncOperationTypeSchema = z.enum([
  'FULL_SYNC',
  'INCREMENTAL_SYNC',
  'WEBHOOK_SYNC',
  'MANUAL_SYNC',
  'CONFLICT_RESOLUTION',
]);

export type CalendarSyncOperationTypeType = `${z.infer<typeof CalendarSyncOperationTypeSchema>}`;

export const CalendarSyncSourceSchema = z.enum(['MEDBOOKINGS', 'GOOGLE_CALENDAR', 'SYSTEM']);

export type CalendarSyncSourceType = `${z.infer<typeof CalendarSyncSourceSchema>}`;

export const CalendarSyncStatusSchema = z.enum([
  'PENDING',
  'IN_PROGRESS',
  'SUCCESS',
  'FAILED',
  'CONFLICT_DETECTED',
  'SKIPPED',
]);

export type CalendarSyncStatusType = `${z.infer<typeof CalendarSyncStatusSchema>}`;

export const CalendarEntityTypeSchema = z.enum(['BOOKING', 'CALENDAR_EVENT', 'AVAILABILITY_SLOT']);

export type CalendarEntityTypeType = `${z.infer<typeof CalendarEntityTypeSchema>}`;

export const ConflictResolutionSchema = z.enum([
  'GOOGLE_WINS',
  'MEDBOOKINGS_WINS',
  'MANUAL_REVIEW',
  'LATEST_WINS',
]);

export type ConflictResolutionType = `${z.infer<typeof ConflictResolutionSchema>}`;

export const MeetSessionStatusSchema = z.enum(['SCHEDULED', 'STARTED', 'ENDED', 'CANCELLED']);

export type MeetSessionStatusType = `${z.infer<typeof MeetSessionStatusSchema>}`;

export const ReviewStatusSchema = z.enum(['PENDING', 'PUBLISHED', 'HIDDEN', 'FLAGGED', 'SYNCED']);

export type ReviewStatusType = `${z.infer<typeof ReviewStatusSchema>}`;

/////////////////////////////////////////
// MODELS
/////////////////////////////////////////

/////////////////////////////////////////
// USER SCHEMA
/////////////////////////////////////////

export const UserSchema = z.object({
  role: UserRoleSchema,
  id: z.string().cuid(),
  name: z.string().nullable(),
  email: z.string().nullable(),
  emailVerified: z.coerce.date().nullable(),
  phone: z.string().nullable(),
  phoneVerified: z.coerce.date().nullable(),
  whatsapp: z.string().nullable(),
  whatsappVerified: z.coerce.date().nullable(),
  password: z.string().nullable(),
  image: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type User = z.infer<typeof UserSchema>;

/////////////////////////////////////////
// ACCOUNT SCHEMA
/////////////////////////////////////////

export const AccountSchema = z.object({
  id: z.string().cuid(),
  userId: z.string(),
  type: z.string(),
  provider: z.string(),
  providerAccountId: z.string(),
  refresh_token: z.string().nullable(),
  access_token: z.string().nullable(),
  expires_at: z.number().int().nullable(),
  token_type: z.string().nullable(),
  scope: z.string().nullable(),
  id_token: z.string().nullable(),
  session_state: z.string().nullable(),
});

export type Account = z.infer<typeof AccountSchema>;

/////////////////////////////////////////
// SERVICE PROVIDER TYPE SCHEMA
/////////////////////////////////////////

export const ServiceProviderTypeSchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type ServiceProviderType = z.infer<typeof ServiceProviderTypeSchema>;

/////////////////////////////////////////
// SERVICE PROVIDER SCHEMA
/////////////////////////////////////////

export const ServiceProviderSchema = z.object({
  languages: LanguagesSchema.array(),
  status: ServiceProviderStatusSchema,
  trialStatus: TrialStatusSchema.nullable(),
  id: z.string().cuid(),
  name: z.string(),
  userId: z.string(),
  serviceProviderTypeId: z.string(),
  bio: z.string().nullable(),
  image: z.string(),
  website: z.string().nullable(),
  email: z.string(),
  whatsapp: z.string(),
  approvedById: z.string().nullable(),
  approvedAt: z.coerce.date().nullable(),
  rejectedAt: z.coerce.date().nullable(),
  rejectionReason: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  averageRating: z.number().nullable(),
  totalReviews: z.number().int(),
  trialStarted: z.coerce.date().nullable(),
  trialEnded: z.coerce.date().nullable(),
  paymentMethodAdded: z.boolean(),
  trialReminderSent: z.boolean(),
  trialConversionDate: z.coerce.date().nullable(),
  selfPaidBookingsEnabled: z.boolean(),
});

export type ServiceProvider = z.infer<typeof ServiceProviderSchema>;

/////////////////////////////////////////
// ORGANIZATION SCHEMA
/////////////////////////////////////////

export const OrganizationSchema = z.object({
  status: OrganizationStatusSchema,
  billingModel: OrganizationBillingModelSchema,
  trialStatus: TrialStatusSchema.nullable(),
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  email: z.string().nullable(),
  phone: z.string().nullable(),
  website: z.string().nullable(),
  logo: z.string().nullable(),
  approvedById: z.string().nullable(),
  approvedAt: z.coerce.date().nullable(),
  rejectedAt: z.coerce.date().nullable(),
  rejectionReason: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  trialStarted: z.coerce.date().nullable(),
  trialEnded: z.coerce.date().nullable(),
  paymentMethodAdded: z.boolean(),
  trialReminderSent: z.boolean(),
  trialConversionDate: z.coerce.date().nullable(),
});

export type Organization = z.infer<typeof OrganizationSchema>;

/////////////////////////////////////////
// ORGANIZATION INVITATION SCHEMA
/////////////////////////////////////////

export const OrganizationInvitationSchema = z.object({
  role: OrganizationRoleSchema,
  permissions: OrganizationPermissionSchema.array(),
  status: InvitationStatusSchema,
  id: z.string().cuid(),
  organizationId: z.string(),
  email: z.string(),
  token: z.string(),
  expiresAt: z.coerce.date(),
  invitedById: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  acceptedAt: z.coerce.date().nullable(),
  membershipId: z.string().nullable(),
});

export type OrganizationInvitation = z.infer<typeof OrganizationInvitationSchema>;

/////////////////////////////////////////
// ORGANIZATION MEMBERSHIP SCHEMA
/////////////////////////////////////////

export const OrganizationMembershipSchema = z.object({
  role: OrganizationRoleSchema,
  permissions: OrganizationPermissionSchema.array(),
  status: MembershipStatusSchema,
  id: z.string().cuid(),
  organizationId: z.string(),
  userId: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type OrganizationMembership = z.infer<typeof OrganizationMembershipSchema>;

/////////////////////////////////////////
// ORGANIZATION MEMBERSHIP HISTORY SCHEMA
/////////////////////////////////////////

export const OrganizationMembershipHistorySchema = z.object({
  changeType: MembershipChangeTypeSchema,
  oldRole: OrganizationRoleSchema.nullable(),
  newRole: OrganizationRoleSchema.nullable(),
  oldPermissions: OrganizationPermissionSchema.array(),
  newPermissions: OrganizationPermissionSchema.array(),
  oldStatus: MembershipStatusSchema.nullable(),
  newStatus: MembershipStatusSchema.nullable(),
  id: z.string().cuid(),
  membershipId: z.string(),
  changedById: z.string(),
  changeReason: z.string().nullable(),
  ipAddress: z.string().nullable(),
  userAgent: z.string().nullable(),
  createdAt: z.coerce.date(),
});

export type OrganizationMembershipHistory = z.infer<typeof OrganizationMembershipHistorySchema>;

/////////////////////////////////////////
// LOCATION SCHEMA
/////////////////////////////////////////

export const LocationSchema = z.object({
  id: z.string().cuid(),
  organizationId: z.string(),
  name: z.string(),
  googlePlaceId: z.string(),
  formattedAddress: z.string(),
  coordinates: JsonValueSchema,
  addressComponents: JsonValueSchema,
  city: z.string(),
  country: z.string(),
  phone: z.string().nullable(),
  email: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Location = z.infer<typeof LocationSchema>;

/////////////////////////////////////////
// ORGANIZATION PROVIDER CONNECTION SCHEMA
/////////////////////////////////////////

export const OrganizationProviderConnectionSchema = z.object({
  status: ConnectionStatusSchema,
  defaultBilledBy: BillingEntitySchema,
  id: z.string().cuid(),
  organizationId: z.string(),
  serviceProviderId: z.string(),
  requestedAt: z.coerce.date(),
  acceptedAt: z.coerce.date().nullable(),
});

export type OrganizationProviderConnection = z.infer<typeof OrganizationProviderConnectionSchema>;

/////////////////////////////////////////
// SUBSCRIPTION SCHEMA
/////////////////////////////////////////

export const SubscriptionSchema = z.object({
  status: SubscriptionStatusSchema,
  type: SubscriptionTypeSchema,
  id: z.string().cuid(),
  organizationId: z.string().nullable(),
  locationId: z.string().nullable(),
  serviceProviderId: z.string().nullable(),
  planId: z.string(),
  isActive: z.boolean(),
  trialStart: z.coerce.date().nullable(),
  trialEnd: z.coerce.date().nullable(),
  startDate: z.coerce.date(),
  endDate: z.coerce.date().nullable(),
  cancelledAt: z.coerce.date().nullable(),
  cancelReason: z.string().nullable(),
  stripeCustomerId: z.string().nullable(),
  stripeSubscriptionId: z.string().nullable(),
  currentMonthSlots: z.number().int(),
  billingCycleStart: z.coerce.date(),
  billingCycleEnd: z.coerce.date(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Subscription = z.infer<typeof SubscriptionSchema>;

/////////////////////////////////////////
// SUBSCRIPTION PLAN SCHEMA
/////////////////////////////////////////

export const SubscriptionPlanSchema = z.object({
  interval: BillingIntervalSchema,
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  /**
   * // e.g., R300
   */
  basePrice: z.number().positive(),
  currency: z.string(),
  includedSlots: z.number().int(),
  tierPricing: JsonValueSchema,
  features: JsonValueSchema.nullable(),
  maxProviders: z.number().int().nullable(),
  maxLocations: z.number().int().nullable(),
  isActive: z.boolean(),
  stripePriceId: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type SubscriptionPlan = z.infer<typeof SubscriptionPlanSchema>;

/////////////////////////////////////////
// USAGE RECORD SCHEMA
/////////////////////////////////////////

export const UsageRecordSchema = z.object({
  slotStatus: SlotStatusSchema,
  id: z.string().cuid(),
  subscriptionId: z.string(),
  slotId: z.string(),
  slotDate: z.coerce.date(),
  billingCycle: z.string(),
  serviceProviderId: z.string(),
  serviceId: z.string(),
  tierUsed: z.number().int(),
  priceCharged: z.number().positive(),
  processed: z.boolean(),
  processedAt: z.coerce.date().nullable(),
  createdAt: z.coerce.date(),
});

export type UsageRecord = z.infer<typeof UsageRecordSchema>;

/////////////////////////////////////////
// PAYMENT SCHEMA
/////////////////////////////////////////

export const PaymentSchema = z.object({
  status: PaymentStatusSchema,
  id: z.string().cuid(),
  subscriptionId: z.string(),
  amount: z.number().positive(),
  /**
   * // Base subscription fee
   */
  baseAmount: z.number().positive().nullable(),
  /**
   * // Usage-based charges
   */
  usageAmount: z.number().positive().nullable(),
  currency: z.string(),
  stripePaymentId: z.string().nullable(),
  stripeInvoiceId: z.string().nullable(),
  paidAt: z.coerce.date().nullable(),
  failureReason: z.string().nullable(),
  billingPeriodStart: z.coerce.date().nullable(),
  billingPeriodEnd: z.coerce.date().nullable(),
  slotsCovered: z.number().int().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Payment = z.infer<typeof PaymentSchema>;

/////////////////////////////////////////
// REQUIREMENT TYPE SCHEMA
/////////////////////////////////////////

export const RequirementTypeSchema = z.object({
  validationType: RequirementValidationTypeSchema,
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  isRequired: z.boolean(),
  validationConfig: JsonValueSchema.nullable(),
  displayPriority: z.number().int(),
  serviceProviderTypeId: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type RequirementType = z.infer<typeof RequirementTypeSchema>;

/////////////////////////////////////////
// REQUIREMENT SUBMISSION SCHEMA
/////////////////////////////////////////

export const RequirementSubmissionSchema = z.object({
  status: RequirementsValidationStatusSchema,
  id: z.string().cuid(),
  requirementTypeId: z.string(),
  serviceProviderId: z.string(),
  documentUrl: z.string().nullable(),
  documentMetadata: JsonValueSchema.nullable(),
  expiresAt: z.coerce.date().nullable(),
  notes: z.string().nullable(),
  validatedAt: z.coerce.date().nullable(),
  validatedById: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type RequirementSubmission = z.infer<typeof RequirementSubmissionSchema>;

/////////////////////////////////////////
// SERVICE SCHEMA
/////////////////////////////////////////

export const ServiceSchema = z.object({
  id: z.string().cuid(),
  name: z.string(),
  description: z.string().nullable(),
  serviceProviderTypeId: z.string(),
  displayPriority: z.number().int(),
  defaultDuration: z.number().int(),
  defaultPrice: z.number().positive(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Service = z.infer<typeof ServiceSchema>;

/////////////////////////////////////////
// SERVICE AVAILABILITY CONFIG SCHEMA
/////////////////////////////////////////

export const ServiceAvailabilityConfigSchema = z.object({
  id: z.string().cuid(),
  serviceId: z.string(),
  serviceProviderId: z.string(),
  duration: z.number().int(),
  price: z.number().positive(),
  isOnlineAvailable: z.boolean(),
  isInPerson: z.boolean(),
  location: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type ServiceAvailabilityConfig = z.infer<typeof ServiceAvailabilityConfigSchema>;

/////////////////////////////////////////
// AVAILABILITY SCHEMA
/////////////////////////////////////////

export const AvailabilitySchema = z.object({
  status: AvailabilityStatusSchema,
  billingEntity: BillingEntitySchema.nullable(),
  id: z.string().cuid(),
  serviceProviderId: z.string(),
  organizationId: z.string().nullable(),
  locationId: z.string().nullable(),
  connectionId: z.string().nullable(),
  startTime: z.coerce.date(),
  endTime: z.coerce.date(),
  createdById: z.string(),
  createdByMembershipId: z.string().nullable(),
  isProviderCreated: z.boolean(),
  acceptedById: z.string().nullable(),
  acceptedAt: z.coerce.date().nullable(),
  requiresConfirmation: z.boolean(),
  defaultSubscriptionId: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Availability = z.infer<typeof AvailabilitySchema>;

/////////////////////////////////////////
// CALCULATED AVAILABILITY SLOT SCHEMA
/////////////////////////////////////////

export const CalculatedAvailabilitySlotSchema = z.object({
  status: SlotStatusSchema,
  id: z.string().cuid(),
  availabilityId: z.string(),
  serviceId: z.string(),
  serviceConfigId: z.string(),
  startTime: z.coerce.date(),
  endTime: z.coerce.date(),
  lastCalculated: z.coerce.date(),
  billedToSubscriptionId: z.string().nullable(),
  blockedByEventId: z.string().nullable(),
  version: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type CalculatedAvailabilitySlot = z.infer<typeof CalculatedAvailabilitySlotSchema>;

/////////////////////////////////////////
// BOOKING SCHEMA
/////////////////////////////////////////

export const BookingSchema = z.object({
  status: BookingStatusSchema,
  id: z.string().cuid(),
  slotId: z.string().nullable(),
  createdById: z.string().nullable(),
  createdByMembershipId: z.string().nullable(),
  isProviderCreated: z.boolean(),
  isGuestBooking: z.boolean(),
  isGuestSelfBooking: z.boolean(),
  confirmedById: z.string().nullable(),
  confirmedAt: z.coerce.date().nullable(),
  clientId: z.string().nullable(),
  guestName: z.string().nullable(),
  guestEmail: z.string().nullable(),
  guestPhone: z.string().nullable(),
  guestWhatsapp: z.string().nullable(),
  price: z.number().positive(),
  isOnline: z.boolean(),
  isInPerson: z.boolean(),
  notes: z.string().nullable(),
  meetLink: z.string().nullable(),
  calendarEventId: z.string().nullable(),
  version: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Booking = z.infer<typeof BookingSchema>;

/////////////////////////////////////////
// COMMUNICATION PREFERENCE SCHEMA
/////////////////////////////////////////

export const CommunicationPreferenceSchema = z.object({
  id: z.string().cuid(),
  userId: z.string(),
  email: z.boolean(),
  sms: z.boolean(),
  whatsapp: z.boolean(),
  phoneNumber: z.string().nullable(),
  whatsappNumber: z.string().nullable(),
  reminderHours: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type CommunicationPreference = z.infer<typeof CommunicationPreferenceSchema>;

/////////////////////////////////////////
// COMMUNICATION LOG SCHEMA
/////////////////////////////////////////

export const CommunicationLogSchema = z.object({
  type: CommunicationTypeSchema,
  channel: CommunicationChannelSchema,
  id: z.string().cuid(),
  bookingId: z.string().nullable(),
  bookingReference: z.string().nullable(),
  serviceProviderName: z.string().nullable(),
  clientName: z.string().nullable(),
  serviceName: z.string().nullable(),
  appointmentTime: z.coerce.date().nullable(),
  content: z.string(),
  status: z.string(),
  sentAt: z.coerce.date(),
  deliveredAt: z.coerce.date().nullable(),
});

export type CommunicationLog = z.infer<typeof CommunicationLogSchema>;

/////////////////////////////////////////
// CALENDAR INTEGRATION SCHEMA
/////////////////////////////////////////

export const CalendarIntegrationSchema = z.object({
  syncDirection: CalendarSyncDirectionSchema,
  id: z.string().cuid(),
  serviceProviderId: z.string(),
  provider: z.string(),
  accessToken: z.string(),
  refreshToken: z.string(),
  expiresAt: z.coerce.date(),
  calendarId: z.string().nullable(),
  syncEnabled: z.boolean(),
  lastSyncedAt: z.coerce.date().nullable(),
  googleEmail: z.string().nullable(),
  grantedScopes: z.string().array(),
  meetSettings: JsonValueSchema.nullable(),
  webhookChannelId: z.string().nullable(),
  webhookResourceId: z.string().nullable(),
  webhookExpiresAt: z.coerce.date().nullable(),
  nextSyncToken: z.string().nullable(),
  blockingEventTypes: z.string().array(),
  autoCreateMeetLinks: z.boolean(),
  backgroundSyncEnabled: z.boolean(),
  syncIntervalMinutes: z.number().int(),
  lastFullSyncAt: z.coerce.date().nullable(),
  syncFailureCount: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type CalendarIntegration = z.infer<typeof CalendarIntegrationSchema>;

/////////////////////////////////////////
// CALENDAR EVENT SCHEMA
/////////////////////////////////////////

export const CalendarEventSchema = z.object({
  syncStatus: CalendarEventSyncStatusSchema,
  id: z.string().cuid(),
  calendarIntegrationId: z.string(),
  externalEventId: z.string(),
  externalCalendarId: z.string(),
  etag: z.string().nullable(),
  title: z.string(),
  startTime: z.coerce.date(),
  endTime: z.coerce.date(),
  isAllDay: z.boolean(),
  lastSyncedAt: z.coerce.date(),
  eventType: z.string().nullable(),
  blocksAvailability: z.boolean(),
  lastModifiedInExternal: z.coerce.date().nullable(),
  hasConflict: z.boolean(),
  conflictDetails: z.string().nullable(),
  conflictResolvedAt: z.coerce.date().nullable(),
  version: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type CalendarEvent = z.infer<typeof CalendarEventSchema>;

/////////////////////////////////////////
// CALENDAR SYNC OPERATION SCHEMA
/////////////////////////////////////////

export const CalendarSyncOperationSchema = z.object({
  operationType: CalendarSyncOperationTypeSchema,
  sourceSystem: CalendarSyncSourceSchema,
  status: CalendarSyncStatusSchema,
  entityType: CalendarEntityTypeSchema,
  conflictResolution: ConflictResolutionSchema.nullable(),
  id: z.string().cuid(),
  calendarIntegrationId: z.string(),
  entityId: z.string().nullable(),
  externalEventId: z.string().nullable(),
  startedAt: z.coerce.date(),
  completedAt: z.coerce.date().nullable(),
  retryCount: z.number().int(),
  maxRetries: z.number().int(),
  errorMessage: z.string().nullable(),
  syncWindowStart: z.coerce.date().nullable(),
  syncWindowEnd: z.coerce.date().nullable(),
  eventsProcessed: z.number().int(),
  eventsSucceeded: z.number().int(),
  eventsFailed: z.number().int(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type CalendarSyncOperation = z.infer<typeof CalendarSyncOperationSchema>;

/////////////////////////////////////////
// MEET SESSION SCHEMA
/////////////////////////////////////////

export const MeetSessionSchema = z.object({
  status: MeetSessionStatusSchema,
  id: z.string().cuid(),
  bookingId: z.string(),
  meetLink: z.string(),
  eventId: z.string(),
  joinCode: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type MeetSession = z.infer<typeof MeetSessionSchema>;

/////////////////////////////////////////
// REVIEW SCHEMA
/////////////////////////////////////////

export const ReviewSchema = z.object({
  status: ReviewStatusSchema,
  id: z.string().cuid(),
  serviceProviderId: z.string(),
  clientId: z.string(),
  bookingId: z.string(),
  rating: z.number().int(),
  comment: z.string().nullable(),
  response: z.string().nullable(),
  isPublic: z.boolean(),
  googleReviewId: z.string().nullable(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

export type Review = z.infer<typeof ReviewSchema>;

/////////////////////////////////////////
// SELECT & INCLUDE
/////////////////////////////////////////

// USER
//------------------------------------------------------

export const UserIncludeSchema: z.ZodType<Prisma.UserInclude> = z
  .object({
    accounts: z.union([z.boolean(), z.lazy(() => AccountFindManyArgsSchema)]).optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    bookingsAsClient: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    bookingsCreated: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    bookingsConfirmed: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    communicationPreferences: z
      .union([z.boolean(), z.lazy(() => CommunicationPreferenceFindManyArgsSchema)])
      .optional(),
    organizationMemberships: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipFindManyArgsSchema)])
      .optional(),
    membershipHistoryChanges: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipHistoryFindManyArgsSchema)])
      .optional(),
    availabilitiesCreated: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    availabilitiesAccepted: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    organizationsApproved: z
      .union([z.boolean(), z.lazy(() => OrganizationFindManyArgsSchema)])
      .optional(),
    providersApproved: z
      .union([z.boolean(), z.lazy(() => ServiceProviderFindManyArgsSchema)])
      .optional(),
    sentInvitations: z
      .union([z.boolean(), z.lazy(() => OrganizationInvitationFindManyArgsSchema)])
      .optional(),
    reviews: z.union([z.boolean(), z.lazy(() => ReviewFindManyArgsSchema)]).optional(),
    validatedRequirements: z
      .union([z.boolean(), z.lazy(() => RequirementSubmissionFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const UserArgsSchema: z.ZodType<Prisma.UserDefaultArgs> = z
  .object({
    select: z.lazy(() => UserSelectSchema).optional(),
    include: z.lazy(() => UserIncludeSchema).optional(),
  })
  .strict();

export const UserCountOutputTypeArgsSchema: z.ZodType<Prisma.UserCountOutputTypeDefaultArgs> = z
  .object({
    select: z.lazy(() => UserCountOutputTypeSelectSchema).nullish(),
  })
  .strict();

export const UserCountOutputTypeSelectSchema: z.ZodType<Prisma.UserCountOutputTypeSelect> = z
  .object({
    accounts: z.boolean().optional(),
    bookingsAsClient: z.boolean().optional(),
    bookingsCreated: z.boolean().optional(),
    bookingsConfirmed: z.boolean().optional(),
    communicationPreferences: z.boolean().optional(),
    organizationMemberships: z.boolean().optional(),
    membershipHistoryChanges: z.boolean().optional(),
    availabilitiesCreated: z.boolean().optional(),
    availabilitiesAccepted: z.boolean().optional(),
    organizationsApproved: z.boolean().optional(),
    providersApproved: z.boolean().optional(),
    sentInvitations: z.boolean().optional(),
    reviews: z.boolean().optional(),
    validatedRequirements: z.boolean().optional(),
  })
  .strict();

export const UserSelectSchema: z.ZodType<Prisma.UserSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    email: z.boolean().optional(),
    emailVerified: z.boolean().optional(),
    phone: z.boolean().optional(),
    phoneVerified: z.boolean().optional(),
    whatsapp: z.boolean().optional(),
    whatsappVerified: z.boolean().optional(),
    password: z.boolean().optional(),
    image: z.boolean().optional(),
    role: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    accounts: z.union([z.boolean(), z.lazy(() => AccountFindManyArgsSchema)]).optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    bookingsAsClient: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    bookingsCreated: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    bookingsConfirmed: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    communicationPreferences: z
      .union([z.boolean(), z.lazy(() => CommunicationPreferenceFindManyArgsSchema)])
      .optional(),
    organizationMemberships: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipFindManyArgsSchema)])
      .optional(),
    membershipHistoryChanges: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipHistoryFindManyArgsSchema)])
      .optional(),
    availabilitiesCreated: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    availabilitiesAccepted: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    organizationsApproved: z
      .union([z.boolean(), z.lazy(() => OrganizationFindManyArgsSchema)])
      .optional(),
    providersApproved: z
      .union([z.boolean(), z.lazy(() => ServiceProviderFindManyArgsSchema)])
      .optional(),
    sentInvitations: z
      .union([z.boolean(), z.lazy(() => OrganizationInvitationFindManyArgsSchema)])
      .optional(),
    reviews: z.union([z.boolean(), z.lazy(() => ReviewFindManyArgsSchema)]).optional(),
    validatedRequirements: z
      .union([z.boolean(), z.lazy(() => RequirementSubmissionFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => UserCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// ACCOUNT
//------------------------------------------------------

export const AccountIncludeSchema: z.ZodType<Prisma.AccountInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

export const AccountArgsSchema: z.ZodType<Prisma.AccountDefaultArgs> = z
  .object({
    select: z.lazy(() => AccountSelectSchema).optional(),
    include: z.lazy(() => AccountIncludeSchema).optional(),
  })
  .strict();

export const AccountSelectSchema: z.ZodType<Prisma.AccountSelect> = z
  .object({
    id: z.boolean().optional(),
    userId: z.boolean().optional(),
    type: z.boolean().optional(),
    provider: z.boolean().optional(),
    providerAccountId: z.boolean().optional(),
    refresh_token: z.boolean().optional(),
    access_token: z.boolean().optional(),
    expires_at: z.boolean().optional(),
    token_type: z.boolean().optional(),
    scope: z.boolean().optional(),
    id_token: z.boolean().optional(),
    session_state: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

// SERVICE PROVIDER TYPE
//------------------------------------------------------

export const ServiceProviderTypeIncludeSchema: z.ZodType<Prisma.ServiceProviderTypeInclude> = z
  .object({
    requirements: z
      .union([z.boolean(), z.lazy(() => RequirementTypeFindManyArgsSchema)])
      .optional(),
    services: z.union([z.boolean(), z.lazy(() => ServiceFindManyArgsSchema)]).optional(),
    serviceProviders: z
      .union([z.boolean(), z.lazy(() => ServiceProviderFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const ServiceProviderTypeArgsSchema: z.ZodType<Prisma.ServiceProviderTypeDefaultArgs> = z
  .object({
    select: z.lazy(() => ServiceProviderTypeSelectSchema).optional(),
    include: z.lazy(() => ServiceProviderTypeIncludeSchema).optional(),
  })
  .strict();

export const ServiceProviderTypeCountOutputTypeArgsSchema: z.ZodType<Prisma.ServiceProviderTypeCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ServiceProviderTypeCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const ServiceProviderTypeCountOutputTypeSelectSchema: z.ZodType<Prisma.ServiceProviderTypeCountOutputTypeSelect> =
  z
    .object({
      requirements: z.boolean().optional(),
      services: z.boolean().optional(),
      serviceProviders: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderTypeSelectSchema: z.ZodType<Prisma.ServiceProviderTypeSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    requirements: z
      .union([z.boolean(), z.lazy(() => RequirementTypeFindManyArgsSchema)])
      .optional(),
    services: z.union([z.boolean(), z.lazy(() => ServiceFindManyArgsSchema)]).optional(),
    serviceProviders: z
      .union([z.boolean(), z.lazy(() => ServiceProviderFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// SERVICE PROVIDER
//------------------------------------------------------

export const ServiceProviderIncludeSchema: z.ZodType<Prisma.ServiceProviderInclude> = z
  .object({
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    serviceProviderType: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeArgsSchema)])
      .optional(),
    approvedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    reviews: z.union([z.boolean(), z.lazy(() => ReviewFindManyArgsSchema)]).optional(),
    requirementSubmissions: z
      .union([z.boolean(), z.lazy(() => RequirementSubmissionFindManyArgsSchema)])
      .optional(),
    services: z.union([z.boolean(), z.lazy(() => ServiceFindManyArgsSchema)]).optional(),
    availabilityConfigs: z
      .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigFindManyArgsSchema)])
      .optional(),
    availabilities: z.union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)]).optional(),
    calendarIntegration: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationArgsSchema)])
      .optional(),
    providerConnections: z
      .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionFindManyArgsSchema)])
      .optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ServiceProviderCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const ServiceProviderArgsSchema: z.ZodType<Prisma.ServiceProviderDefaultArgs> = z
  .object({
    select: z.lazy(() => ServiceProviderSelectSchema).optional(),
    include: z.lazy(() => ServiceProviderIncludeSchema).optional(),
  })
  .strict();

export const ServiceProviderCountOutputTypeArgsSchema: z.ZodType<Prisma.ServiceProviderCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ServiceProviderCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const ServiceProviderCountOutputTypeSelectSchema: z.ZodType<Prisma.ServiceProviderCountOutputTypeSelect> =
  z
    .object({
      reviews: z.boolean().optional(),
      requirementSubmissions: z.boolean().optional(),
      services: z.boolean().optional(),
      availabilityConfigs: z.boolean().optional(),
      availabilities: z.boolean().optional(),
      providerConnections: z.boolean().optional(),
      subscriptions: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderSelectSchema: z.ZodType<Prisma.ServiceProviderSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    userId: z.boolean().optional(),
    serviceProviderTypeId: z.boolean().optional(),
    bio: z.boolean().optional(),
    image: z.boolean().optional(),
    languages: z.boolean().optional(),
    website: z.boolean().optional(),
    email: z.boolean().optional(),
    whatsapp: z.boolean().optional(),
    status: z.boolean().optional(),
    approvedById: z.boolean().optional(),
    approvedAt: z.boolean().optional(),
    rejectedAt: z.boolean().optional(),
    rejectionReason: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    averageRating: z.boolean().optional(),
    totalReviews: z.boolean().optional(),
    trialStarted: z.boolean().optional(),
    trialEnded: z.boolean().optional(),
    trialStatus: z.boolean().optional(),
    paymentMethodAdded: z.boolean().optional(),
    trialReminderSent: z.boolean().optional(),
    trialConversionDate: z.boolean().optional(),
    selfPaidBookingsEnabled: z.boolean().optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    serviceProviderType: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeArgsSchema)])
      .optional(),
    approvedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    reviews: z.union([z.boolean(), z.lazy(() => ReviewFindManyArgsSchema)]).optional(),
    requirementSubmissions: z
      .union([z.boolean(), z.lazy(() => RequirementSubmissionFindManyArgsSchema)])
      .optional(),
    services: z.union([z.boolean(), z.lazy(() => ServiceFindManyArgsSchema)]).optional(),
    availabilityConfigs: z
      .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigFindManyArgsSchema)])
      .optional(),
    availabilities: z.union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)]).optional(),
    calendarIntegration: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationArgsSchema)])
      .optional(),
    providerConnections: z
      .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionFindManyArgsSchema)])
      .optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => ServiceProviderCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// ORGANIZATION
//------------------------------------------------------

export const OrganizationIncludeSchema: z.ZodType<Prisma.OrganizationInclude> = z
  .object({
    approvedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    invitations: z
      .union([z.boolean(), z.lazy(() => OrganizationInvitationFindManyArgsSchema)])
      .optional(),
    memberships: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipFindManyArgsSchema)])
      .optional(),
    providerConnections: z
      .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionFindManyArgsSchema)])
      .optional(),
    locations: z.union([z.boolean(), z.lazy(() => LocationFindManyArgsSchema)]).optional(),
    availabilities: z.union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)]).optional(),
    _count: z.union([z.boolean(), z.lazy(() => OrganizationCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const OrganizationArgsSchema: z.ZodType<Prisma.OrganizationDefaultArgs> = z
  .object({
    select: z.lazy(() => OrganizationSelectSchema).optional(),
    include: z.lazy(() => OrganizationIncludeSchema).optional(),
  })
  .strict();

export const OrganizationCountOutputTypeArgsSchema: z.ZodType<Prisma.OrganizationCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const OrganizationCountOutputTypeSelectSchema: z.ZodType<Prisma.OrganizationCountOutputTypeSelect> =
  z
    .object({
      subscriptions: z.boolean().optional(),
      invitations: z.boolean().optional(),
      memberships: z.boolean().optional(),
      providerConnections: z.boolean().optional(),
      locations: z.boolean().optional(),
      availabilities: z.boolean().optional(),
    })
    .strict();

export const OrganizationSelectSchema: z.ZodType<Prisma.OrganizationSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    email: z.boolean().optional(),
    phone: z.boolean().optional(),
    website: z.boolean().optional(),
    logo: z.boolean().optional(),
    status: z.boolean().optional(),
    approvedById: z.boolean().optional(),
    approvedAt: z.boolean().optional(),
    rejectedAt: z.boolean().optional(),
    rejectionReason: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    billingModel: z.boolean().optional(),
    trialStarted: z.boolean().optional(),
    trialEnded: z.boolean().optional(),
    trialStatus: z.boolean().optional(),
    paymentMethodAdded: z.boolean().optional(),
    trialReminderSent: z.boolean().optional(),
    trialConversionDate: z.boolean().optional(),
    approvedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    invitations: z
      .union([z.boolean(), z.lazy(() => OrganizationInvitationFindManyArgsSchema)])
      .optional(),
    memberships: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipFindManyArgsSchema)])
      .optional(),
    providerConnections: z
      .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionFindManyArgsSchema)])
      .optional(),
    locations: z.union([z.boolean(), z.lazy(() => LocationFindManyArgsSchema)]).optional(),
    availabilities: z.union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)]).optional(),
    _count: z.union([z.boolean(), z.lazy(() => OrganizationCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// ORGANIZATION INVITATION
//------------------------------------------------------

export const OrganizationInvitationIncludeSchema: z.ZodType<Prisma.OrganizationInvitationInclude> =
  z
    .object({
      organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
      invitedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      membership: z.union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)]).optional(),
    })
    .strict();

export const OrganizationInvitationArgsSchema: z.ZodType<Prisma.OrganizationInvitationDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationInvitationSelectSchema).optional(),
      include: z.lazy(() => OrganizationInvitationIncludeSchema).optional(),
    })
    .strict();

export const OrganizationInvitationSelectSchema: z.ZodType<Prisma.OrganizationInvitationSelect> = z
  .object({
    id: z.boolean().optional(),
    organizationId: z.boolean().optional(),
    email: z.boolean().optional(),
    role: z.boolean().optional(),
    permissions: z.boolean().optional(),
    token: z.boolean().optional(),
    expiresAt: z.boolean().optional(),
    invitedById: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    acceptedAt: z.boolean().optional(),
    membershipId: z.boolean().optional(),
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    invitedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    membership: z.union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)]).optional(),
  })
  .strict();

// ORGANIZATION MEMBERSHIP
//------------------------------------------------------

export const OrganizationMembershipIncludeSchema: z.ZodType<Prisma.OrganizationMembershipInclude> =
  z
    .object({
      organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
      invitation: z.union([z.boolean(), z.lazy(() => OrganizationInvitationArgsSchema)]).optional(),
      bookingsCreated: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
      availabilitiesCreated: z
        .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
        .optional(),
      history: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipHistoryFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipCountOutputTypeArgsSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipArgsSchema: z.ZodType<Prisma.OrganizationMembershipDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationMembershipSelectSchema).optional(),
      include: z.lazy(() => OrganizationMembershipIncludeSchema).optional(),
    })
    .strict();

export const OrganizationMembershipCountOutputTypeArgsSchema: z.ZodType<Prisma.OrganizationMembershipCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationMembershipCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const OrganizationMembershipCountOutputTypeSelectSchema: z.ZodType<Prisma.OrganizationMembershipCountOutputTypeSelect> =
  z
    .object({
      bookingsCreated: z.boolean().optional(),
      availabilitiesCreated: z.boolean().optional(),
      history: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipSelectSchema: z.ZodType<Prisma.OrganizationMembershipSelect> = z
  .object({
    id: z.boolean().optional(),
    organizationId: z.boolean().optional(),
    userId: z.boolean().optional(),
    role: z.boolean().optional(),
    permissions: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    invitation: z.union([z.boolean(), z.lazy(() => OrganizationInvitationArgsSchema)]).optional(),
    bookingsCreated: z.union([z.boolean(), z.lazy(() => BookingFindManyArgsSchema)]).optional(),
    availabilitiesCreated: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    history: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipHistoryFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// ORGANIZATION MEMBERSHIP HISTORY
//------------------------------------------------------

export const OrganizationMembershipHistoryIncludeSchema: z.ZodType<Prisma.OrganizationMembershipHistoryInclude> =
  z
    .object({
      membership: z.union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)]).optional(),
      changedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationMembershipHistorySelectSchema).optional(),
      include: z.lazy(() => OrganizationMembershipHistoryIncludeSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistorySelectSchema: z.ZodType<Prisma.OrganizationMembershipHistorySelect> =
  z
    .object({
      id: z.boolean().optional(),
      membershipId: z.boolean().optional(),
      changeType: z.boolean().optional(),
      oldRole: z.boolean().optional(),
      newRole: z.boolean().optional(),
      oldPermissions: z.boolean().optional(),
      newPermissions: z.boolean().optional(),
      oldStatus: z.boolean().optional(),
      newStatus: z.boolean().optional(),
      changedById: z.boolean().optional(),
      changeReason: z.boolean().optional(),
      ipAddress: z.boolean().optional(),
      userAgent: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      membership: z.union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)]).optional(),
      changedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

// LOCATION
//------------------------------------------------------

export const LocationIncludeSchema: z.ZodType<Prisma.LocationInclude> = z
  .object({
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    availabilities: z.union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)]).optional(),
    _count: z.union([z.boolean(), z.lazy(() => LocationCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const LocationArgsSchema: z.ZodType<Prisma.LocationDefaultArgs> = z
  .object({
    select: z.lazy(() => LocationSelectSchema).optional(),
    include: z.lazy(() => LocationIncludeSchema).optional(),
  })
  .strict();

export const LocationCountOutputTypeArgsSchema: z.ZodType<Prisma.LocationCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => LocationCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const LocationCountOutputTypeSelectSchema: z.ZodType<Prisma.LocationCountOutputTypeSelect> =
  z
    .object({
      subscriptions: z.boolean().optional(),
      availabilities: z.boolean().optional(),
    })
    .strict();

export const LocationSelectSchema: z.ZodType<Prisma.LocationSelect> = z
  .object({
    id: z.boolean().optional(),
    organizationId: z.boolean().optional(),
    name: z.boolean().optional(),
    googlePlaceId: z.boolean().optional(),
    formattedAddress: z.boolean().optional(),
    coordinates: z.boolean().optional(),
    addressComponents: z.boolean().optional(),
    city: z.boolean().optional(),
    country: z.boolean().optional(),
    phone: z.boolean().optional(),
    email: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    availabilities: z.union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)]).optional(),
    _count: z.union([z.boolean(), z.lazy(() => LocationCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// ORGANIZATION PROVIDER CONNECTION
//------------------------------------------------------

export const OrganizationProviderConnectionIncludeSchema: z.ZodType<Prisma.OrganizationProviderConnectionInclude> =
  z
    .object({
      organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
      serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
      availabilities: z
        .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionCountOutputTypeArgsSchema)])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationProviderConnectionSelectSchema).optional(),
      include: z.lazy(() => OrganizationProviderConnectionIncludeSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionCountOutputTypeArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => OrganizationProviderConnectionCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const OrganizationProviderConnectionCountOutputTypeSelectSchema: z.ZodType<Prisma.OrganizationProviderConnectionCountOutputTypeSelect> =
  z
    .object({
      availabilities: z.boolean().optional(),
    })
    .strict();

export const OrganizationProviderConnectionSelectSchema: z.ZodType<Prisma.OrganizationProviderConnectionSelect> =
  z
    .object({
      id: z.boolean().optional(),
      organizationId: z.boolean().optional(),
      serviceProviderId: z.boolean().optional(),
      status: z.boolean().optional(),
      defaultBilledBy: z.boolean().optional(),
      requestedAt: z.boolean().optional(),
      acceptedAt: z.boolean().optional(),
      organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
      serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
      availabilities: z
        .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionCountOutputTypeArgsSchema)])
        .optional(),
    })
    .strict();

// SUBSCRIPTION
//------------------------------------------------------

export const SubscriptionIncludeSchema: z.ZodType<Prisma.SubscriptionInclude> = z
  .object({
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    location: z.union([z.boolean(), z.lazy(() => LocationArgsSchema)]).optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    plan: z.union([z.boolean(), z.lazy(() => SubscriptionPlanArgsSchema)]).optional(),
    payments: z.union([z.boolean(), z.lazy(() => PaymentFindManyArgsSchema)]).optional(),
    usageRecords: z.union([z.boolean(), z.lazy(() => UsageRecordFindManyArgsSchema)]).optional(),
    billedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    defaultForAvailabilities: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => SubscriptionCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const SubscriptionArgsSchema: z.ZodType<Prisma.SubscriptionDefaultArgs> = z
  .object({
    select: z.lazy(() => SubscriptionSelectSchema).optional(),
    include: z.lazy(() => SubscriptionIncludeSchema).optional(),
  })
  .strict();

export const SubscriptionCountOutputTypeArgsSchema: z.ZodType<Prisma.SubscriptionCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => SubscriptionCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const SubscriptionCountOutputTypeSelectSchema: z.ZodType<Prisma.SubscriptionCountOutputTypeSelect> =
  z
    .object({
      payments: z.boolean().optional(),
      usageRecords: z.boolean().optional(),
      billedSlots: z.boolean().optional(),
      defaultForAvailabilities: z.boolean().optional(),
    })
    .strict();

export const SubscriptionSelectSchema: z.ZodType<Prisma.SubscriptionSelect> = z
  .object({
    id: z.boolean().optional(),
    organizationId: z.boolean().optional(),
    locationId: z.boolean().optional(),
    serviceProviderId: z.boolean().optional(),
    status: z.boolean().optional(),
    type: z.boolean().optional(),
    planId: z.boolean().optional(),
    isActive: z.boolean().optional(),
    trialStart: z.boolean().optional(),
    trialEnd: z.boolean().optional(),
    startDate: z.boolean().optional(),
    endDate: z.boolean().optional(),
    cancelledAt: z.boolean().optional(),
    cancelReason: z.boolean().optional(),
    stripeCustomerId: z.boolean().optional(),
    stripeSubscriptionId: z.boolean().optional(),
    currentMonthSlots: z.boolean().optional(),
    billingCycleStart: z.boolean().optional(),
    billingCycleEnd: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    location: z.union([z.boolean(), z.lazy(() => LocationArgsSchema)]).optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    plan: z.union([z.boolean(), z.lazy(() => SubscriptionPlanArgsSchema)]).optional(),
    payments: z.union([z.boolean(), z.lazy(() => PaymentFindManyArgsSchema)]).optional(),
    usageRecords: z.union([z.boolean(), z.lazy(() => UsageRecordFindManyArgsSchema)]).optional(),
    billedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    defaultForAvailabilities: z
      .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => SubscriptionCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// SUBSCRIPTION PLAN
//------------------------------------------------------

export const SubscriptionPlanIncludeSchema: z.ZodType<Prisma.SubscriptionPlanInclude> = z
  .object({
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => SubscriptionPlanCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const SubscriptionPlanArgsSchema: z.ZodType<Prisma.SubscriptionPlanDefaultArgs> = z
  .object({
    select: z.lazy(() => SubscriptionPlanSelectSchema).optional(),
    include: z.lazy(() => SubscriptionPlanIncludeSchema).optional(),
  })
  .strict();

export const SubscriptionPlanCountOutputTypeArgsSchema: z.ZodType<Prisma.SubscriptionPlanCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => SubscriptionPlanCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const SubscriptionPlanCountOutputTypeSelectSchema: z.ZodType<Prisma.SubscriptionPlanCountOutputTypeSelect> =
  z
    .object({
      subscriptions: z.boolean().optional(),
    })
    .strict();

export const SubscriptionPlanSelectSchema: z.ZodType<Prisma.SubscriptionPlanSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    basePrice: z.boolean().optional(),
    currency: z.boolean().optional(),
    interval: z.boolean().optional(),
    includedSlots: z.boolean().optional(),
    tierPricing: z.boolean().optional(),
    features: z.boolean().optional(),
    maxProviders: z.boolean().optional(),
    maxLocations: z.boolean().optional(),
    isActive: z.boolean().optional(),
    stripePriceId: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    subscriptions: z.union([z.boolean(), z.lazy(() => SubscriptionFindManyArgsSchema)]).optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => SubscriptionPlanCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// USAGE RECORD
//------------------------------------------------------

export const UsageRecordIncludeSchema: z.ZodType<Prisma.UsageRecordInclude> = z
  .object({
    subscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
  })
  .strict();

export const UsageRecordArgsSchema: z.ZodType<Prisma.UsageRecordDefaultArgs> = z
  .object({
    select: z.lazy(() => UsageRecordSelectSchema).optional(),
    include: z.lazy(() => UsageRecordIncludeSchema).optional(),
  })
  .strict();

export const UsageRecordSelectSchema: z.ZodType<Prisma.UsageRecordSelect> = z
  .object({
    id: z.boolean().optional(),
    subscriptionId: z.boolean().optional(),
    slotId: z.boolean().optional(),
    slotDate: z.boolean().optional(),
    slotStatus: z.boolean().optional(),
    billingCycle: z.boolean().optional(),
    serviceProviderId: z.boolean().optional(),
    serviceId: z.boolean().optional(),
    tierUsed: z.boolean().optional(),
    priceCharged: z.boolean().optional(),
    processed: z.boolean().optional(),
    processedAt: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    subscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
  })
  .strict();

// PAYMENT
//------------------------------------------------------

export const PaymentIncludeSchema: z.ZodType<Prisma.PaymentInclude> = z
  .object({
    subscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
  })
  .strict();

export const PaymentArgsSchema: z.ZodType<Prisma.PaymentDefaultArgs> = z
  .object({
    select: z.lazy(() => PaymentSelectSchema).optional(),
    include: z.lazy(() => PaymentIncludeSchema).optional(),
  })
  .strict();

export const PaymentSelectSchema: z.ZodType<Prisma.PaymentSelect> = z
  .object({
    id: z.boolean().optional(),
    subscriptionId: z.boolean().optional(),
    amount: z.boolean().optional(),
    baseAmount: z.boolean().optional(),
    usageAmount: z.boolean().optional(),
    currency: z.boolean().optional(),
    status: z.boolean().optional(),
    stripePaymentId: z.boolean().optional(),
    stripeInvoiceId: z.boolean().optional(),
    paidAt: z.boolean().optional(),
    failureReason: z.boolean().optional(),
    billingPeriodStart: z.boolean().optional(),
    billingPeriodEnd: z.boolean().optional(),
    slotsCovered: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    subscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
  })
  .strict();

// REQUIREMENT TYPE
//------------------------------------------------------

export const RequirementTypeIncludeSchema: z.ZodType<Prisma.RequirementTypeInclude> = z
  .object({
    serviceProviderType: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeArgsSchema)])
      .optional(),
    submissions: z
      .union([z.boolean(), z.lazy(() => RequirementSubmissionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => RequirementTypeCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const RequirementTypeArgsSchema: z.ZodType<Prisma.RequirementTypeDefaultArgs> = z
  .object({
    select: z.lazy(() => RequirementTypeSelectSchema).optional(),
    include: z.lazy(() => RequirementTypeIncludeSchema).optional(),
  })
  .strict();

export const RequirementTypeCountOutputTypeArgsSchema: z.ZodType<Prisma.RequirementTypeCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => RequirementTypeCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const RequirementTypeCountOutputTypeSelectSchema: z.ZodType<Prisma.RequirementTypeCountOutputTypeSelect> =
  z
    .object({
      submissions: z.boolean().optional(),
    })
    .strict();

export const RequirementTypeSelectSchema: z.ZodType<Prisma.RequirementTypeSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    isRequired: z.boolean().optional(),
    validationType: z.boolean().optional(),
    validationConfig: z.boolean().optional(),
    displayPriority: z.boolean().optional(),
    serviceProviderTypeId: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    serviceProviderType: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeArgsSchema)])
      .optional(),
    submissions: z
      .union([z.boolean(), z.lazy(() => RequirementSubmissionFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => RequirementTypeCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// REQUIREMENT SUBMISSION
//------------------------------------------------------

export const RequirementSubmissionIncludeSchema: z.ZodType<Prisma.RequirementSubmissionInclude> = z
  .object({
    requirementType: z.union([z.boolean(), z.lazy(() => RequirementTypeArgsSchema)]).optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    validatedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

export const RequirementSubmissionArgsSchema: z.ZodType<Prisma.RequirementSubmissionDefaultArgs> = z
  .object({
    select: z.lazy(() => RequirementSubmissionSelectSchema).optional(),
    include: z.lazy(() => RequirementSubmissionIncludeSchema).optional(),
  })
  .strict();

export const RequirementSubmissionSelectSchema: z.ZodType<Prisma.RequirementSubmissionSelect> = z
  .object({
    id: z.boolean().optional(),
    requirementTypeId: z.boolean().optional(),
    serviceProviderId: z.boolean().optional(),
    status: z.boolean().optional(),
    documentUrl: z.boolean().optional(),
    documentMetadata: z.boolean().optional(),
    expiresAt: z.boolean().optional(),
    notes: z.boolean().optional(),
    validatedAt: z.boolean().optional(),
    validatedById: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    requirementType: z.union([z.boolean(), z.lazy(() => RequirementTypeArgsSchema)]).optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    validatedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
  })
  .strict();

// SERVICE
//------------------------------------------------------

export const ServiceIncludeSchema: z.ZodType<Prisma.ServiceInclude> = z
  .object({
    serviceProviderType: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeArgsSchema)])
      .optional(),
    providers: z.union([z.boolean(), z.lazy(() => ServiceProviderFindManyArgsSchema)]).optional(),
    availabilityConfigs: z
      .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigFindManyArgsSchema)])
      .optional(),
    calculatedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => ServiceCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const ServiceArgsSchema: z.ZodType<Prisma.ServiceDefaultArgs> = z
  .object({
    select: z.lazy(() => ServiceSelectSchema).optional(),
    include: z.lazy(() => ServiceIncludeSchema).optional(),
  })
  .strict();

export const ServiceCountOutputTypeArgsSchema: z.ZodType<Prisma.ServiceCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ServiceCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const ServiceCountOutputTypeSelectSchema: z.ZodType<Prisma.ServiceCountOutputTypeSelect> = z
  .object({
    providers: z.boolean().optional(),
    availabilityConfigs: z.boolean().optional(),
    calculatedSlots: z.boolean().optional(),
  })
  .strict();

export const ServiceSelectSchema: z.ZodType<Prisma.ServiceSelect> = z
  .object({
    id: z.boolean().optional(),
    name: z.boolean().optional(),
    description: z.boolean().optional(),
    serviceProviderTypeId: z.boolean().optional(),
    displayPriority: z.boolean().optional(),
    defaultDuration: z.boolean().optional(),
    defaultPrice: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    serviceProviderType: z
      .union([z.boolean(), z.lazy(() => ServiceProviderTypeArgsSchema)])
      .optional(),
    providers: z.union([z.boolean(), z.lazy(() => ServiceProviderFindManyArgsSchema)]).optional(),
    availabilityConfigs: z
      .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigFindManyArgsSchema)])
      .optional(),
    calculatedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => ServiceCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// SERVICE AVAILABILITY CONFIG
//------------------------------------------------------

export const ServiceAvailabilityConfigIncludeSchema: z.ZodType<Prisma.ServiceAvailabilityConfigInclude> =
  z
    .object({
      service: z.union([z.boolean(), z.lazy(() => ServiceArgsSchema)]).optional(),
      serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
      availabilities: z
        .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
        .optional(),
      calculatedSlots: z
        .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigCountOutputTypeArgsSchema)])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ServiceAvailabilityConfigSelectSchema).optional(),
      include: z.lazy(() => ServiceAvailabilityConfigIncludeSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCountOutputTypeArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => ServiceAvailabilityConfigCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const ServiceAvailabilityConfigCountOutputTypeSelectSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCountOutputTypeSelect> =
  z
    .object({
      availabilities: z.boolean().optional(),
      calculatedSlots: z.boolean().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigSelectSchema: z.ZodType<Prisma.ServiceAvailabilityConfigSelect> =
  z
    .object({
      id: z.boolean().optional(),
      serviceId: z.boolean().optional(),
      serviceProviderId: z.boolean().optional(),
      duration: z.boolean().optional(),
      price: z.boolean().optional(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      service: z.union([z.boolean(), z.lazy(() => ServiceArgsSchema)]).optional(),
      serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
      availabilities: z
        .union([z.boolean(), z.lazy(() => AvailabilityFindManyArgsSchema)])
        .optional(),
      calculatedSlots: z
        .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
        .optional(),
      _count: z
        .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigCountOutputTypeArgsSchema)])
        .optional(),
    })
    .strict();

// AVAILABILITY
//------------------------------------------------------

export const AvailabilityIncludeSchema: z.ZodType<Prisma.AvailabilityInclude> = z
  .object({
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    location: z.union([z.boolean(), z.lazy(() => LocationArgsSchema)]).optional(),
    providerConnection: z
      .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionArgsSchema)])
      .optional(),
    createdBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    createdByMembership: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)])
      .optional(),
    acceptedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    defaultSubscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
    availableServices: z
      .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigFindManyArgsSchema)])
      .optional(),
    calculatedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => AvailabilityCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const AvailabilityArgsSchema: z.ZodType<Prisma.AvailabilityDefaultArgs> = z
  .object({
    select: z.lazy(() => AvailabilitySelectSchema).optional(),
    include: z.lazy(() => AvailabilityIncludeSchema).optional(),
  })
  .strict();

export const AvailabilityCountOutputTypeArgsSchema: z.ZodType<Prisma.AvailabilityCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => AvailabilityCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const AvailabilityCountOutputTypeSelectSchema: z.ZodType<Prisma.AvailabilityCountOutputTypeSelect> =
  z
    .object({
      availableServices: z.boolean().optional(),
      calculatedSlots: z.boolean().optional(),
    })
    .strict();

export const AvailabilitySelectSchema: z.ZodType<Prisma.AvailabilitySelect> = z
  .object({
    id: z.boolean().optional(),
    serviceProviderId: z.boolean().optional(),
    organizationId: z.boolean().optional(),
    locationId: z.boolean().optional(),
    connectionId: z.boolean().optional(),
    startTime: z.boolean().optional(),
    endTime: z.boolean().optional(),
    createdById: z.boolean().optional(),
    createdByMembershipId: z.boolean().optional(),
    isProviderCreated: z.boolean().optional(),
    status: z.boolean().optional(),
    acceptedById: z.boolean().optional(),
    acceptedAt: z.boolean().optional(),
    requiresConfirmation: z.boolean().optional(),
    billingEntity: z.boolean().optional(),
    defaultSubscriptionId: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    organization: z.union([z.boolean(), z.lazy(() => OrganizationArgsSchema)]).optional(),
    location: z.union([z.boolean(), z.lazy(() => LocationArgsSchema)]).optional(),
    providerConnection: z
      .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionArgsSchema)])
      .optional(),
    createdBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    createdByMembership: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)])
      .optional(),
    acceptedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    defaultSubscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
    availableServices: z
      .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigFindManyArgsSchema)])
      .optional(),
    calculatedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => AvailabilityCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// CALCULATED AVAILABILITY SLOT
//------------------------------------------------------

export const CalculatedAvailabilitySlotIncludeSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotInclude> =
  z
    .object({
      availability: z.union([z.boolean(), z.lazy(() => AvailabilityArgsSchema)]).optional(),
      service: z.union([z.boolean(), z.lazy(() => ServiceArgsSchema)]).optional(),
      serviceConfig: z
        .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigArgsSchema)])
        .optional(),
      booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
      billedToSubscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
      blockedByCalendarEvent: z
        .union([z.boolean(), z.lazy(() => CalendarEventArgsSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CalculatedAvailabilitySlotSelectSchema).optional(),
      include: z.lazy(() => CalculatedAvailabilitySlotIncludeSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotSelectSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotSelect> =
  z
    .object({
      id: z.boolean().optional(),
      availabilityId: z.boolean().optional(),
      serviceId: z.boolean().optional(),
      serviceConfigId: z.boolean().optional(),
      startTime: z.boolean().optional(),
      endTime: z.boolean().optional(),
      status: z.boolean().optional(),
      lastCalculated: z.boolean().optional(),
      billedToSubscriptionId: z.boolean().optional(),
      blockedByEventId: z.boolean().optional(),
      version: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      availability: z.union([z.boolean(), z.lazy(() => AvailabilityArgsSchema)]).optional(),
      service: z.union([z.boolean(), z.lazy(() => ServiceArgsSchema)]).optional(),
      serviceConfig: z
        .union([z.boolean(), z.lazy(() => ServiceAvailabilityConfigArgsSchema)])
        .optional(),
      booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
      billedToSubscription: z.union([z.boolean(), z.lazy(() => SubscriptionArgsSchema)]).optional(),
      blockedByCalendarEvent: z
        .union([z.boolean(), z.lazy(() => CalendarEventArgsSchema)])
        .optional(),
    })
    .strict();

// BOOKING
//------------------------------------------------------

export const BookingIncludeSchema: z.ZodType<Prisma.BookingInclude> = z
  .object({
    slot: z.union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotArgsSchema)]).optional(),
    createdBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    createdByMembership: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)])
      .optional(),
    confirmedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    client: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    communications: z
      .union([z.boolean(), z.lazy(() => CommunicationLogFindManyArgsSchema)])
      .optional(),
    review: z.union([z.boolean(), z.lazy(() => ReviewArgsSchema)]).optional(),
    meetSession: z.union([z.boolean(), z.lazy(() => MeetSessionArgsSchema)]).optional(),
    _count: z.union([z.boolean(), z.lazy(() => BookingCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const BookingArgsSchema: z.ZodType<Prisma.BookingDefaultArgs> = z
  .object({
    select: z.lazy(() => BookingSelectSchema).optional(),
    include: z.lazy(() => BookingIncludeSchema).optional(),
  })
  .strict();

export const BookingCountOutputTypeArgsSchema: z.ZodType<Prisma.BookingCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => BookingCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const BookingCountOutputTypeSelectSchema: z.ZodType<Prisma.BookingCountOutputTypeSelect> = z
  .object({
    communications: z.boolean().optional(),
  })
  .strict();

export const BookingSelectSchema: z.ZodType<Prisma.BookingSelect> = z
  .object({
    id: z.boolean().optional(),
    slotId: z.boolean().optional(),
    createdById: z.boolean().optional(),
    createdByMembershipId: z.boolean().optional(),
    isProviderCreated: z.boolean().optional(),
    isGuestBooking: z.boolean().optional(),
    isGuestSelfBooking: z.boolean().optional(),
    confirmedById: z.boolean().optional(),
    confirmedAt: z.boolean().optional(),
    clientId: z.boolean().optional(),
    guestName: z.boolean().optional(),
    guestEmail: z.boolean().optional(),
    guestPhone: z.boolean().optional(),
    guestWhatsapp: z.boolean().optional(),
    price: z.boolean().optional(),
    isOnline: z.boolean().optional(),
    isInPerson: z.boolean().optional(),
    status: z.boolean().optional(),
    notes: z.boolean().optional(),
    meetLink: z.boolean().optional(),
    calendarEventId: z.boolean().optional(),
    version: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    slot: z.union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotArgsSchema)]).optional(),
    createdBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    createdByMembership: z
      .union([z.boolean(), z.lazy(() => OrganizationMembershipArgsSchema)])
      .optional(),
    confirmedBy: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    client: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    communications: z
      .union([z.boolean(), z.lazy(() => CommunicationLogFindManyArgsSchema)])
      .optional(),
    review: z.union([z.boolean(), z.lazy(() => ReviewArgsSchema)]).optional(),
    meetSession: z.union([z.boolean(), z.lazy(() => MeetSessionArgsSchema)]).optional(),
    _count: z.union([z.boolean(), z.lazy(() => BookingCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// COMMUNICATION PREFERENCE
//------------------------------------------------------

export const CommunicationPreferenceIncludeSchema: z.ZodType<Prisma.CommunicationPreferenceInclude> =
  z
    .object({
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

export const CommunicationPreferenceArgsSchema: z.ZodType<Prisma.CommunicationPreferenceDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CommunicationPreferenceSelectSchema).optional(),
      include: z.lazy(() => CommunicationPreferenceIncludeSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceSelectSchema: z.ZodType<Prisma.CommunicationPreferenceSelect> =
  z
    .object({
      id: z.boolean().optional(),
      userId: z.boolean().optional(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.boolean().optional(),
      whatsappNumber: z.boolean().optional(),
      reminderHours: z.boolean().optional(),
      createdAt: z.boolean().optional(),
      updatedAt: z.boolean().optional(),
      user: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    })
    .strict();

// COMMUNICATION LOG
//------------------------------------------------------

export const CommunicationLogIncludeSchema: z.ZodType<Prisma.CommunicationLogInclude> = z
  .object({
    booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
  })
  .strict();

export const CommunicationLogArgsSchema: z.ZodType<Prisma.CommunicationLogDefaultArgs> = z
  .object({
    select: z.lazy(() => CommunicationLogSelectSchema).optional(),
    include: z.lazy(() => CommunicationLogIncludeSchema).optional(),
  })
  .strict();

export const CommunicationLogSelectSchema: z.ZodType<Prisma.CommunicationLogSelect> = z
  .object({
    id: z.boolean().optional(),
    bookingId: z.boolean().optional(),
    bookingReference: z.boolean().optional(),
    serviceProviderName: z.boolean().optional(),
    clientName: z.boolean().optional(),
    serviceName: z.boolean().optional(),
    appointmentTime: z.boolean().optional(),
    type: z.boolean().optional(),
    channel: z.boolean().optional(),
    content: z.boolean().optional(),
    status: z.boolean().optional(),
    sentAt: z.boolean().optional(),
    deliveredAt: z.boolean().optional(),
    booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
  })
  .strict();

// CALENDAR INTEGRATION
//------------------------------------------------------

export const CalendarIntegrationIncludeSchema: z.ZodType<Prisma.CalendarIntegrationInclude> = z
  .object({
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    calendarEvents: z
      .union([z.boolean(), z.lazy(() => CalendarEventFindManyArgsSchema)])
      .optional(),
    syncOperations: z
      .union([z.boolean(), z.lazy(() => CalendarSyncOperationFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

export const CalendarIntegrationArgsSchema: z.ZodType<Prisma.CalendarIntegrationDefaultArgs> = z
  .object({
    select: z.lazy(() => CalendarIntegrationSelectSchema).optional(),
    include: z.lazy(() => CalendarIntegrationIncludeSchema).optional(),
  })
  .strict();

export const CalendarIntegrationCountOutputTypeArgsSchema: z.ZodType<Prisma.CalendarIntegrationCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CalendarIntegrationCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const CalendarIntegrationCountOutputTypeSelectSchema: z.ZodType<Prisma.CalendarIntegrationCountOutputTypeSelect> =
  z
    .object({
      calendarEvents: z.boolean().optional(),
      syncOperations: z.boolean().optional(),
    })
    .strict();

export const CalendarIntegrationSelectSchema: z.ZodType<Prisma.CalendarIntegrationSelect> = z
  .object({
    id: z.boolean().optional(),
    serviceProviderId: z.boolean().optional(),
    provider: z.boolean().optional(),
    accessToken: z.boolean().optional(),
    refreshToken: z.boolean().optional(),
    expiresAt: z.boolean().optional(),
    calendarId: z.boolean().optional(),
    syncEnabled: z.boolean().optional(),
    lastSyncedAt: z.boolean().optional(),
    googleEmail: z.boolean().optional(),
    grantedScopes: z.boolean().optional(),
    meetSettings: z.boolean().optional(),
    webhookChannelId: z.boolean().optional(),
    webhookResourceId: z.boolean().optional(),
    webhookExpiresAt: z.boolean().optional(),
    nextSyncToken: z.boolean().optional(),
    syncDirection: z.boolean().optional(),
    blockingEventTypes: z.boolean().optional(),
    autoCreateMeetLinks: z.boolean().optional(),
    backgroundSyncEnabled: z.boolean().optional(),
    syncIntervalMinutes: z.boolean().optional(),
    lastFullSyncAt: z.boolean().optional(),
    syncFailureCount: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    calendarEvents: z
      .union([z.boolean(), z.lazy(() => CalendarEventFindManyArgsSchema)])
      .optional(),
    syncOperations: z
      .union([z.boolean(), z.lazy(() => CalendarSyncOperationFindManyArgsSchema)])
      .optional(),
    _count: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationCountOutputTypeArgsSchema)])
      .optional(),
  })
  .strict();

// CALENDAR EVENT
//------------------------------------------------------

export const CalendarEventIncludeSchema: z.ZodType<Prisma.CalendarEventInclude> = z
  .object({
    calendarIntegration: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationArgsSchema)])
      .optional(),
    blockedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => CalendarEventCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

export const CalendarEventArgsSchema: z.ZodType<Prisma.CalendarEventDefaultArgs> = z
  .object({
    select: z.lazy(() => CalendarEventSelectSchema).optional(),
    include: z.lazy(() => CalendarEventIncludeSchema).optional(),
  })
  .strict();

export const CalendarEventCountOutputTypeArgsSchema: z.ZodType<Prisma.CalendarEventCountOutputTypeDefaultArgs> =
  z
    .object({
      select: z.lazy(() => CalendarEventCountOutputTypeSelectSchema).nullish(),
    })
    .strict();

export const CalendarEventCountOutputTypeSelectSchema: z.ZodType<Prisma.CalendarEventCountOutputTypeSelect> =
  z
    .object({
      blockedSlots: z.boolean().optional(),
    })
    .strict();

export const CalendarEventSelectSchema: z.ZodType<Prisma.CalendarEventSelect> = z
  .object({
    id: z.boolean().optional(),
    calendarIntegrationId: z.boolean().optional(),
    externalEventId: z.boolean().optional(),
    externalCalendarId: z.boolean().optional(),
    etag: z.boolean().optional(),
    title: z.boolean().optional(),
    startTime: z.boolean().optional(),
    endTime: z.boolean().optional(),
    isAllDay: z.boolean().optional(),
    lastSyncedAt: z.boolean().optional(),
    eventType: z.boolean().optional(),
    blocksAvailability: z.boolean().optional(),
    syncStatus: z.boolean().optional(),
    lastModifiedInExternal: z.boolean().optional(),
    hasConflict: z.boolean().optional(),
    conflictDetails: z.boolean().optional(),
    conflictResolvedAt: z.boolean().optional(),
    version: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    calendarIntegration: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationArgsSchema)])
      .optional(),
    blockedSlots: z
      .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotFindManyArgsSchema)])
      .optional(),
    _count: z.union([z.boolean(), z.lazy(() => CalendarEventCountOutputTypeArgsSchema)]).optional(),
  })
  .strict();

// CALENDAR SYNC OPERATION
//------------------------------------------------------

export const CalendarSyncOperationIncludeSchema: z.ZodType<Prisma.CalendarSyncOperationInclude> = z
  .object({
    calendarIntegration: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationArgsSchema)])
      .optional(),
  })
  .strict();

export const CalendarSyncOperationArgsSchema: z.ZodType<Prisma.CalendarSyncOperationDefaultArgs> = z
  .object({
    select: z.lazy(() => CalendarSyncOperationSelectSchema).optional(),
    include: z.lazy(() => CalendarSyncOperationIncludeSchema).optional(),
  })
  .strict();

export const CalendarSyncOperationSelectSchema: z.ZodType<Prisma.CalendarSyncOperationSelect> = z
  .object({
    id: z.boolean().optional(),
    calendarIntegrationId: z.boolean().optional(),
    operationType: z.boolean().optional(),
    sourceSystem: z.boolean().optional(),
    status: z.boolean().optional(),
    entityType: z.boolean().optional(),
    entityId: z.boolean().optional(),
    externalEventId: z.boolean().optional(),
    startedAt: z.boolean().optional(),
    completedAt: z.boolean().optional(),
    retryCount: z.boolean().optional(),
    maxRetries: z.boolean().optional(),
    errorMessage: z.boolean().optional(),
    conflictResolution: z.boolean().optional(),
    syncWindowStart: z.boolean().optional(),
    syncWindowEnd: z.boolean().optional(),
    eventsProcessed: z.boolean().optional(),
    eventsSucceeded: z.boolean().optional(),
    eventsFailed: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    calendarIntegration: z
      .union([z.boolean(), z.lazy(() => CalendarIntegrationArgsSchema)])
      .optional(),
  })
  .strict();

// MEET SESSION
//------------------------------------------------------

export const MeetSessionIncludeSchema: z.ZodType<Prisma.MeetSessionInclude> = z
  .object({
    booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
  })
  .strict();

export const MeetSessionArgsSchema: z.ZodType<Prisma.MeetSessionDefaultArgs> = z
  .object({
    select: z.lazy(() => MeetSessionSelectSchema).optional(),
    include: z.lazy(() => MeetSessionIncludeSchema).optional(),
  })
  .strict();

export const MeetSessionSelectSchema: z.ZodType<Prisma.MeetSessionSelect> = z
  .object({
    id: z.boolean().optional(),
    bookingId: z.boolean().optional(),
    meetLink: z.boolean().optional(),
    eventId: z.boolean().optional(),
    joinCode: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
  })
  .strict();

// REVIEW
//------------------------------------------------------

export const ReviewIncludeSchema: z.ZodType<Prisma.ReviewInclude> = z
  .object({
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    client: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
  })
  .strict();

export const ReviewArgsSchema: z.ZodType<Prisma.ReviewDefaultArgs> = z
  .object({
    select: z.lazy(() => ReviewSelectSchema).optional(),
    include: z.lazy(() => ReviewIncludeSchema).optional(),
  })
  .strict();

export const ReviewSelectSchema: z.ZodType<Prisma.ReviewSelect> = z
  .object({
    id: z.boolean().optional(),
    serviceProviderId: z.boolean().optional(),
    clientId: z.boolean().optional(),
    bookingId: z.boolean().optional(),
    rating: z.boolean().optional(),
    comment: z.boolean().optional(),
    response: z.boolean().optional(),
    isPublic: z.boolean().optional(),
    googleReviewId: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    updatedAt: z.boolean().optional(),
    serviceProvider: z.union([z.boolean(), z.lazy(() => ServiceProviderArgsSchema)]).optional(),
    client: z.union([z.boolean(), z.lazy(() => UserArgsSchema)]).optional(),
    booking: z.union([z.boolean(), z.lazy(() => BookingArgsSchema)]).optional(),
  })
  .strict();

/////////////////////////////////////////
// INPUT TYPES
/////////////////////////////////////////

export const UserWhereInputSchema: z.ZodType<Prisma.UserWhereInput> = z
  .object({
    AND: z
      .union([z.lazy(() => UserWhereInputSchema), z.lazy(() => UserWhereInputSchema).array()])
      .optional(),
    OR: z
      .lazy(() => UserWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([z.lazy(() => UserWhereInputSchema), z.lazy(() => UserWhereInputSchema).array()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    emailVerified: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    phoneVerified: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    whatsapp: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    whatsappVerified: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    password: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    image: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    role: z
      .union([z.lazy(() => EnumUserRoleFilterSchema), z.lazy(() => UserRoleSchema)])
      .optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    accounts: z.lazy(() => AccountListRelationFilterSchema).optional(),
    serviceProvider: z
      .union([
        z.lazy(() => ServiceProviderNullableRelationFilterSchema),
        z.lazy(() => ServiceProviderWhereInputSchema),
      ])
      .optional()
      .nullable(),
    bookingsAsClient: z.lazy(() => BookingListRelationFilterSchema).optional(),
    bookingsCreated: z.lazy(() => BookingListRelationFilterSchema).optional(),
    bookingsConfirmed: z.lazy(() => BookingListRelationFilterSchema).optional(),
    communicationPreferences: z
      .lazy(() => CommunicationPreferenceListRelationFilterSchema)
      .optional(),
    organizationMemberships: z
      .lazy(() => OrganizationMembershipListRelationFilterSchema)
      .optional(),
    membershipHistoryChanges: z
      .lazy(() => OrganizationMembershipHistoryListRelationFilterSchema)
      .optional(),
    availabilitiesCreated: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
    availabilitiesAccepted: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
    organizationsApproved: z.lazy(() => OrganizationListRelationFilterSchema).optional(),
    providersApproved: z.lazy(() => ServiceProviderListRelationFilterSchema).optional(),
    sentInvitations: z.lazy(() => OrganizationInvitationListRelationFilterSchema).optional(),
    reviews: z.lazy(() => ReviewListRelationFilterSchema).optional(),
    validatedRequirements: z.lazy(() => RequirementSubmissionListRelationFilterSchema).optional(),
  })
  .strict();

export const UserOrderByWithRelationInputSchema: z.ZodType<Prisma.UserOrderByWithRelationInput> = z
  .object({
    id: z.lazy(() => SortOrderSchema).optional(),
    name: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
    email: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
    emailVerified: z
      .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
      .optional(),
    phone: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
    phoneVerified: z
      .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
      .optional(),
    whatsapp: z
      .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
      .optional(),
    whatsappVerified: z
      .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
      .optional(),
    password: z
      .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
      .optional(),
    image: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
    role: z.lazy(() => SortOrderSchema).optional(),
    createdAt: z.lazy(() => SortOrderSchema).optional(),
    updatedAt: z.lazy(() => SortOrderSchema).optional(),
    accounts: z.lazy(() => AccountOrderByRelationAggregateInputSchema).optional(),
    serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
    bookingsAsClient: z.lazy(() => BookingOrderByRelationAggregateInputSchema).optional(),
    bookingsCreated: z.lazy(() => BookingOrderByRelationAggregateInputSchema).optional(),
    bookingsConfirmed: z.lazy(() => BookingOrderByRelationAggregateInputSchema).optional(),
    communicationPreferences: z
      .lazy(() => CommunicationPreferenceOrderByRelationAggregateInputSchema)
      .optional(),
    organizationMemberships: z
      .lazy(() => OrganizationMembershipOrderByRelationAggregateInputSchema)
      .optional(),
    membershipHistoryChanges: z
      .lazy(() => OrganizationMembershipHistoryOrderByRelationAggregateInputSchema)
      .optional(),
    availabilitiesCreated: z.lazy(() => AvailabilityOrderByRelationAggregateInputSchema).optional(),
    availabilitiesAccepted: z
      .lazy(() => AvailabilityOrderByRelationAggregateInputSchema)
      .optional(),
    organizationsApproved: z.lazy(() => OrganizationOrderByRelationAggregateInputSchema).optional(),
    providersApproved: z.lazy(() => ServiceProviderOrderByRelationAggregateInputSchema).optional(),
    sentInvitations: z
      .lazy(() => OrganizationInvitationOrderByRelationAggregateInputSchema)
      .optional(),
    reviews: z.lazy(() => ReviewOrderByRelationAggregateInputSchema).optional(),
    validatedRequirements: z
      .lazy(() => RequirementSubmissionOrderByRelationAggregateInputSchema)
      .optional(),
  })
  .strict();

export const UserWhereUniqueInputSchema: z.ZodType<Prisma.UserWhereUniqueInput> = z
  .union([
    z.object({
      id: z.string().cuid(),
      email: z.string(),
    }),
    z.object({
      id: z.string().cuid(),
    }),
    z.object({
      email: z.string(),
    }),
  ])
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        email: z.string().optional(),
        AND: z
          .union([z.lazy(() => UserWhereInputSchema), z.lazy(() => UserWhereInputSchema).array()])
          .optional(),
        OR: z
          .lazy(() => UserWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([z.lazy(() => UserWhereInputSchema), z.lazy(() => UserWhereInputSchema).array()])
          .optional(),
        name: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        emailVerified: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        phone: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        phoneVerified: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        whatsapp: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        whatsappVerified: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        password: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        image: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        role: z
          .union([z.lazy(() => EnumUserRoleFilterSchema), z.lazy(() => UserRoleSchema)])
          .optional(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        accounts: z.lazy(() => AccountListRelationFilterSchema).optional(),
        serviceProvider: z
          .union([
            z.lazy(() => ServiceProviderNullableRelationFilterSchema),
            z.lazy(() => ServiceProviderWhereInputSchema),
          ])
          .optional()
          .nullable(),
        bookingsAsClient: z.lazy(() => BookingListRelationFilterSchema).optional(),
        bookingsCreated: z.lazy(() => BookingListRelationFilterSchema).optional(),
        bookingsConfirmed: z.lazy(() => BookingListRelationFilterSchema).optional(),
        communicationPreferences: z
          .lazy(() => CommunicationPreferenceListRelationFilterSchema)
          .optional(),
        organizationMemberships: z
          .lazy(() => OrganizationMembershipListRelationFilterSchema)
          .optional(),
        membershipHistoryChanges: z
          .lazy(() => OrganizationMembershipHistoryListRelationFilterSchema)
          .optional(),
        availabilitiesCreated: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
        availabilitiesAccepted: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
        organizationsApproved: z.lazy(() => OrganizationListRelationFilterSchema).optional(),
        providersApproved: z.lazy(() => ServiceProviderListRelationFilterSchema).optional(),
        sentInvitations: z.lazy(() => OrganizationInvitationListRelationFilterSchema).optional(),
        reviews: z.lazy(() => ReviewListRelationFilterSchema).optional(),
        validatedRequirements: z
          .lazy(() => RequirementSubmissionListRelationFilterSchema)
          .optional(),
      })
      .strict()
  );

export const UserOrderByWithAggregationInputSchema: z.ZodType<Prisma.UserOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      email: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      emailVerified: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      phone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      phoneVerified: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      whatsapp: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      whatsappVerified: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      password: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      image: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => UserCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => UserMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => UserMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const UserScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UserScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UserScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UserScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      phone: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      password: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      image: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      role: z
        .union([z.lazy(() => EnumUserRoleWithAggregatesFilterSchema), z.lazy(() => UserRoleSchema)])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const AccountWhereInputSchema: z.ZodType<Prisma.AccountWhereInput> = z
  .object({
    AND: z
      .union([z.lazy(() => AccountWhereInputSchema), z.lazy(() => AccountWhereInputSchema).array()])
      .optional(),
    OR: z
      .lazy(() => AccountWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([z.lazy(() => AccountWhereInputSchema), z.lazy(() => AccountWhereInputSchema).array()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    type: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    provider: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    providerAccountId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    refresh_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    access_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    expires_at: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    token_type: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    scope: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    id_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    session_state: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    user: z
      .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional(),
  })
  .strict();

export const AccountOrderByWithRelationInputSchema: z.ZodType<Prisma.AccountOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      access_token: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      expires_at: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      token_type: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      scope: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      id_token: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      session_state: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const AccountWhereUniqueInputSchema: z.ZodType<Prisma.AccountWhereUniqueInput> = z
  .union([
    z.object({
      id: z.string().cuid(),
      provider_providerAccountId: z.lazy(
        () => AccountProviderProviderAccountIdCompoundUniqueInputSchema
      ),
    }),
    z.object({
      id: z.string().cuid(),
    }),
    z.object({
      provider_providerAccountId: z.lazy(
        () => AccountProviderProviderAccountIdCompoundUniqueInputSchema
      ),
    }),
  ])
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        provider_providerAccountId: z
          .lazy(() => AccountProviderProviderAccountIdCompoundUniqueInputSchema)
          .optional(),
        AND: z
          .union([
            z.lazy(() => AccountWhereInputSchema),
            z.lazy(() => AccountWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => AccountWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => AccountWhereInputSchema),
            z.lazy(() => AccountWhereInputSchema).array(),
          ])
          .optional(),
        userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        type: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        provider: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        providerAccountId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        refresh_token: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        access_token: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        expires_at: z
          .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
          .optional()
          .nullable(),
        token_type: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        scope: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        id_token: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        session_state: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        user: z
          .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
          .optional(),
      })
      .strict()
  );

export const AccountOrderByWithAggregationInputSchema: z.ZodType<Prisma.AccountOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      access_token: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      expires_at: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      token_type: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      scope: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      id_token: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      session_state: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      _count: z.lazy(() => AccountCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => AccountAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => AccountMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => AccountMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => AccountSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const AccountScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AccountScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AccountScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AccountScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      type: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      provider: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      providerAccountId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      refresh_token: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      access_token: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.lazy(() => IntNullableWithAggregatesFilterSchema), z.number()])
        .optional()
        .nullable(),
      token_type: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      scope: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      id_token: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      session_state: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
    })
    .strict();

export const ServiceProviderTypeWhereInputSchema: z.ZodType<Prisma.ServiceProviderTypeWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceProviderTypeWhereInputSchema),
          z.lazy(() => ServiceProviderTypeWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceProviderTypeWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceProviderTypeWhereInputSchema),
          z.lazy(() => ServiceProviderTypeWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      requirements: z.lazy(() => RequirementTypeListRelationFilterSchema).optional(),
      services: z.lazy(() => ServiceListRelationFilterSchema).optional(),
      serviceProviders: z.lazy(() => ServiceProviderListRelationFilterSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeOrderByWithRelationInputSchema: z.ZodType<Prisma.ServiceProviderTypeOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      requirements: z.lazy(() => RequirementTypeOrderByRelationAggregateInputSchema).optional(),
      services: z.lazy(() => ServiceOrderByRelationAggregateInputSchema).optional(),
      serviceProviders: z.lazy(() => ServiceProviderOrderByRelationAggregateInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeWhereUniqueInputSchema: z.ZodType<Prisma.ServiceProviderTypeWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        name: z.string(),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        name: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          name: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ServiceProviderTypeWhereInputSchema),
              z.lazy(() => ServiceProviderTypeWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ServiceProviderTypeWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ServiceProviderTypeWhereInputSchema),
              z.lazy(() => ServiceProviderTypeWhereInputSchema).array(),
            ])
            .optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          requirements: z.lazy(() => RequirementTypeListRelationFilterSchema).optional(),
          services: z.lazy(() => ServiceListRelationFilterSchema).optional(),
          serviceProviders: z.lazy(() => ServiceProviderListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const ServiceProviderTypeOrderByWithAggregationInputSchema: z.ZodType<Prisma.ServiceProviderTypeOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ServiceProviderTypeCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ServiceProviderTypeMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ServiceProviderTypeMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ServiceProviderTypeScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceProviderTypeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceProviderTypeScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceProviderTypeScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceProviderTypeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceProviderTypeScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const ServiceProviderWhereInputSchema: z.ZodType<Prisma.ServiceProviderWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ServiceProviderWhereInputSchema),
        z.lazy(() => ServiceProviderWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => ServiceProviderWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ServiceProviderWhereInputSchema),
        z.lazy(() => ServiceProviderWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    bio: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    image: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    languages: z.lazy(() => EnumLanguagesNullableListFilterSchema).optional(),
    website: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    whatsapp: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z
      .union([
        z.lazy(() => EnumServiceProviderStatusFilterSchema),
        z.lazy(() => ServiceProviderStatusSchema),
      ])
      .optional(),
    approvedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    approvedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    rejectedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    rejectionReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    averageRating: z
      .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    totalReviews: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    trialStarted: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialEnded: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialStatus: z
      .union([z.lazy(() => EnumTrialStatusNullableFilterSchema), z.lazy(() => TrialStatusSchema)])
      .optional()
      .nullable(),
    paymentMethodAdded: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialReminderSent: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialConversionDate: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    selfPaidBookingsEnabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    user: z
      .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional(),
    serviceProviderType: z
      .union([
        z.lazy(() => ServiceProviderTypeRelationFilterSchema),
        z.lazy(() => ServiceProviderTypeWhereInputSchema),
      ])
      .optional(),
    approvedBy: z
      .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional()
      .nullable(),
    reviews: z.lazy(() => ReviewListRelationFilterSchema).optional(),
    requirementSubmissions: z.lazy(() => RequirementSubmissionListRelationFilterSchema).optional(),
    services: z.lazy(() => ServiceListRelationFilterSchema).optional(),
    availabilityConfigs: z.lazy(() => ServiceAvailabilityConfigListRelationFilterSchema).optional(),
    availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
    calendarIntegration: z
      .union([
        z.lazy(() => CalendarIntegrationNullableRelationFilterSchema),
        z.lazy(() => CalendarIntegrationWhereInputSchema),
      ])
      .optional()
      .nullable(),
    providerConnections: z
      .lazy(() => OrganizationProviderConnectionListRelationFilterSchema)
      .optional(),
    subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
  })
  .strict();

export const ServiceProviderOrderByWithRelationInputSchema: z.ZodType<Prisma.ServiceProviderOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      bio: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      languages: z.lazy(() => SortOrderSchema).optional(),
      website: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      approvedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectionReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      averageRating: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialEnded: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      selfPaidBookingsEnabled: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeOrderByWithRelationInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      reviews: z.lazy(() => ReviewOrderByRelationAggregateInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionOrderByRelationAggregateInputSchema)
        .optional(),
      services: z.lazy(() => ServiceOrderByRelationAggregateInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigOrderByRelationAggregateInputSchema)
        .optional(),
      availabilities: z.lazy(() => AvailabilityOrderByRelationAggregateInputSchema).optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationOrderByWithRelationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionOrderByRelationAggregateInputSchema)
        .optional(),
      subscriptions: z.lazy(() => SubscriptionOrderByRelationAggregateInputSchema).optional(),
    })
    .strict();

export const ServiceProviderWhereUniqueInputSchema: z.ZodType<Prisma.ServiceProviderWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        userId: z.string(),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        userId: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          userId: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => ServiceProviderWhereInputSchema),
              z.lazy(() => ServiceProviderWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ServiceProviderWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ServiceProviderWhereInputSchema),
              z.lazy(() => ServiceProviderWhereInputSchema).array(),
            ])
            .optional(),
          name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          bio: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          image: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          languages: z.lazy(() => EnumLanguagesNullableListFilterSchema).optional(),
          website: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          whatsapp: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          status: z
            .union([
              z.lazy(() => EnumServiceProviderStatusFilterSchema),
              z.lazy(() => ServiceProviderStatusSchema),
            ])
            .optional(),
          approvedById: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          approvedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          rejectedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          rejectionReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          averageRating: z
            .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
            .optional()
            .nullable(),
          totalReviews: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          trialStarted: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          trialEnded: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          trialStatus: z
            .union([
              z.lazy(() => EnumTrialStatusNullableFilterSchema),
              z.lazy(() => TrialStatusSchema),
            ])
            .optional()
            .nullable(),
          paymentMethodAdded: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          trialReminderSent: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          trialConversionDate: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          selfPaidBookingsEnabled: z
            .union([z.lazy(() => BoolFilterSchema), z.boolean()])
            .optional(),
          user: z
            .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
            .optional(),
          serviceProviderType: z
            .union([
              z.lazy(() => ServiceProviderTypeRelationFilterSchema),
              z.lazy(() => ServiceProviderTypeWhereInputSchema),
            ])
            .optional(),
          approvedBy: z
            .union([
              z.lazy(() => UserNullableRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional()
            .nullable(),
          reviews: z.lazy(() => ReviewListRelationFilterSchema).optional(),
          requirementSubmissions: z
            .lazy(() => RequirementSubmissionListRelationFilterSchema)
            .optional(),
          services: z.lazy(() => ServiceListRelationFilterSchema).optional(),
          availabilityConfigs: z
            .lazy(() => ServiceAvailabilityConfigListRelationFilterSchema)
            .optional(),
          availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
          calendarIntegration: z
            .union([
              z.lazy(() => CalendarIntegrationNullableRelationFilterSchema),
              z.lazy(() => CalendarIntegrationWhereInputSchema),
            ])
            .optional()
            .nullable(),
          providerConnections: z
            .lazy(() => OrganizationProviderConnectionListRelationFilterSchema)
            .optional(),
          subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const ServiceProviderOrderByWithAggregationInputSchema: z.ZodType<Prisma.ServiceProviderOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      bio: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      languages: z.lazy(() => SortOrderSchema).optional(),
      website: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      approvedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectionReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      averageRating: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialEnded: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      selfPaidBookingsEnabled: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ServiceProviderCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => ServiceProviderAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ServiceProviderMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ServiceProviderMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ServiceProviderSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const ServiceProviderScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ServiceProviderScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceProviderScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceProviderScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceProviderScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceProviderTypeId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      bio: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      image: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      languages: z.lazy(() => EnumLanguagesNullableListFilterSchema).optional(),
      website: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      whatsapp: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumServiceProviderStatusWithAggregatesFilterSchema),
          z.lazy(() => ServiceProviderStatusSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      averageRating: z
        .union([z.lazy(() => FloatNullableWithAggregatesFilterSchema), z.number()])
        .optional()
        .nullable(),
      totalReviews: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      trialStarted: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => EnumTrialStatusNullableWithAggregatesFilterSchema),
          z.lazy(() => TrialStatusSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      trialReminderSent: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      trialConversionDate: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
    })
    .strict();

export const OrganizationWhereInputSchema: z.ZodType<Prisma.OrganizationWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => OrganizationWhereInputSchema),
        z.lazy(() => OrganizationWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => OrganizationWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => OrganizationWhereInputSchema),
        z.lazy(() => OrganizationWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    website: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    logo: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => EnumOrganizationStatusFilterSchema),
        z.lazy(() => OrganizationStatusSchema),
      ])
      .optional(),
    approvedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    approvedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    rejectedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    rejectionReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    billingModel: z
      .union([
        z.lazy(() => EnumOrganizationBillingModelFilterSchema),
        z.lazy(() => OrganizationBillingModelSchema),
      ])
      .optional(),
    trialStarted: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialEnded: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialStatus: z
      .union([z.lazy(() => EnumTrialStatusNullableFilterSchema), z.lazy(() => TrialStatusSchema)])
      .optional()
      .nullable(),
    paymentMethodAdded: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialReminderSent: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialConversionDate: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    approvedBy: z
      .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional()
      .nullable(),
    subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
    invitations: z.lazy(() => OrganizationInvitationListRelationFilterSchema).optional(),
    memberships: z.lazy(() => OrganizationMembershipListRelationFilterSchema).optional(),
    providerConnections: z
      .lazy(() => OrganizationProviderConnectionListRelationFilterSchema)
      .optional(),
    locations: z.lazy(() => LocationListRelationFilterSchema).optional(),
    availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
  })
  .strict();

export const OrganizationOrderByWithRelationInputSchema: z.ZodType<Prisma.OrganizationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      email: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      phone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      website: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      logo: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      approvedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectionReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      billingModel: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialEnded: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      approvedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      subscriptions: z.lazy(() => SubscriptionOrderByRelationAggregateInputSchema).optional(),
      invitations: z
        .lazy(() => OrganizationInvitationOrderByRelationAggregateInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipOrderByRelationAggregateInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionOrderByRelationAggregateInputSchema)
        .optional(),
      locations: z.lazy(() => LocationOrderByRelationAggregateInputSchema).optional(),
      availabilities: z.lazy(() => AvailabilityOrderByRelationAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationWhereUniqueInputSchema: z.ZodType<Prisma.OrganizationWhereUniqueInput> = z
  .object({
    id: z.string().cuid(),
  })
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        AND: z
          .union([
            z.lazy(() => OrganizationWhereInputSchema),
            z.lazy(() => OrganizationWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => OrganizationWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => OrganizationWhereInputSchema),
            z.lazy(() => OrganizationWhereInputSchema).array(),
          ])
          .optional(),
        name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        description: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        email: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        phone: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        website: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        logo: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        status: z
          .union([
            z.lazy(() => EnumOrganizationStatusFilterSchema),
            z.lazy(() => OrganizationStatusSchema),
          ])
          .optional(),
        approvedById: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        approvedAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        rejectedAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        rejectionReason: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        billingModel: z
          .union([
            z.lazy(() => EnumOrganizationBillingModelFilterSchema),
            z.lazy(() => OrganizationBillingModelSchema),
          ])
          .optional(),
        trialStarted: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        trialEnded: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        trialStatus: z
          .union([
            z.lazy(() => EnumTrialStatusNullableFilterSchema),
            z.lazy(() => TrialStatusSchema),
          ])
          .optional()
          .nullable(),
        paymentMethodAdded: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        trialReminderSent: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        trialConversionDate: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        approvedBy: z
          .union([
            z.lazy(() => UserNullableRelationFilterSchema),
            z.lazy(() => UserWhereInputSchema),
          ])
          .optional()
          .nullable(),
        subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
        invitations: z.lazy(() => OrganizationInvitationListRelationFilterSchema).optional(),
        memberships: z.lazy(() => OrganizationMembershipListRelationFilterSchema).optional(),
        providerConnections: z
          .lazy(() => OrganizationProviderConnectionListRelationFilterSchema)
          .optional(),
        locations: z.lazy(() => LocationListRelationFilterSchema).optional(),
        availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
      })
      .strict()
  );

export const OrganizationOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrganizationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      email: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      phone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      website: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      logo: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      approvedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      rejectionReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      billingModel: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialEnded: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      _count: z.lazy(() => OrganizationCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => OrganizationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrganizationMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrganizationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      phone: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      website: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      logo: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumOrganizationStatusWithAggregatesFilterSchema),
          z.lazy(() => OrganizationStatusSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => EnumOrganizationBillingModelWithAggregatesFilterSchema),
          z.lazy(() => OrganizationBillingModelSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => EnumTrialStatusNullableWithAggregatesFilterSchema),
          z.lazy(() => TrialStatusSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      trialReminderSent: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      trialConversionDate: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationWhereInputSchema: z.ZodType<Prisma.OrganizationInvitationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationInvitationWhereInputSchema),
          z.lazy(() => OrganizationInvitationWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationInvitationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationInvitationWhereInputSchema),
          z.lazy(() => OrganizationInvitationWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      role: z
        .union([
          z.lazy(() => EnumOrganizationRoleFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional(),
      permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      token: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expiresAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      invitedById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumInvitationStatusFilterSchema),
          z.lazy(() => InvitationStatusSchema),
        ])
        .optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      organization: z
        .union([
          z.lazy(() => OrganizationRelationFilterSchema),
          z.lazy(() => OrganizationWhereInputSchema),
        ])
        .optional(),
      invitedBy: z
        .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      membership: z
        .union([
          z.lazy(() => OrganizationMembershipNullableRelationFilterSchema),
          z.lazy(() => OrganizationMembershipWhereInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationOrderByWithRelationInputSchema: z.ZodType<Prisma.OrganizationInvitationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      permissions: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      invitedById: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      membershipId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      organization: z.lazy(() => OrganizationOrderByWithRelationInputSchema).optional(),
      invitedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      membership: z.lazy(() => OrganizationMembershipOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const OrganizationInvitationWhereUniqueInputSchema: z.ZodType<Prisma.OrganizationInvitationWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        token: z.string(),
        membershipId: z.string(),
      }),
      z.object({
        id: z.string().cuid(),
        token: z.string(),
      }),
      z.object({
        id: z.string().cuid(),
        membershipId: z.string(),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        token: z.string(),
        membershipId: z.string(),
      }),
      z.object({
        token: z.string(),
      }),
      z.object({
        membershipId: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          token: z.string().optional(),
          membershipId: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => OrganizationInvitationWhereInputSchema),
              z.lazy(() => OrganizationInvitationWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrganizationInvitationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrganizationInvitationWhereInputSchema),
              z.lazy(() => OrganizationInvitationWhereInputSchema).array(),
            ])
            .optional(),
          organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          role: z
            .union([
              z.lazy(() => EnumOrganizationRoleFilterSchema),
              z.lazy(() => OrganizationRoleSchema),
            ])
            .optional(),
          permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
          expiresAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          invitedById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          status: z
            .union([
              z.lazy(() => EnumInvitationStatusFilterSchema),
              z.lazy(() => InvitationStatusSchema),
            ])
            .optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          acceptedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          organization: z
            .union([
              z.lazy(() => OrganizationRelationFilterSchema),
              z.lazy(() => OrganizationWhereInputSchema),
            ])
            .optional(),
          invitedBy: z
            .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
            .optional(),
          membership: z
            .union([
              z.lazy(() => OrganizationMembershipNullableRelationFilterSchema),
              z.lazy(() => OrganizationMembershipWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict()
    );

export const OrganizationInvitationOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrganizationInvitationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      permissions: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      invitedById: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      membershipId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      _count: z.lazy(() => OrganizationInvitationCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => OrganizationInvitationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrganizationInvitationMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationInvitationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrganizationInvitationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationInvitationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      organizationId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      email: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      role: z
        .union([
          z.lazy(() => EnumOrganizationRoleWithAggregatesFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional(),
      permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      token: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      invitedById: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumInvitationStatusWithAggregatesFilterSchema),
          z.lazy(() => InvitationStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipWhereInputSchema: z.ZodType<Prisma.OrganizationMembershipWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationMembershipWhereInputSchema),
          z.lazy(() => OrganizationMembershipWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationMembershipWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationMembershipWhereInputSchema),
          z.lazy(() => OrganizationMembershipWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      role: z
        .union([
          z.lazy(() => EnumOrganizationRoleFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional(),
      permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      status: z
        .union([
          z.lazy(() => EnumMembershipStatusFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      organization: z
        .union([
          z.lazy(() => OrganizationRelationFilterSchema),
          z.lazy(() => OrganizationWhereInputSchema),
        ])
        .optional(),
      user: z
        .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
        .optional(),
      invitation: z
        .union([
          z.lazy(() => OrganizationInvitationNullableRelationFilterSchema),
          z.lazy(() => OrganizationInvitationWhereInputSchema),
        ])
        .optional()
        .nullable(),
      bookingsCreated: z.lazy(() => BookingListRelationFilterSchema).optional(),
      availabilitiesCreated: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
      history: z.lazy(() => OrganizationMembershipHistoryListRelationFilterSchema).optional(),
    })
    .strict();

export const OrganizationMembershipOrderByWithRelationInputSchema: z.ZodType<Prisma.OrganizationMembershipOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      permissions: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      organization: z.lazy(() => OrganizationOrderByWithRelationInputSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      invitation: z.lazy(() => OrganizationInvitationOrderByWithRelationInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingOrderByRelationAggregateInputSchema).optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityOrderByRelationAggregateInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipWhereUniqueInputSchema: z.ZodType<Prisma.OrganizationMembershipWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        organizationId_userId: z.lazy(
          () => OrganizationMembershipOrganizationIdUserIdCompoundUniqueInputSchema
        ),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        organizationId_userId: z.lazy(
          () => OrganizationMembershipOrganizationIdUserIdCompoundUniqueInputSchema
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          organizationId_userId: z
            .lazy(() => OrganizationMembershipOrganizationIdUserIdCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => OrganizationMembershipWhereInputSchema),
              z.lazy(() => OrganizationMembershipWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrganizationMembershipWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrganizationMembershipWhereInputSchema),
              z.lazy(() => OrganizationMembershipWhereInputSchema).array(),
            ])
            .optional(),
          organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          role: z
            .union([
              z.lazy(() => EnumOrganizationRoleFilterSchema),
              z.lazy(() => OrganizationRoleSchema),
            ])
            .optional(),
          permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
          status: z
            .union([
              z.lazy(() => EnumMembershipStatusFilterSchema),
              z.lazy(() => MembershipStatusSchema),
            ])
            .optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          organization: z
            .union([
              z.lazy(() => OrganizationRelationFilterSchema),
              z.lazy(() => OrganizationWhereInputSchema),
            ])
            .optional(),
          user: z
            .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
            .optional(),
          invitation: z
            .union([
              z.lazy(() => OrganizationInvitationNullableRelationFilterSchema),
              z.lazy(() => OrganizationInvitationWhereInputSchema),
            ])
            .optional()
            .nullable(),
          bookingsCreated: z.lazy(() => BookingListRelationFilterSchema).optional(),
          availabilitiesCreated: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
          history: z.lazy(() => OrganizationMembershipHistoryListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const OrganizationMembershipOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrganizationMembershipOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      permissions: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => OrganizationMembershipCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => OrganizationMembershipMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrganizationMembershipMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrganizationMembershipScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationMembershipScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      organizationId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      userId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      role: z
        .union([
          z.lazy(() => EnumOrganizationRoleWithAggregatesFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional(),
      permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      status: z
        .union([
          z.lazy(() => EnumMembershipStatusWithAggregatesFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryWhereInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationMembershipHistoryWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      membershipId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      changeType: z
        .union([
          z.lazy(() => EnumMembershipChangeTypeFilterSchema),
          z.lazy(() => MembershipChangeTypeSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => EnumOrganizationRoleNullableFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => EnumOrganizationRoleNullableFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      newPermissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      oldStatus: z
        .union([
          z.lazy(() => EnumMembershipStatusNullableFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => EnumMembershipStatusNullableFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional()
        .nullable(),
      changedById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      changeReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      membership: z
        .union([
          z.lazy(() => OrganizationMembershipRelationFilterSchema),
          z.lazy(() => OrganizationMembershipWhereInputSchema),
        ])
        .optional(),
      changedBy: z
        .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryOrderByWithRelationInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
      changeType: z.lazy(() => SortOrderSchema).optional(),
      oldRole: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      newRole: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      oldPermissions: z.lazy(() => SortOrderSchema).optional(),
      newPermissions: z.lazy(() => SortOrderSchema).optional(),
      oldStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      newStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      changedById: z.lazy(() => SortOrderSchema).optional(),
      changeReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      ipAddress: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      userAgent: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      membership: z.lazy(() => OrganizationMembershipOrderByWithRelationInputSchema).optional(),
      changedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryWhereUniqueInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => OrganizationMembershipHistoryWhereInputSchema),
              z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrganizationMembershipHistoryWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrganizationMembershipHistoryWhereInputSchema),
              z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).array(),
            ])
            .optional(),
          membershipId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          changeType: z
            .union([
              z.lazy(() => EnumMembershipChangeTypeFilterSchema),
              z.lazy(() => MembershipChangeTypeSchema),
            ])
            .optional(),
          oldRole: z
            .union([
              z.lazy(() => EnumOrganizationRoleNullableFilterSchema),
              z.lazy(() => OrganizationRoleSchema),
            ])
            .optional()
            .nullable(),
          newRole: z
            .union([
              z.lazy(() => EnumOrganizationRoleNullableFilterSchema),
              z.lazy(() => OrganizationRoleSchema),
            ])
            .optional()
            .nullable(),
          oldPermissions: z
            .lazy(() => EnumOrganizationPermissionNullableListFilterSchema)
            .optional(),
          newPermissions: z
            .lazy(() => EnumOrganizationPermissionNullableListFilterSchema)
            .optional(),
          oldStatus: z
            .union([
              z.lazy(() => EnumMembershipStatusNullableFilterSchema),
              z.lazy(() => MembershipStatusSchema),
            ])
            .optional()
            .nullable(),
          newStatus: z
            .union([
              z.lazy(() => EnumMembershipStatusNullableFilterSchema),
              z.lazy(() => MembershipStatusSchema),
            ])
            .optional()
            .nullable(),
          changedById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          changeReason: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          ipAddress: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          userAgent: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          membership: z
            .union([
              z.lazy(() => OrganizationMembershipRelationFilterSchema),
              z.lazy(() => OrganizationMembershipWhereInputSchema),
            ])
            .optional(),
          changedBy: z
            .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
            .optional(),
        })
        .strict()
    );

export const OrganizationMembershipHistoryOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
      changeType: z.lazy(() => SortOrderSchema).optional(),
      oldRole: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      newRole: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      oldPermissions: z.lazy(() => SortOrderSchema).optional(),
      newPermissions: z.lazy(() => SortOrderSchema).optional(),
      oldStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      newStatus: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      changedById: z.lazy(() => SortOrderSchema).optional(),
      changeReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      ipAddress: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      userAgent: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z
        .lazy(() => OrganizationMembershipHistoryCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => OrganizationMembershipHistoryMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrganizationMembershipHistoryMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      membershipId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => EnumMembershipChangeTypeWithAggregatesFilterSchema),
          z.lazy(() => MembershipChangeTypeSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => EnumOrganizationRoleNullableWithAggregatesFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => EnumOrganizationRoleNullableWithAggregatesFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      newPermissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      oldStatus: z
        .union([
          z.lazy(() => EnumMembershipStatusNullableWithAggregatesFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => EnumMembershipStatusNullableWithAggregatesFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional()
        .nullable(),
      changedById: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      changeReason: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const LocationWhereInputSchema: z.ZodType<Prisma.LocationWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => LocationWhereInputSchema),
        z.lazy(() => LocationWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => LocationWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => LocationWhereInputSchema),
        z.lazy(() => LocationWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    googlePlaceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    formattedAddress: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    coordinates: z.lazy(() => JsonFilterSchema).optional(),
    addressComponents: z.lazy(() => JsonFilterSchema).optional(),
    city: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    country: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    organization: z
      .union([
        z.lazy(() => OrganizationRelationFilterSchema),
        z.lazy(() => OrganizationWhereInputSchema),
      ])
      .optional(),
    subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
    availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
  })
  .strict();

export const LocationOrderByWithRelationInputSchema: z.ZodType<Prisma.LocationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      googlePlaceId: z.lazy(() => SortOrderSchema).optional(),
      formattedAddress: z.lazy(() => SortOrderSchema).optional(),
      coordinates: z.lazy(() => SortOrderSchema).optional(),
      addressComponents: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      email: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      organization: z.lazy(() => OrganizationOrderByWithRelationInputSchema).optional(),
      subscriptions: z.lazy(() => SubscriptionOrderByRelationAggregateInputSchema).optional(),
      availabilities: z.lazy(() => AvailabilityOrderByRelationAggregateInputSchema).optional(),
    })
    .strict();

export const LocationWhereUniqueInputSchema: z.ZodType<Prisma.LocationWhereUniqueInput> = z
  .union([
    z.object({
      id: z.string().cuid(),
      googlePlaceId: z.string(),
    }),
    z.object({
      id: z.string().cuid(),
    }),
    z.object({
      googlePlaceId: z.string(),
    }),
  ])
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        googlePlaceId: z.string().optional(),
        AND: z
          .union([
            z.lazy(() => LocationWhereInputSchema),
            z.lazy(() => LocationWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => LocationWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => LocationWhereInputSchema),
            z.lazy(() => LocationWhereInputSchema).array(),
          ])
          .optional(),
        organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        formattedAddress: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        coordinates: z.lazy(() => JsonFilterSchema).optional(),
        addressComponents: z.lazy(() => JsonFilterSchema).optional(),
        city: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        country: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        phone: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        email: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        organization: z
          .union([
            z.lazy(() => OrganizationRelationFilterSchema),
            z.lazy(() => OrganizationWhereInputSchema),
          ])
          .optional(),
        subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
        availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
      })
      .strict()
  );

export const LocationOrderByWithAggregationInputSchema: z.ZodType<Prisma.LocationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      googlePlaceId: z.lazy(() => SortOrderSchema).optional(),
      formattedAddress: z.lazy(() => SortOrderSchema).optional(),
      coordinates: z.lazy(() => SortOrderSchema).optional(),
      addressComponents: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      email: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => LocationCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => LocationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => LocationMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const LocationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.LocationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => LocationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => LocationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => LocationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => LocationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => LocationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      organizationId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      googlePlaceId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      formattedAddress: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      coordinates: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      addressComponents: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      city: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      country: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      phone: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionWhereInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationProviderConnectionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumConnectionStatusFilterSchema),
          z.lazy(() => ConnectionStatusSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([z.lazy(() => EnumBillingEntityFilterSchema), z.lazy(() => BillingEntitySchema)])
        .optional(),
      requestedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      organization: z
        .union([
          z.lazy(() => OrganizationRelationFilterSchema),
          z.lazy(() => OrganizationWhereInputSchema),
        ])
        .optional(),
      serviceProvider: z
        .union([
          z.lazy(() => ServiceProviderRelationFilterSchema),
          z.lazy(() => ServiceProviderWhereInputSchema),
        ])
        .optional(),
      availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionOrderByWithRelationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      defaultBilledBy: z.lazy(() => SortOrderSchema).optional(),
      requestedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      organization: z.lazy(() => OrganizationOrderByWithRelationInputSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      availabilities: z.lazy(() => AvailabilityOrderByRelationAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionWhereUniqueInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        organizationId_serviceProviderId: z.lazy(
          () =>
            OrganizationProviderConnectionOrganizationIdServiceProviderIdCompoundUniqueInputSchema
        ),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        organizationId_serviceProviderId: z.lazy(
          () =>
            OrganizationProviderConnectionOrganizationIdServiceProviderIdCompoundUniqueInputSchema
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          organizationId_serviceProviderId: z
            .lazy(
              () =>
                OrganizationProviderConnectionOrganizationIdServiceProviderIdCompoundUniqueInputSchema
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => OrganizationProviderConnectionWhereInputSchema),
              z.lazy(() => OrganizationProviderConnectionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => OrganizationProviderConnectionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => OrganizationProviderConnectionWhereInputSchema),
              z.lazy(() => OrganizationProviderConnectionWhereInputSchema).array(),
            ])
            .optional(),
          organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          status: z
            .union([
              z.lazy(() => EnumConnectionStatusFilterSchema),
              z.lazy(() => ConnectionStatusSchema),
            ])
            .optional(),
          defaultBilledBy: z
            .union([z.lazy(() => EnumBillingEntityFilterSchema), z.lazy(() => BillingEntitySchema)])
            .optional(),
          requestedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          acceptedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          organization: z
            .union([
              z.lazy(() => OrganizationRelationFilterSchema),
              z.lazy(() => OrganizationWhereInputSchema),
            ])
            .optional(),
          serviceProvider: z
            .union([
              z.lazy(() => ServiceProviderRelationFilterSchema),
              z.lazy(() => ServiceProviderWhereInputSchema),
            ])
            .optional(),
          availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const OrganizationProviderConnectionOrderByWithAggregationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      defaultBilledBy: z.lazy(() => SortOrderSchema).optional(),
      requestedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      _count: z
        .lazy(() => OrganizationProviderConnectionCountOrderByAggregateInputSchema)
        .optional(),
      _max: z.lazy(() => OrganizationProviderConnectionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => OrganizationProviderConnectionMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      organizationId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumConnectionStatusWithAggregatesFilterSchema),
          z.lazy(() => ConnectionStatusSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => EnumBillingEntityWithAggregatesFilterSchema),
          z.lazy(() => BillingEntitySchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict();

export const SubscriptionWhereInputSchema: z.ZodType<Prisma.SubscriptionWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SubscriptionWhereInputSchema),
        z.lazy(() => SubscriptionWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => SubscriptionWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SubscriptionWhereInputSchema),
        z.lazy(() => SubscriptionWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    organizationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    locationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    serviceProviderId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => EnumSubscriptionStatusFilterSchema),
        z.lazy(() => SubscriptionStatusSchema),
      ])
      .optional(),
    type: z
      .union([z.lazy(() => EnumSubscriptionTypeFilterSchema), z.lazy(() => SubscriptionTypeSchema)])
      .optional(),
    planId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialStart: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialEnd: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    startDate: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    endDate: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    cancelledAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    cancelReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    stripeCustomerId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    stripeSubscriptionId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    currentMonthSlots: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    billingCycleStart: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    billingCycleEnd: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    organization: z
      .union([
        z.lazy(() => OrganizationNullableRelationFilterSchema),
        z.lazy(() => OrganizationWhereInputSchema),
      ])
      .optional()
      .nullable(),
    location: z
      .union([
        z.lazy(() => LocationNullableRelationFilterSchema),
        z.lazy(() => LocationWhereInputSchema),
      ])
      .optional()
      .nullable(),
    serviceProvider: z
      .union([
        z.lazy(() => ServiceProviderNullableRelationFilterSchema),
        z.lazy(() => ServiceProviderWhereInputSchema),
      ])
      .optional()
      .nullable(),
    plan: z
      .union([
        z.lazy(() => SubscriptionPlanRelationFilterSchema),
        z.lazy(() => SubscriptionPlanWhereInputSchema),
      ])
      .optional(),
    payments: z.lazy(() => PaymentListRelationFilterSchema).optional(),
    usageRecords: z.lazy(() => UsageRecordListRelationFilterSchema).optional(),
    billedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
    defaultForAvailabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
  })
  .strict();

export const SubscriptionOrderByWithRelationInputSchema: z.ZodType<Prisma.SubscriptionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      locationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      planId: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      trialStart: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialEnd: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      cancelledAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      cancelReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      stripeCustomerId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      stripeSubscriptionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
      billingCycleStart: z.lazy(() => SortOrderSchema).optional(),
      billingCycleEnd: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      organization: z.lazy(() => OrganizationOrderByWithRelationInputSchema).optional(),
      location: z.lazy(() => LocationOrderByWithRelationInputSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      plan: z.lazy(() => SubscriptionPlanOrderByWithRelationInputSchema).optional(),
      payments: z.lazy(() => PaymentOrderByRelationAggregateInputSchema).optional(),
      usageRecords: z.lazy(() => UsageRecordOrderByRelationAggregateInputSchema).optional(),
      billedSlots: z
        .lazy(() => CalculatedAvailabilitySlotOrderByRelationAggregateInputSchema)
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionWhereUniqueInputSchema: z.ZodType<Prisma.SubscriptionWhereUniqueInput> = z
  .object({
    id: z.string().cuid(),
  })
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        AND: z
          .union([
            z.lazy(() => SubscriptionWhereInputSchema),
            z.lazy(() => SubscriptionWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => SubscriptionWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => SubscriptionWhereInputSchema),
            z.lazy(() => SubscriptionWhereInputSchema).array(),
          ])
          .optional(),
        organizationId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        locationId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        serviceProviderId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        status: z
          .union([
            z.lazy(() => EnumSubscriptionStatusFilterSchema),
            z.lazy(() => SubscriptionStatusSchema),
          ])
          .optional(),
        type: z
          .union([
            z.lazy(() => EnumSubscriptionTypeFilterSchema),
            z.lazy(() => SubscriptionTypeSchema),
          ])
          .optional(),
        planId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        trialStart: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        trialEnd: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        startDate: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        endDate: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        cancelledAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        cancelReason: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        stripeCustomerId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        stripeSubscriptionId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        currentMonthSlots: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
        billingCycleStart: z
          .union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()])
          .optional(),
        billingCycleEnd: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        organization: z
          .union([
            z.lazy(() => OrganizationNullableRelationFilterSchema),
            z.lazy(() => OrganizationWhereInputSchema),
          ])
          .optional()
          .nullable(),
        location: z
          .union([
            z.lazy(() => LocationNullableRelationFilterSchema),
            z.lazy(() => LocationWhereInputSchema),
          ])
          .optional()
          .nullable(),
        serviceProvider: z
          .union([
            z.lazy(() => ServiceProviderNullableRelationFilterSchema),
            z.lazy(() => ServiceProviderWhereInputSchema),
          ])
          .optional()
          .nullable(),
        plan: z
          .union([
            z.lazy(() => SubscriptionPlanRelationFilterSchema),
            z.lazy(() => SubscriptionPlanWhereInputSchema),
          ])
          .optional(),
        payments: z.lazy(() => PaymentListRelationFilterSchema).optional(),
        usageRecords: z.lazy(() => UsageRecordListRelationFilterSchema).optional(),
        billedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
        defaultForAvailabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
      })
      .strict()
  );

export const SubscriptionOrderByWithAggregationInputSchema: z.ZodType<Prisma.SubscriptionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      locationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      planId: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      trialStart: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      trialEnd: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      cancelledAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      cancelReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      stripeCustomerId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      stripeSubscriptionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
      billingCycleStart: z.lazy(() => SortOrderSchema).optional(),
      billingCycleEnd: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => SubscriptionCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => SubscriptionAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SubscriptionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SubscriptionMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => SubscriptionSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const SubscriptionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SubscriptionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriptionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      organizationId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      locationId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumSubscriptionStatusWithAggregatesFilterSchema),
          z.lazy(() => SubscriptionStatusSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => EnumSubscriptionTypeWithAggregatesFilterSchema),
          z.lazy(() => SubscriptionTypeSchema),
        ])
        .optional(),
      planId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      isActive: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      trialStart: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      startDate: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      endDate: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      billingCycleStart: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      billingCycleEnd: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const SubscriptionPlanWhereInputSchema: z.ZodType<Prisma.SubscriptionPlanWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SubscriptionPlanWhereInputSchema),
        z.lazy(() => SubscriptionPlanWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => SubscriptionPlanWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SubscriptionPlanWhereInputSchema),
        z.lazy(() => SubscriptionPlanWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    basePrice: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    currency: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    interval: z
      .union([z.lazy(() => EnumBillingIntervalFilterSchema), z.lazy(() => BillingIntervalSchema)])
      .optional(),
    includedSlots: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    tierPricing: z.lazy(() => JsonFilterSchema).optional(),
    features: z.lazy(() => JsonNullableFilterSchema).optional(),
    maxProviders: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    maxLocations: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    stripePriceId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
  })
  .strict();

export const SubscriptionPlanOrderByWithRelationInputSchema: z.ZodType<Prisma.SubscriptionPlanOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      tierPricing: z.lazy(() => SortOrderSchema).optional(),
      features: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      maxProviders: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      maxLocations: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      stripePriceId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      subscriptions: z.lazy(() => SubscriptionOrderByRelationAggregateInputSchema).optional(),
    })
    .strict();

export const SubscriptionPlanWhereUniqueInputSchema: z.ZodType<Prisma.SubscriptionPlanWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => SubscriptionPlanWhereInputSchema),
              z.lazy(() => SubscriptionPlanWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => SubscriptionPlanWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => SubscriptionPlanWhereInputSchema),
              z.lazy(() => SubscriptionPlanWhereInputSchema).array(),
            ])
            .optional(),
          name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          basePrice: z.union([z.lazy(() => DecimalFilterSchema), z.number().positive()]).optional(),
          currency: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          interval: z
            .union([
              z.lazy(() => EnumBillingIntervalFilterSchema),
              z.lazy(() => BillingIntervalSchema),
            ])
            .optional(),
          includedSlots: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          tierPricing: z.lazy(() => JsonFilterSchema).optional(),
          features: z.lazy(() => JsonNullableFilterSchema).optional(),
          maxProviders: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          maxLocations: z
            .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
            .optional()
            .nullable(),
          isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          stripePriceId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          subscriptions: z.lazy(() => SubscriptionListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const SubscriptionPlanOrderByWithAggregationInputSchema: z.ZodType<Prisma.SubscriptionPlanOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      tierPricing: z.lazy(() => SortOrderSchema).optional(),
      features: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      maxProviders: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      maxLocations: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      stripePriceId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => SubscriptionPlanCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => SubscriptionPlanAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => SubscriptionPlanMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => SubscriptionPlanMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => SubscriptionPlanSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const SubscriptionPlanScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.SubscriptionPlanScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => SubscriptionPlanScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriptionPlanScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => SubscriptionPlanScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => SubscriptionPlanScalarWhereWithAggregatesInputSchema),
          z.lazy(() => SubscriptionPlanScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      basePrice: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      currency: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      interval: z
        .union([
          z.lazy(() => EnumBillingIntervalWithAggregatesFilterSchema),
          z.lazy(() => BillingIntervalSchema),
        ])
        .optional(),
      includedSlots: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      tierPricing: z.lazy(() => JsonWithAggregatesFilterSchema).optional(),
      features: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      maxProviders: z
        .union([z.lazy(() => IntNullableWithAggregatesFilterSchema), z.number()])
        .optional()
        .nullable(),
      maxLocations: z
        .union([z.lazy(() => IntNullableWithAggregatesFilterSchema), z.number()])
        .optional()
        .nullable(),
      isActive: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      stripePriceId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const UsageRecordWhereInputSchema: z.ZodType<Prisma.UsageRecordWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => UsageRecordWhereInputSchema),
        z.lazy(() => UsageRecordWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => UsageRecordWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => UsageRecordWhereInputSchema),
        z.lazy(() => UsageRecordWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    subscriptionId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slotId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slotDate: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    slotStatus: z
      .union([z.lazy(() => EnumSlotStatusFilterSchema), z.lazy(() => SlotStatusSchema)])
      .optional(),
    billingCycle: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    tierUsed: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    priceCharged: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    processed: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    processedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    subscription: z
      .union([
        z.lazy(() => SubscriptionRelationFilterSchema),
        z.lazy(() => SubscriptionWhereInputSchema),
      ])
      .optional(),
  })
  .strict();

export const UsageRecordOrderByWithRelationInputSchema: z.ZodType<Prisma.UsageRecordOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      slotDate: z.lazy(() => SortOrderSchema).optional(),
      slotStatus: z.lazy(() => SortOrderSchema).optional(),
      billingCycle: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
      processed: z.lazy(() => SortOrderSchema).optional(),
      processedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      subscription: z.lazy(() => SubscriptionOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const UsageRecordWhereUniqueInputSchema: z.ZodType<Prisma.UsageRecordWhereUniqueInput> = z
  .object({
    id: z.string().cuid(),
  })
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        AND: z
          .union([
            z.lazy(() => UsageRecordWhereInputSchema),
            z.lazy(() => UsageRecordWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => UsageRecordWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => UsageRecordWhereInputSchema),
            z.lazy(() => UsageRecordWhereInputSchema).array(),
          ])
          .optional(),
        subscriptionId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        slotId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        slotDate: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        slotStatus: z
          .union([z.lazy(() => EnumSlotStatusFilterSchema), z.lazy(() => SlotStatusSchema)])
          .optional(),
        billingCycle: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        tierUsed: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
        priceCharged: z
          .union([z.lazy(() => DecimalFilterSchema), z.number().positive()])
          .optional(),
        processed: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        processedAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        subscription: z
          .union([
            z.lazy(() => SubscriptionRelationFilterSchema),
            z.lazy(() => SubscriptionWhereInputSchema),
          ])
          .optional(),
      })
      .strict()
  );

export const UsageRecordOrderByWithAggregationInputSchema: z.ZodType<Prisma.UsageRecordOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      slotDate: z.lazy(() => SortOrderSchema).optional(),
      slotStatus: z.lazy(() => SortOrderSchema).optional(),
      billingCycle: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
      processed: z.lazy(() => SortOrderSchema).optional(),
      processedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => UsageRecordCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => UsageRecordAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => UsageRecordMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => UsageRecordMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => UsageRecordSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const UsageRecordScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.UsageRecordScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => UsageRecordScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UsageRecordScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => UsageRecordScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => UsageRecordScalarWhereWithAggregatesInputSchema),
          z.lazy(() => UsageRecordScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      subscriptionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      slotId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      slotDate: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => EnumSlotStatusWithAggregatesFilterSchema),
          z.lazy(() => SlotStatusSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      serviceId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      tierUsed: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      priceCharged: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      processed: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      processedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const PaymentWhereInputSchema: z.ZodType<Prisma.PaymentWhereInput> = z
  .object({
    AND: z
      .union([z.lazy(() => PaymentWhereInputSchema), z.lazy(() => PaymentWhereInputSchema).array()])
      .optional(),
    OR: z
      .lazy(() => PaymentWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([z.lazy(() => PaymentWhereInputSchema), z.lazy(() => PaymentWhereInputSchema).array()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    subscriptionId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    amount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    baseAmount: z
      .union([
        z.lazy(() => DecimalNullableFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional()
      .nullable(),
    usageAmount: z
      .union([
        z.lazy(() => DecimalNullableFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional()
      .nullable(),
    currency: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z
      .union([z.lazy(() => EnumPaymentStatusFilterSchema), z.lazy(() => PaymentStatusSchema)])
      .optional(),
    stripePaymentId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    stripeInvoiceId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    paidAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    failureReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    billingPeriodStart: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    billingPeriodEnd: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    slotsCovered: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    subscription: z
      .union([
        z.lazy(() => SubscriptionRelationFilterSchema),
        z.lazy(() => SubscriptionWhereInputSchema),
      ])
      .optional(),
  })
  .strict();

export const PaymentOrderByWithRelationInputSchema: z.ZodType<Prisma.PaymentOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      usageAmount: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      stripePaymentId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      stripeInvoiceId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      paidAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      failureReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      billingPeriodStart: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      billingPeriodEnd: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      slotsCovered: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      subscription: z.lazy(() => SubscriptionOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const PaymentWhereUniqueInputSchema: z.ZodType<Prisma.PaymentWhereUniqueInput> = z
  .object({
    id: z.string().cuid(),
  })
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        AND: z
          .union([
            z.lazy(() => PaymentWhereInputSchema),
            z.lazy(() => PaymentWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => PaymentWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => PaymentWhereInputSchema),
            z.lazy(() => PaymentWhereInputSchema).array(),
          ])
          .optional(),
        subscriptionId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        amount: z.union([z.lazy(() => DecimalFilterSchema), z.number().positive()]).optional(),
        baseAmount: z
          .union([z.lazy(() => DecimalNullableFilterSchema), z.number().positive()])
          .optional()
          .nullable(),
        usageAmount: z
          .union([z.lazy(() => DecimalNullableFilterSchema), z.number().positive()])
          .optional()
          .nullable(),
        currency: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        status: z
          .union([z.lazy(() => EnumPaymentStatusFilterSchema), z.lazy(() => PaymentStatusSchema)])
          .optional(),
        stripePaymentId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        stripeInvoiceId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        paidAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        failureReason: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        billingPeriodStart: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        billingPeriodEnd: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        slotsCovered: z
          .union([z.lazy(() => IntNullableFilterSchema), z.number().int()])
          .optional()
          .nullable(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        subscription: z
          .union([
            z.lazy(() => SubscriptionRelationFilterSchema),
            z.lazy(() => SubscriptionWhereInputSchema),
          ])
          .optional(),
      })
      .strict()
  );

export const PaymentOrderByWithAggregationInputSchema: z.ZodType<Prisma.PaymentOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      usageAmount: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      stripePaymentId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      stripeInvoiceId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      paidAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      failureReason: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      billingPeriodStart: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      billingPeriodEnd: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      slotsCovered: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => PaymentCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => PaymentAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => PaymentMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => PaymentMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => PaymentSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const PaymentScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.PaymentScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => PaymentScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema),
          z.lazy(() => PaymentScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      subscriptionId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      amount: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      baseAmount: z
        .union([
          z.lazy(() => DecimalNullableWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional()
        .nullable(),
      usageAmount: z
        .union([
          z.lazy(() => DecimalNullableWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional()
        .nullable(),
      currency: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumPaymentStatusWithAggregatesFilterSchema),
          z.lazy(() => PaymentStatusSchema),
        ])
        .optional(),
      stripePaymentId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      stripeInvoiceId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      paidAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      failureReason: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      billingPeriodStart: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      billingPeriodEnd: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      slotsCovered: z
        .union([z.lazy(() => IntNullableWithAggregatesFilterSchema), z.number()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const RequirementTypeWhereInputSchema: z.ZodType<Prisma.RequirementTypeWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => RequirementTypeWhereInputSchema),
        z.lazy(() => RequirementTypeWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => RequirementTypeWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => RequirementTypeWhereInputSchema),
        z.lazy(() => RequirementTypeWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isRequired: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    validationType: z
      .union([
        z.lazy(() => EnumRequirementValidationTypeFilterSchema),
        z.lazy(() => RequirementValidationTypeSchema),
      ])
      .optional(),
    validationConfig: z.lazy(() => JsonNullableFilterSchema).optional(),
    displayPriority: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    serviceProviderType: z
      .union([
        z.lazy(() => ServiceProviderTypeRelationFilterSchema),
        z.lazy(() => ServiceProviderTypeWhereInputSchema),
      ])
      .optional(),
    submissions: z.lazy(() => RequirementSubmissionListRelationFilterSchema).optional(),
  })
  .strict();

export const RequirementTypeOrderByWithRelationInputSchema: z.ZodType<Prisma.RequirementTypeOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isRequired: z.lazy(() => SortOrderSchema).optional(),
      validationType: z.lazy(() => SortOrderSchema).optional(),
      validationConfig: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeOrderByWithRelationInputSchema)
        .optional(),
      submissions: z
        .lazy(() => RequirementSubmissionOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeWhereUniqueInputSchema: z.ZodType<Prisma.RequirementTypeWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => RequirementTypeWhereInputSchema),
              z.lazy(() => RequirementTypeWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => RequirementTypeWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => RequirementTypeWhereInputSchema),
              z.lazy(() => RequirementTypeWhereInputSchema).array(),
            ])
            .optional(),
          name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          description: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          isRequired: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          validationType: z
            .union([
              z.lazy(() => EnumRequirementValidationTypeFilterSchema),
              z.lazy(() => RequirementValidationTypeSchema),
            ])
            .optional(),
          validationConfig: z.lazy(() => JsonNullableFilterSchema).optional(),
          displayPriority: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          serviceProviderType: z
            .union([
              z.lazy(() => ServiceProviderTypeRelationFilterSchema),
              z.lazy(() => ServiceProviderTypeWhereInputSchema),
            ])
            .optional(),
          submissions: z.lazy(() => RequirementSubmissionListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const RequirementTypeOrderByWithAggregationInputSchema: z.ZodType<Prisma.RequirementTypeOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isRequired: z.lazy(() => SortOrderSchema).optional(),
      validationType: z.lazy(() => SortOrderSchema).optional(),
      validationConfig: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => RequirementTypeCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => RequirementTypeAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => RequirementTypeMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => RequirementTypeMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => RequirementTypeSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const RequirementTypeScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RequirementTypeScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RequirementTypeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RequirementTypeScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RequirementTypeScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RequirementTypeScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RequirementTypeScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      isRequired: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      validationType: z
        .union([
          z.lazy(() => EnumRequirementValidationTypeWithAggregatesFilterSchema),
          z.lazy(() => RequirementValidationTypeSchema),
        ])
        .optional(),
      validationConfig: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      displayPriority: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      serviceProviderTypeId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const RequirementSubmissionWhereInputSchema: z.ZodType<Prisma.RequirementSubmissionWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RequirementSubmissionWhereInputSchema),
          z.lazy(() => RequirementSubmissionWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RequirementSubmissionWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RequirementSubmissionWhereInputSchema),
          z.lazy(() => RequirementSubmissionWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      requirementTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumRequirementsValidationStatusFilterSchema),
          z.lazy(() => RequirementsValidationStatusSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      documentMetadata: z.lazy(() => JsonNullableFilterSchema).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      notes: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      requirementType: z
        .union([
          z.lazy(() => RequirementTypeRelationFilterSchema),
          z.lazy(() => RequirementTypeWhereInputSchema),
        ])
        .optional(),
      serviceProvider: z
        .union([
          z.lazy(() => ServiceProviderRelationFilterSchema),
          z.lazy(() => ServiceProviderWhereInputSchema),
        ])
        .optional(),
      validatedBy: z
        .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const RequirementSubmissionOrderByWithRelationInputSchema: z.ZodType<Prisma.RequirementSubmissionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      requirementTypeId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      documentUrl: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      documentMetadata: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      notes: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      validatedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      validatedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      requirementType: z.lazy(() => RequirementTypeOrderByWithRelationInputSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      validatedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const RequirementSubmissionWhereUniqueInputSchema: z.ZodType<Prisma.RequirementSubmissionWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        requirementTypeId_serviceProviderId: z.lazy(
          () => RequirementSubmissionRequirementTypeIdServiceProviderIdCompoundUniqueInputSchema
        ),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        requirementTypeId_serviceProviderId: z.lazy(
          () => RequirementSubmissionRequirementTypeIdServiceProviderIdCompoundUniqueInputSchema
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          requirementTypeId_serviceProviderId: z
            .lazy(
              () => RequirementSubmissionRequirementTypeIdServiceProviderIdCompoundUniqueInputSchema
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => RequirementSubmissionWhereInputSchema),
              z.lazy(() => RequirementSubmissionWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => RequirementSubmissionWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => RequirementSubmissionWhereInputSchema),
              z.lazy(() => RequirementSubmissionWhereInputSchema).array(),
            ])
            .optional(),
          requirementTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          status: z
            .union([
              z.lazy(() => EnumRequirementsValidationStatusFilterSchema),
              z.lazy(() => RequirementsValidationStatusSchema),
            ])
            .optional(),
          documentUrl: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          documentMetadata: z.lazy(() => JsonNullableFilterSchema).optional(),
          expiresAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          notes: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          validatedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          validatedById: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          requirementType: z
            .union([
              z.lazy(() => RequirementTypeRelationFilterSchema),
              z.lazy(() => RequirementTypeWhereInputSchema),
            ])
            .optional(),
          serviceProvider: z
            .union([
              z.lazy(() => ServiceProviderRelationFilterSchema),
              z.lazy(() => ServiceProviderWhereInputSchema),
            ])
            .optional(),
          validatedBy: z
            .union([
              z.lazy(() => UserNullableRelationFilterSchema),
              z.lazy(() => UserWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict()
    );

export const RequirementSubmissionOrderByWithAggregationInputSchema: z.ZodType<Prisma.RequirementSubmissionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      requirementTypeId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      documentUrl: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      documentMetadata: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      notes: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      validatedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      validatedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => RequirementSubmissionCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => RequirementSubmissionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => RequirementSubmissionMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const RequirementSubmissionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.RequirementSubmissionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RequirementSubmissionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      requirementTypeId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumRequirementsValidationStatusWithAggregatesFilterSchema),
          z.lazy(() => RequirementsValidationStatusSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      documentMetadata: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      notes: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const ServiceWhereInputSchema: z.ZodType<Prisma.ServiceWhereInput> = z
  .object({
    AND: z
      .union([z.lazy(() => ServiceWhereInputSchema), z.lazy(() => ServiceWhereInputSchema).array()])
      .optional(),
    OR: z
      .lazy(() => ServiceWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([z.lazy(() => ServiceWhereInputSchema), z.lazy(() => ServiceWhereInputSchema).array()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    displayPriority: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    defaultDuration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    defaultPrice: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    serviceProviderType: z
      .union([
        z.lazy(() => ServiceProviderTypeRelationFilterSchema),
        z.lazy(() => ServiceProviderTypeWhereInputSchema),
      ])
      .optional(),
    providers: z.lazy(() => ServiceProviderListRelationFilterSchema).optional(),
    availabilityConfigs: z.lazy(() => ServiceAvailabilityConfigListRelationFilterSchema).optional(),
    calculatedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
  })
  .strict();

export const ServiceOrderByWithRelationInputSchema: z.ZodType<Prisma.ServiceOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeOrderByWithRelationInputSchema)
        .optional(),
      providers: z.lazy(() => ServiceProviderOrderByRelationAggregateInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigOrderByRelationAggregateInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const ServiceWhereUniqueInputSchema: z.ZodType<Prisma.ServiceWhereUniqueInput> = z
  .object({
    id: z.string().cuid(),
  })
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        AND: z
          .union([
            z.lazy(() => ServiceWhereInputSchema),
            z.lazy(() => ServiceWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => ServiceWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => ServiceWhereInputSchema),
            z.lazy(() => ServiceWhereInputSchema).array(),
          ])
          .optional(),
        name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        description: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        displayPriority: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
        defaultDuration: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
        defaultPrice: z
          .union([z.lazy(() => DecimalFilterSchema), z.number().positive()])
          .optional(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        serviceProviderType: z
          .union([
            z.lazy(() => ServiceProviderTypeRelationFilterSchema),
            z.lazy(() => ServiceProviderTypeWhereInputSchema),
          ])
          .optional(),
        providers: z.lazy(() => ServiceProviderListRelationFilterSchema).optional(),
        availabilityConfigs: z
          .lazy(() => ServiceAvailabilityConfigListRelationFilterSchema)
          .optional(),
        calculatedSlots: z
          .lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema)
          .optional(),
      })
      .strict()
  );

export const ServiceOrderByWithAggregationInputSchema: z.ZodType<Prisma.ServiceOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ServiceCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => ServiceAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ServiceMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ServiceMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ServiceSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const ServiceScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ServiceScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      serviceProviderTypeId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      displayPriority: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      defaultDuration: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      defaultPrice: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigWhereInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceAvailabilityConfigWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      duration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      price: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      isOnlineAvailable: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      isInPerson: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      location: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      service: z
        .union([z.lazy(() => ServiceRelationFilterSchema), z.lazy(() => ServiceWhereInputSchema)])
        .optional(),
      serviceProvider: z
        .union([
          z.lazy(() => ServiceProviderRelationFilterSchema),
          z.lazy(() => ServiceProviderWhereInputSchema),
        ])
        .optional(),
      availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
      calculatedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigOrderByWithRelationInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnlineAvailable: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      location: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      service: z.lazy(() => ServiceOrderByWithRelationInputSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      availabilities: z.lazy(() => AvailabilityOrderByRelationAggregateInputSchema).optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigWhereUniqueInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        serviceId_serviceProviderId: z.lazy(
          () => ServiceAvailabilityConfigServiceIdServiceProviderIdCompoundUniqueInputSchema
        ),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        serviceId_serviceProviderId: z.lazy(
          () => ServiceAvailabilityConfigServiceIdServiceProviderIdCompoundUniqueInputSchema
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          serviceId_serviceProviderId: z
            .lazy(
              () => ServiceAvailabilityConfigServiceIdServiceProviderIdCompoundUniqueInputSchema
            )
            .optional(),
          AND: z
            .union([
              z.lazy(() => ServiceAvailabilityConfigWhereInputSchema),
              z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => ServiceAvailabilityConfigWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => ServiceAvailabilityConfigWhereInputSchema),
              z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).array(),
            ])
            .optional(),
          serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          duration: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          price: z.union([z.lazy(() => DecimalFilterSchema), z.number().positive()]).optional(),
          isOnlineAvailable: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          isInPerson: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          location: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          service: z
            .union([
              z.lazy(() => ServiceRelationFilterSchema),
              z.lazy(() => ServiceWhereInputSchema),
            ])
            .optional(),
          serviceProvider: z
            .union([
              z.lazy(() => ServiceProviderRelationFilterSchema),
              z.lazy(() => ServiceProviderWhereInputSchema),
            ])
            .optional(),
          availabilities: z.lazy(() => AvailabilityListRelationFilterSchema).optional(),
          calculatedSlots: z
            .lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema)
            .optional(),
        })
        .strict()
    );

export const ServiceAvailabilityConfigOrderByWithAggregationInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnlineAvailable: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      location: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ServiceAvailabilityConfigCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => ServiceAvailabilityConfigAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ServiceAvailabilityConfigMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ServiceAvailabilityConfigMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ServiceAvailabilityConfigSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      duration: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      price: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      isOnlineAvailable: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      isInPerson: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      location: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const AvailabilityWhereInputSchema: z.ZodType<Prisma.AvailabilityWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => AvailabilityWhereInputSchema),
        z.lazy(() => AvailabilityWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => AvailabilityWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => AvailabilityWhereInputSchema),
        z.lazy(() => AvailabilityWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    organizationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    locationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    connectionId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    createdById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdByMembershipId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isProviderCreated: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    status: z
      .union([
        z.lazy(() => EnumAvailabilityStatusFilterSchema),
        z.lazy(() => AvailabilityStatusSchema),
      ])
      .optional(),
    acceptedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    acceptedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    requiresConfirmation: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    billingEntity: z
      .union([
        z.lazy(() => EnumBillingEntityNullableFilterSchema),
        z.lazy(() => BillingEntitySchema),
      ])
      .optional()
      .nullable(),
    defaultSubscriptionId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    serviceProvider: z
      .union([
        z.lazy(() => ServiceProviderRelationFilterSchema),
        z.lazy(() => ServiceProviderWhereInputSchema),
      ])
      .optional(),
    organization: z
      .union([
        z.lazy(() => OrganizationNullableRelationFilterSchema),
        z.lazy(() => OrganizationWhereInputSchema),
      ])
      .optional()
      .nullable(),
    location: z
      .union([
        z.lazy(() => LocationNullableRelationFilterSchema),
        z.lazy(() => LocationWhereInputSchema),
      ])
      .optional()
      .nullable(),
    providerConnection: z
      .union([
        z.lazy(() => OrganizationProviderConnectionNullableRelationFilterSchema),
        z.lazy(() => OrganizationProviderConnectionWhereInputSchema),
      ])
      .optional()
      .nullable(),
    createdBy: z
      .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional(),
    createdByMembership: z
      .union([
        z.lazy(() => OrganizationMembershipNullableRelationFilterSchema),
        z.lazy(() => OrganizationMembershipWhereInputSchema),
      ])
      .optional()
      .nullable(),
    acceptedBy: z
      .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional()
      .nullable(),
    defaultSubscription: z
      .union([
        z.lazy(() => SubscriptionNullableRelationFilterSchema),
        z.lazy(() => SubscriptionWhereInputSchema),
      ])
      .optional()
      .nullable(),
    availableServices: z.lazy(() => ServiceAvailabilityConfigListRelationFilterSchema).optional(),
    calculatedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
  })
  .strict();

export const AvailabilityOrderByWithRelationInputSchema: z.ZodType<Prisma.AvailabilityOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      locationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      connectionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      acceptedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      requiresConfirmation: z.lazy(() => SortOrderSchema).optional(),
      billingEntity: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      defaultSubscriptionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      organization: z.lazy(() => OrganizationOrderByWithRelationInputSchema).optional(),
      location: z.lazy(() => LocationOrderByWithRelationInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionOrderByWithRelationInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipOrderByWithRelationInputSchema)
        .optional(),
      acceptedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      defaultSubscription: z.lazy(() => SubscriptionOrderByWithRelationInputSchema).optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigOrderByRelationAggregateInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityWhereUniqueInputSchema: z.ZodType<Prisma.AvailabilityWhereUniqueInput> = z
  .object({
    id: z.string().cuid(),
  })
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        AND: z
          .union([
            z.lazy(() => AvailabilityWhereInputSchema),
            z.lazy(() => AvailabilityWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => AvailabilityWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => AvailabilityWhereInputSchema),
            z.lazy(() => AvailabilityWhereInputSchema).array(),
          ])
          .optional(),
        serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        organizationId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        locationId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        connectionId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        createdById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        createdByMembershipId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        isProviderCreated: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        status: z
          .union([
            z.lazy(() => EnumAvailabilityStatusFilterSchema),
            z.lazy(() => AvailabilityStatusSchema),
          ])
          .optional(),
        acceptedById: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        acceptedAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        requiresConfirmation: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        billingEntity: z
          .union([
            z.lazy(() => EnumBillingEntityNullableFilterSchema),
            z.lazy(() => BillingEntitySchema),
          ])
          .optional()
          .nullable(),
        defaultSubscriptionId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        serviceProvider: z
          .union([
            z.lazy(() => ServiceProviderRelationFilterSchema),
            z.lazy(() => ServiceProviderWhereInputSchema),
          ])
          .optional(),
        organization: z
          .union([
            z.lazy(() => OrganizationNullableRelationFilterSchema),
            z.lazy(() => OrganizationWhereInputSchema),
          ])
          .optional()
          .nullable(),
        location: z
          .union([
            z.lazy(() => LocationNullableRelationFilterSchema),
            z.lazy(() => LocationWhereInputSchema),
          ])
          .optional()
          .nullable(),
        providerConnection: z
          .union([
            z.lazy(() => OrganizationProviderConnectionNullableRelationFilterSchema),
            z.lazy(() => OrganizationProviderConnectionWhereInputSchema),
          ])
          .optional()
          .nullable(),
        createdBy: z
          .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
          .optional(),
        createdByMembership: z
          .union([
            z.lazy(() => OrganizationMembershipNullableRelationFilterSchema),
            z.lazy(() => OrganizationMembershipWhereInputSchema),
          ])
          .optional()
          .nullable(),
        acceptedBy: z
          .union([
            z.lazy(() => UserNullableRelationFilterSchema),
            z.lazy(() => UserWhereInputSchema),
          ])
          .optional()
          .nullable(),
        defaultSubscription: z
          .union([
            z.lazy(() => SubscriptionNullableRelationFilterSchema),
            z.lazy(() => SubscriptionWhereInputSchema),
          ])
          .optional()
          .nullable(),
        availableServices: z
          .lazy(() => ServiceAvailabilityConfigListRelationFilterSchema)
          .optional(),
        calculatedSlots: z
          .lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema)
          .optional(),
      })
      .strict()
  );

export const AvailabilityOrderByWithAggregationInputSchema: z.ZodType<Prisma.AvailabilityOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      locationId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      connectionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      acceptedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      requiresConfirmation: z.lazy(() => SortOrderSchema).optional(),
      billingEntity: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      defaultSubscriptionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => AvailabilityCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => AvailabilityMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => AvailabilityMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const AvailabilityScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.AvailabilityScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => AvailabilityScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AvailabilityScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => AvailabilityScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => AvailabilityScalarWhereWithAggregatesInputSchema),
          z.lazy(() => AvailabilityScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      organizationId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      locationId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      startTime: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      endTime: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      createdById: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      createdByMembershipId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumAvailabilityStatusWithAggregatesFilterSchema),
          z.lazy(() => AvailabilityStatusSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => EnumBillingEntityNullableWithAggregatesFilterSchema),
          z.lazy(() => BillingEntitySchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotWhereInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalculatedAvailabilitySlotWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      availabilityId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceConfigId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      status: z
        .union([z.lazy(() => EnumSlotStatusFilterSchema), z.lazy(() => SlotStatusSchema)])
        .optional(),
      lastCalculated: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      billedToSubscriptionId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      availability: z
        .union([
          z.lazy(() => AvailabilityRelationFilterSchema),
          z.lazy(() => AvailabilityWhereInputSchema),
        ])
        .optional(),
      service: z
        .union([z.lazy(() => ServiceRelationFilterSchema), z.lazy(() => ServiceWhereInputSchema)])
        .optional(),
      serviceConfig: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigRelationFilterSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereInputSchema),
        ])
        .optional(),
      booking: z
        .union([
          z.lazy(() => BookingNullableRelationFilterSchema),
          z.lazy(() => BookingWhereInputSchema),
        ])
        .optional()
        .nullable(),
      billedToSubscription: z
        .union([
          z.lazy(() => SubscriptionNullableRelationFilterSchema),
          z.lazy(() => SubscriptionWhereInputSchema),
        ])
        .optional()
        .nullable(),
      blockedByCalendarEvent: z
        .union([
          z.lazy(() => CalendarEventNullableRelationFilterSchema),
          z.lazy(() => CalendarEventWhereInputSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const CalculatedAvailabilitySlotOrderByWithRelationInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      availabilityId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceConfigId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      lastCalculated: z.lazy(() => SortOrderSchema).optional(),
      billedToSubscriptionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      blockedByEventId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      availability: z.lazy(() => AvailabilityOrderByWithRelationInputSchema).optional(),
      service: z.lazy(() => ServiceOrderByWithRelationInputSchema).optional(),
      serviceConfig: z
        .lazy(() => ServiceAvailabilityConfigOrderByWithRelationInputSchema)
        .optional(),
      booking: z.lazy(() => BookingOrderByWithRelationInputSchema).optional(),
      billedToSubscription: z.lazy(() => SubscriptionOrderByWithRelationInputSchema).optional(),
      blockedByCalendarEvent: z.lazy(() => CalendarEventOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotWhereUniqueInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema),
              z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CalculatedAvailabilitySlotWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema),
              z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).array(),
            ])
            .optional(),
          availabilityId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          serviceConfigId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          status: z
            .union([z.lazy(() => EnumSlotStatusFilterSchema), z.lazy(() => SlotStatusSchema)])
            .optional(),
          lastCalculated: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          billedToSubscriptionId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          blockedByEventId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          version: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          availability: z
            .union([
              z.lazy(() => AvailabilityRelationFilterSchema),
              z.lazy(() => AvailabilityWhereInputSchema),
            ])
            .optional(),
          service: z
            .union([
              z.lazy(() => ServiceRelationFilterSchema),
              z.lazy(() => ServiceWhereInputSchema),
            ])
            .optional(),
          serviceConfig: z
            .union([
              z.lazy(() => ServiceAvailabilityConfigRelationFilterSchema),
              z.lazy(() => ServiceAvailabilityConfigWhereInputSchema),
            ])
            .optional(),
          booking: z
            .union([
              z.lazy(() => BookingNullableRelationFilterSchema),
              z.lazy(() => BookingWhereInputSchema),
            ])
            .optional()
            .nullable(),
          billedToSubscription: z
            .union([
              z.lazy(() => SubscriptionNullableRelationFilterSchema),
              z.lazy(() => SubscriptionWhereInputSchema),
            ])
            .optional()
            .nullable(),
          blockedByCalendarEvent: z
            .union([
              z.lazy(() => CalendarEventNullableRelationFilterSchema),
              z.lazy(() => CalendarEventWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict()
    );

export const CalculatedAvailabilitySlotOrderByWithAggregationInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      availabilityId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceConfigId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      lastCalculated: z.lazy(() => SortOrderSchema).optional(),
      billedToSubscriptionId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      blockedByEventId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CalculatedAvailabilitySlotCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CalculatedAvailabilitySlotAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CalculatedAvailabilitySlotMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CalculatedAvailabilitySlotMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CalculatedAvailabilitySlotSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      availabilityId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      serviceId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceConfigId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      startTime: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      endTime: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumSlotStatusWithAggregatesFilterSchema),
          z.lazy(() => SlotStatusSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      billedToSubscriptionId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      version: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const BookingWhereInputSchema: z.ZodType<Prisma.BookingWhereInput> = z
  .object({
    AND: z
      .union([z.lazy(() => BookingWhereInputSchema), z.lazy(() => BookingWhereInputSchema).array()])
      .optional(),
    OR: z
      .lazy(() => BookingWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([z.lazy(() => BookingWhereInputSchema), z.lazy(() => BookingWhereInputSchema).array()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slotId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdByMembershipId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isProviderCreated: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    isGuestBooking: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    isGuestSelfBooking: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    confirmedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    confirmedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    clientId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestName: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestEmail: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestPhone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestWhatsapp: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    price: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    isOnline: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    isInPerson: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    status: z
      .union([z.lazy(() => EnumBookingStatusFilterSchema), z.lazy(() => BookingStatusSchema)])
      .optional(),
    notes: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    meetLink: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    calendarEventId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    slot: z
      .union([
        z.lazy(() => CalculatedAvailabilitySlotNullableRelationFilterSchema),
        z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema),
      ])
      .optional()
      .nullable(),
    createdBy: z
      .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional()
      .nullable(),
    createdByMembership: z
      .union([
        z.lazy(() => OrganizationMembershipNullableRelationFilterSchema),
        z.lazy(() => OrganizationMembershipWhereInputSchema),
      ])
      .optional()
      .nullable(),
    confirmedBy: z
      .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional()
      .nullable(),
    client: z
      .union([z.lazy(() => UserNullableRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional()
      .nullable(),
    communications: z.lazy(() => CommunicationLogListRelationFilterSchema).optional(),
    review: z
      .union([
        z.lazy(() => ReviewNullableRelationFilterSchema),
        z.lazy(() => ReviewWhereInputSchema),
      ])
      .optional()
      .nullable(),
    meetSession: z
      .union([
        z.lazy(() => MeetSessionNullableRelationFilterSchema),
        z.lazy(() => MeetSessionWhereInputSchema),
      ])
      .optional()
      .nullable(),
  })
  .strict();

export const BookingOrderByWithRelationInputSchema: z.ZodType<Prisma.BookingOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      slotId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      isGuestBooking: z.lazy(() => SortOrderSchema).optional(),
      isGuestSelfBooking: z.lazy(() => SortOrderSchema).optional(),
      confirmedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      clientId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestEmail: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestPhone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestWhatsapp: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnline: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      notes: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      meetLink: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      calendarEventId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      slot: z.lazy(() => CalculatedAvailabilitySlotOrderByWithRelationInputSchema).optional(),
      createdBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipOrderByWithRelationInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      client: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      communications: z.lazy(() => CommunicationLogOrderByRelationAggregateInputSchema).optional(),
      review: z.lazy(() => ReviewOrderByWithRelationInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const BookingWhereUniqueInputSchema: z.ZodType<Prisma.BookingWhereUniqueInput> = z
  .union([
    z.object({
      id: z.string().cuid(),
      slotId: z.string(),
    }),
    z.object({
      id: z.string().cuid(),
    }),
    z.object({
      slotId: z.string(),
    }),
  ])
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        slotId: z.string().optional(),
        AND: z
          .union([
            z.lazy(() => BookingWhereInputSchema),
            z.lazy(() => BookingWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => BookingWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => BookingWhereInputSchema),
            z.lazy(() => BookingWhereInputSchema).array(),
          ])
          .optional(),
        createdById: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        createdByMembershipId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        isProviderCreated: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        isGuestBooking: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        isGuestSelfBooking: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        confirmedById: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        confirmedAt: z
          .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
          .optional()
          .nullable(),
        clientId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        guestName: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        guestEmail: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        guestPhone: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        guestWhatsapp: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        price: z.union([z.lazy(() => DecimalFilterSchema), z.number().positive()]).optional(),
        isOnline: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        isInPerson: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        status: z
          .union([z.lazy(() => EnumBookingStatusFilterSchema), z.lazy(() => BookingStatusSchema)])
          .optional(),
        notes: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        meetLink: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        calendarEventId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        version: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        slot: z
          .union([
            z.lazy(() => CalculatedAvailabilitySlotNullableRelationFilterSchema),
            z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema),
          ])
          .optional()
          .nullable(),
        createdBy: z
          .union([
            z.lazy(() => UserNullableRelationFilterSchema),
            z.lazy(() => UserWhereInputSchema),
          ])
          .optional()
          .nullable(),
        createdByMembership: z
          .union([
            z.lazy(() => OrganizationMembershipNullableRelationFilterSchema),
            z.lazy(() => OrganizationMembershipWhereInputSchema),
          ])
          .optional()
          .nullable(),
        confirmedBy: z
          .union([
            z.lazy(() => UserNullableRelationFilterSchema),
            z.lazy(() => UserWhereInputSchema),
          ])
          .optional()
          .nullable(),
        client: z
          .union([
            z.lazy(() => UserNullableRelationFilterSchema),
            z.lazy(() => UserWhereInputSchema),
          ])
          .optional()
          .nullable(),
        communications: z.lazy(() => CommunicationLogListRelationFilterSchema).optional(),
        review: z
          .union([
            z.lazy(() => ReviewNullableRelationFilterSchema),
            z.lazy(() => ReviewWhereInputSchema),
          ])
          .optional()
          .nullable(),
        meetSession: z
          .union([
            z.lazy(() => MeetSessionNullableRelationFilterSchema),
            z.lazy(() => MeetSessionWhereInputSchema),
          ])
          .optional()
          .nullable(),
      })
      .strict()
  );

export const BookingOrderByWithAggregationInputSchema: z.ZodType<Prisma.BookingOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      slotId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      isGuestBooking: z.lazy(() => SortOrderSchema).optional(),
      isGuestSelfBooking: z.lazy(() => SortOrderSchema).optional(),
      confirmedById: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      clientId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestEmail: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestPhone: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      guestWhatsapp: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnline: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      notes: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      meetLink: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      calendarEventId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => BookingCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => BookingAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => BookingMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => BookingMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => BookingSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const BookingScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.BookingScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => BookingScalarWhereWithAggregatesInputSchema),
          z.lazy(() => BookingScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => BookingScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => BookingScalarWhereWithAggregatesInputSchema),
          z.lazy(() => BookingScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      slotId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdById: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      isGuestBooking: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      isGuestSelfBooking: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      confirmedById: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      clientId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      guestName: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      price: z
        .union([
          z.lazy(() => DecimalWithAggregatesFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      isOnline: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      isInPerson: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumBookingStatusWithAggregatesFilterSchema),
          z.lazy(() => BookingStatusSchema),
        ])
        .optional(),
      notes: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      version: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceWhereInputSchema: z.ZodType<Prisma.CommunicationPreferenceWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereInputSchema),
          z.lazy(() => CommunicationPreferenceWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CommunicationPreferenceWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereInputSchema),
          z.lazy(() => CommunicationPreferenceWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      sms: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      whatsapp: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      phoneNumber: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      reminderHours: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      user: z
        .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceOrderByWithRelationInputSchema: z.ZodType<Prisma.CommunicationPreferenceOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      sms: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      phoneNumber: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      whatsappNumber: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      user: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceWhereUniqueInputSchema: z.ZodType<Prisma.CommunicationPreferenceWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => CommunicationPreferenceWhereInputSchema),
              z.lazy(() => CommunicationPreferenceWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CommunicationPreferenceWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CommunicationPreferenceWhereInputSchema),
              z.lazy(() => CommunicationPreferenceWhereInputSchema).array(),
            ])
            .optional(),
          userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          email: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          sms: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          whatsapp: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          phoneNumber: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          whatsappNumber: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          reminderHours: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          user: z
            .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
            .optional(),
        })
        .strict()
    );

export const CommunicationPreferenceOrderByWithAggregationInputSchema: z.ZodType<Prisma.CommunicationPreferenceOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      sms: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      phoneNumber: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      whatsappNumber: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CommunicationPreferenceCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CommunicationPreferenceAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CommunicationPreferenceMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CommunicationPreferenceMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CommunicationPreferenceSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CommunicationPreferenceScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommunicationPreferenceScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CommunicationPreferenceScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CommunicationPreferenceScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommunicationPreferenceScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CommunicationPreferenceScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      sms: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      whatsapp: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      phoneNumber: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      reminderHours: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const CommunicationLogWhereInputSchema: z.ZodType<Prisma.CommunicationLogWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CommunicationLogWhereInputSchema),
        z.lazy(() => CommunicationLogWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => CommunicationLogWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CommunicationLogWhereInputSchema),
        z.lazy(() => CommunicationLogWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    bookingId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    bookingReference: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    serviceProviderName: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    clientName: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    serviceName: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    appointmentTime: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    type: z
      .union([
        z.lazy(() => EnumCommunicationTypeFilterSchema),
        z.lazy(() => CommunicationTypeSchema),
      ])
      .optional(),
    channel: z
      .union([
        z.lazy(() => EnumCommunicationChannelFilterSchema),
        z.lazy(() => CommunicationChannelSchema),
      ])
      .optional(),
    content: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    sentAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    deliveredAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    booking: z
      .union([
        z.lazy(() => BookingNullableRelationFilterSchema),
        z.lazy(() => BookingWhereInputSchema),
      ])
      .optional()
      .nullable(),
  })
  .strict();

export const CommunicationLogOrderByWithRelationInputSchema: z.ZodType<Prisma.CommunicationLogOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      bookingReference: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceProviderName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      clientName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      appointmentTime: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      channel: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      sentAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const CommunicationLogWhereUniqueInputSchema: z.ZodType<Prisma.CommunicationLogWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => CommunicationLogWhereInputSchema),
              z.lazy(() => CommunicationLogWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CommunicationLogWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CommunicationLogWhereInputSchema),
              z.lazy(() => CommunicationLogWhereInputSchema).array(),
            ])
            .optional(),
          bookingId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          bookingReference: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          serviceProviderName: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          clientName: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          serviceName: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          appointmentTime: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          type: z
            .union([
              z.lazy(() => EnumCommunicationTypeFilterSchema),
              z.lazy(() => CommunicationTypeSchema),
            ])
            .optional(),
          channel: z
            .union([
              z.lazy(() => EnumCommunicationChannelFilterSchema),
              z.lazy(() => CommunicationChannelSchema),
            ])
            .optional(),
          content: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          sentAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          deliveredAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          booking: z
            .union([
              z.lazy(() => BookingNullableRelationFilterSchema),
              z.lazy(() => BookingWhereInputSchema),
            ])
            .optional()
            .nullable(),
        })
        .strict()
    );

export const CommunicationLogOrderByWithAggregationInputSchema: z.ZodType<Prisma.CommunicationLogOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      bookingReference: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceProviderName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      clientName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      serviceName: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      appointmentTime: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      channel: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      sentAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      _count: z.lazy(() => CommunicationLogCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CommunicationLogMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CommunicationLogMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CommunicationLogScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CommunicationLogScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommunicationLogScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CommunicationLogScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CommunicationLogScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommunicationLogScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CommunicationLogScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      bookingId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      bookingReference: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      clientName: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumCommunicationTypeWithAggregatesFilterSchema),
          z.lazy(() => CommunicationTypeSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => EnumCommunicationChannelWithAggregatesFilterSchema),
          z.lazy(() => CommunicationChannelSchema),
        ])
        .optional(),
      content: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      status: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      sentAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      deliveredAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict();

export const CalendarIntegrationWhereInputSchema: z.ZodType<Prisma.CalendarIntegrationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarIntegrationWhereInputSchema),
          z.lazy(() => CalendarIntegrationWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarIntegrationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarIntegrationWhereInputSchema),
          z.lazy(() => CalendarIntegrationWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      provider: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      accessToken: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      refreshToken: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expiresAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      calendarId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      syncEnabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      lastSyncedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      grantedScopes: z.lazy(() => StringNullableListFilterSchema).optional(),
      meetSettings: z.lazy(() => JsonNullableFilterSchema).optional(),
      webhookChannelId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => EnumCalendarSyncDirectionFilterSchema),
          z.lazy(() => CalendarSyncDirectionSchema),
        ])
        .optional(),
      blockingEventTypes: z.lazy(() => StringNullableListFilterSchema).optional(),
      autoCreateMeetLinks: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      backgroundSyncEnabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      syncIntervalMinutes: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      lastFullSyncAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      syncFailureCount: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      serviceProvider: z
        .union([
          z.lazy(() => ServiceProviderRelationFilterSchema),
          z.lazy(() => ServiceProviderWhereInputSchema),
        ])
        .optional(),
      calendarEvents: z.lazy(() => CalendarEventListRelationFilterSchema).optional(),
      syncOperations: z.lazy(() => CalendarSyncOperationListRelationFilterSchema).optional(),
    })
    .strict();

export const CalendarIntegrationOrderByWithRelationInputSchema: z.ZodType<Prisma.CalendarIntegrationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      calendarId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncEnabled: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      googleEmail: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      grantedScopes: z.lazy(() => SortOrderSchema).optional(),
      meetSettings: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      webhookChannelId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      webhookResourceId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      webhookExpiresAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      nextSyncToken: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncDirection: z.lazy(() => SortOrderSchema).optional(),
      blockingEventTypes: z.lazy(() => SortOrderSchema).optional(),
      autoCreateMeetLinks: z.lazy(() => SortOrderSchema).optional(),
      backgroundSyncEnabled: z.lazy(() => SortOrderSchema).optional(),
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      lastFullSyncAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      calendarEvents: z.lazy(() => CalendarEventOrderByRelationAggregateInputSchema).optional(),
      syncOperations: z
        .lazy(() => CalendarSyncOperationOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationWhereUniqueInputSchema: z.ZodType<Prisma.CalendarIntegrationWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        serviceProviderId: z.string(),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        serviceProviderId: z.string(),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          serviceProviderId: z.string().optional(),
          AND: z
            .union([
              z.lazy(() => CalendarIntegrationWhereInputSchema),
              z.lazy(() => CalendarIntegrationWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CalendarIntegrationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CalendarIntegrationWhereInputSchema),
              z.lazy(() => CalendarIntegrationWhereInputSchema).array(),
            ])
            .optional(),
          provider: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          accessToken: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          refreshToken: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          expiresAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          calendarId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          syncEnabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          lastSyncedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          googleEmail: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          grantedScopes: z.lazy(() => StringNullableListFilterSchema).optional(),
          meetSettings: z.lazy(() => JsonNullableFilterSchema).optional(),
          webhookChannelId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          webhookResourceId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          webhookExpiresAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          nextSyncToken: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          syncDirection: z
            .union([
              z.lazy(() => EnumCalendarSyncDirectionFilterSchema),
              z.lazy(() => CalendarSyncDirectionSchema),
            ])
            .optional(),
          blockingEventTypes: z.lazy(() => StringNullableListFilterSchema).optional(),
          autoCreateMeetLinks: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          backgroundSyncEnabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          syncIntervalMinutes: z
            .union([z.lazy(() => IntFilterSchema), z.number().int()])
            .optional(),
          lastFullSyncAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          syncFailureCount: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          serviceProvider: z
            .union([
              z.lazy(() => ServiceProviderRelationFilterSchema),
              z.lazy(() => ServiceProviderWhereInputSchema),
            ])
            .optional(),
          calendarEvents: z.lazy(() => CalendarEventListRelationFilterSchema).optional(),
          syncOperations: z.lazy(() => CalendarSyncOperationListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const CalendarIntegrationOrderByWithAggregationInputSchema: z.ZodType<Prisma.CalendarIntegrationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      calendarId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncEnabled: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      googleEmail: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      grantedScopes: z.lazy(() => SortOrderSchema).optional(),
      meetSettings: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      webhookChannelId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      webhookResourceId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      webhookExpiresAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      nextSyncToken: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncDirection: z.lazy(() => SortOrderSchema).optional(),
      blockingEventTypes: z.lazy(() => SortOrderSchema).optional(),
      autoCreateMeetLinks: z.lazy(() => SortOrderSchema).optional(),
      backgroundSyncEnabled: z.lazy(() => SortOrderSchema).optional(),
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      lastFullSyncAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CalendarIntegrationCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CalendarIntegrationAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CalendarIntegrationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CalendarIntegrationMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CalendarIntegrationSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CalendarIntegrationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CalendarIntegrationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarIntegrationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalendarIntegrationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarIntegrationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarIntegrationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalendarIntegrationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      provider: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      accessToken: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      refreshToken: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      calendarId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      syncEnabled: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      lastSyncedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      grantedScopes: z.lazy(() => StringNullableListFilterSchema).optional(),
      meetSettings: z.lazy(() => JsonNullableWithAggregatesFilterSchema).optional(),
      webhookChannelId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => EnumCalendarSyncDirectionWithAggregatesFilterSchema),
          z.lazy(() => CalendarSyncDirectionSchema),
        ])
        .optional(),
      blockingEventTypes: z.lazy(() => StringNullableListFilterSchema).optional(),
      autoCreateMeetLinks: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      syncIntervalMinutes: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      lastFullSyncAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const CalendarEventWhereInputSchema: z.ZodType<Prisma.CalendarEventWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => CalendarEventWhereInputSchema),
        z.lazy(() => CalendarEventWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => CalendarEventWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => CalendarEventWhereInputSchema),
        z.lazy(() => CalendarEventWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    calendarIntegrationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    externalEventId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    externalCalendarId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    etag: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    isAllDay: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    lastSyncedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    eventType: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    blocksAvailability: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    syncStatus: z
      .union([
        z.lazy(() => EnumCalendarEventSyncStatusFilterSchema),
        z.lazy(() => CalendarEventSyncStatusSchema),
      ])
      .optional(),
    lastModifiedInExternal: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    hasConflict: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    conflictDetails: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    conflictResolvedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    calendarIntegration: z
      .union([
        z.lazy(() => CalendarIntegrationRelationFilterSchema),
        z.lazy(() => CalendarIntegrationWhereInputSchema),
      ])
      .optional(),
    blockedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
  })
  .strict();

export const CalendarEventOrderByWithRelationInputSchema: z.ZodType<Prisma.CalendarEventOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      externalCalendarId: z.lazy(() => SortOrderSchema).optional(),
      etag: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      isAllDay: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      eventType: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      blocksAvailability: z.lazy(() => SortOrderSchema).optional(),
      syncStatus: z.lazy(() => SortOrderSchema).optional(),
      lastModifiedInExternal: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      hasConflict: z.lazy(() => SortOrderSchema).optional(),
      conflictDetails: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      conflictResolvedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationOrderByWithRelationInputSchema)
        .optional(),
      blockedSlots: z
        .lazy(() => CalculatedAvailabilitySlotOrderByRelationAggregateInputSchema)
        .optional(),
    })
    .strict();

export const CalendarEventWhereUniqueInputSchema: z.ZodType<Prisma.CalendarEventWhereUniqueInput> =
  z
    .union([
      z.object({
        id: z.string().cuid(),
        calendarIntegrationId_externalEventId: z.lazy(
          () => CalendarEventCalendarIntegrationIdExternalEventIdCompoundUniqueInputSchema
        ),
      }),
      z.object({
        id: z.string().cuid(),
      }),
      z.object({
        calendarIntegrationId_externalEventId: z.lazy(
          () => CalendarEventCalendarIntegrationIdExternalEventIdCompoundUniqueInputSchema
        ),
      }),
    ])
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          calendarIntegrationId_externalEventId: z
            .lazy(() => CalendarEventCalendarIntegrationIdExternalEventIdCompoundUniqueInputSchema)
            .optional(),
          AND: z
            .union([
              z.lazy(() => CalendarEventWhereInputSchema),
              z.lazy(() => CalendarEventWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CalendarEventWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CalendarEventWhereInputSchema),
              z.lazy(() => CalendarEventWhereInputSchema).array(),
            ])
            .optional(),
          calendarIntegrationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          externalEventId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          externalCalendarId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          etag: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          isAllDay: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          lastSyncedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          eventType: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          blocksAvailability: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          syncStatus: z
            .union([
              z.lazy(() => EnumCalendarEventSyncStatusFilterSchema),
              z.lazy(() => CalendarEventSyncStatusSchema),
            ])
            .optional(),
          lastModifiedInExternal: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          hasConflict: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
          conflictDetails: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          conflictResolvedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          version: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          calendarIntegration: z
            .union([
              z.lazy(() => CalendarIntegrationRelationFilterSchema),
              z.lazy(() => CalendarIntegrationWhereInputSchema),
            ])
            .optional(),
          blockedSlots: z.lazy(() => CalculatedAvailabilitySlotListRelationFilterSchema).optional(),
        })
        .strict()
    );

export const CalendarEventOrderByWithAggregationInputSchema: z.ZodType<Prisma.CalendarEventOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      externalCalendarId: z.lazy(() => SortOrderSchema).optional(),
      etag: z.union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)]).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      isAllDay: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      eventType: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      blocksAvailability: z.lazy(() => SortOrderSchema).optional(),
      syncStatus: z.lazy(() => SortOrderSchema).optional(),
      lastModifiedInExternal: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      hasConflict: z.lazy(() => SortOrderSchema).optional(),
      conflictDetails: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      conflictResolvedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CalendarEventCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CalendarEventAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CalendarEventMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CalendarEventMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CalendarEventSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CalendarEventScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CalendarEventScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarEventScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalendarEventScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarEventScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarEventScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalendarEventScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      calendarIntegrationId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      externalEventId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      externalCalendarId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      etag: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      title: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      startTime: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      endTime: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      isAllDay: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      lastSyncedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      eventType: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => EnumCalendarEventSyncStatusWithAggregatesFilterSchema),
          z.lazy(() => CalendarEventSyncStatusSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      hasConflict: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      conflictDetails: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      version: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationWhereInputSchema: z.ZodType<Prisma.CalendarSyncOperationWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereInputSchema),
          z.lazy(() => CalendarSyncOperationWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarSyncOperationWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereInputSchema),
          z.lazy(() => CalendarSyncOperationWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      calendarIntegrationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      operationType: z
        .union([
          z.lazy(() => EnumCalendarSyncOperationTypeFilterSchema),
          z.lazy(() => CalendarSyncOperationTypeSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => EnumCalendarSyncSourceFilterSchema),
          z.lazy(() => CalendarSyncSourceSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumCalendarSyncStatusFilterSchema),
          z.lazy(() => CalendarSyncStatusSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EnumCalendarEntityTypeFilterSchema),
          z.lazy(() => CalendarEntityTypeSchema),
        ])
        .optional(),
      entityId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      startedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      completedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      retryCount: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      maxRetries: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      errorMessage: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => EnumConflictResolutionNullableFilterSchema),
          z.lazy(() => ConflictResolutionSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      eventsProcessed: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      eventsSucceeded: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      eventsFailed: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      calendarIntegration: z
        .union([
          z.lazy(() => CalendarIntegrationRelationFilterSchema),
          z.lazy(() => CalendarIntegrationWhereInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationOrderByWithRelationInputSchema: z.ZodType<Prisma.CalendarSyncOperationOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      operationType: z.lazy(() => SortOrderSchema).optional(),
      sourceSystem: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      entityId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      completedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      conflictResolution: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncWindowStart: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncWindowEnd: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationOrderByWithRelationInputSchema)
        .optional(),
    })
    .strict();

export const CalendarSyncOperationWhereUniqueInputSchema: z.ZodType<Prisma.CalendarSyncOperationWhereUniqueInput> =
  z
    .object({
      id: z.string().cuid(),
    })
    .and(
      z
        .object({
          id: z.string().cuid().optional(),
          AND: z
            .union([
              z.lazy(() => CalendarSyncOperationWhereInputSchema),
              z.lazy(() => CalendarSyncOperationWhereInputSchema).array(),
            ])
            .optional(),
          OR: z
            .lazy(() => CalendarSyncOperationWhereInputSchema)
            .array()
            .optional(),
          NOT: z
            .union([
              z.lazy(() => CalendarSyncOperationWhereInputSchema),
              z.lazy(() => CalendarSyncOperationWhereInputSchema).array(),
            ])
            .optional(),
          calendarIntegrationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
          operationType: z
            .union([
              z.lazy(() => EnumCalendarSyncOperationTypeFilterSchema),
              z.lazy(() => CalendarSyncOperationTypeSchema),
            ])
            .optional(),
          sourceSystem: z
            .union([
              z.lazy(() => EnumCalendarSyncSourceFilterSchema),
              z.lazy(() => CalendarSyncSourceSchema),
            ])
            .optional(),
          status: z
            .union([
              z.lazy(() => EnumCalendarSyncStatusFilterSchema),
              z.lazy(() => CalendarSyncStatusSchema),
            ])
            .optional(),
          entityType: z
            .union([
              z.lazy(() => EnumCalendarEntityTypeFilterSchema),
              z.lazy(() => CalendarEntityTypeSchema),
            ])
            .optional(),
          entityId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          externalEventId: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          startedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          completedAt: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          retryCount: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          maxRetries: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          errorMessage: z
            .union([z.lazy(() => StringNullableFilterSchema), z.string()])
            .optional()
            .nullable(),
          conflictResolution: z
            .union([
              z.lazy(() => EnumConflictResolutionNullableFilterSchema),
              z.lazy(() => ConflictResolutionSchema),
            ])
            .optional()
            .nullable(),
          syncWindowStart: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          syncWindowEnd: z
            .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
            .optional()
            .nullable(),
          eventsProcessed: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          eventsSucceeded: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          eventsFailed: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
          createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
          calendarIntegration: z
            .union([
              z.lazy(() => CalendarIntegrationRelationFilterSchema),
              z.lazy(() => CalendarIntegrationWhereInputSchema),
            ])
            .optional(),
        })
        .strict()
    );

export const CalendarSyncOperationOrderByWithAggregationInputSchema: z.ZodType<Prisma.CalendarSyncOperationOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      operationType: z.lazy(() => SortOrderSchema).optional(),
      sourceSystem: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      entityId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      completedAt: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      conflictResolution: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncWindowStart: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      syncWindowEnd: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => CalendarSyncOperationCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => CalendarSyncOperationAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => CalendarSyncOperationMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => CalendarSyncOperationMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => CalendarSyncOperationSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.CalendarSyncOperationScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarSyncOperationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalendarSyncOperationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarSyncOperationScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarSyncOperationScalarWhereWithAggregatesInputSchema),
          z.lazy(() => CalendarSyncOperationScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      calendarIntegrationId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => EnumCalendarSyncOperationTypeWithAggregatesFilterSchema),
          z.lazy(() => CalendarSyncOperationTypeSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => EnumCalendarSyncSourceWithAggregatesFilterSchema),
          z.lazy(() => CalendarSyncSourceSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumCalendarSyncStatusWithAggregatesFilterSchema),
          z.lazy(() => CalendarSyncStatusSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EnumCalendarEntityTypeWithAggregatesFilterSchema),
          z.lazy(() => CalendarEntityTypeSchema),
        ])
        .optional(),
      entityId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      completedAt: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      retryCount: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      maxRetries: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      errorMessage: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => EnumConflictResolutionNullableWithAggregatesFilterSchema),
          z.lazy(() => ConflictResolutionSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.lazy(() => DateTimeNullableWithAggregatesFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      eventsSucceeded: z
        .union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()])
        .optional(),
      eventsFailed: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const MeetSessionWhereInputSchema: z.ZodType<Prisma.MeetSessionWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => MeetSessionWhereInputSchema),
        z.lazy(() => MeetSessionWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => MeetSessionWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => MeetSessionWhereInputSchema),
        z.lazy(() => MeetSessionWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    bookingId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    meetLink: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    eventId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    joinCode: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => EnumMeetSessionStatusFilterSchema),
        z.lazy(() => MeetSessionStatusSchema),
      ])
      .optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    booking: z
      .union([z.lazy(() => BookingRelationFilterSchema), z.lazy(() => BookingWhereInputSchema)])
      .optional(),
  })
  .strict();

export const MeetSessionOrderByWithRelationInputSchema: z.ZodType<Prisma.MeetSessionOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      eventId: z.lazy(() => SortOrderSchema).optional(),
      joinCode: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      booking: z.lazy(() => BookingOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const MeetSessionWhereUniqueInputSchema: z.ZodType<Prisma.MeetSessionWhereUniqueInput> = z
  .union([
    z.object({
      id: z.string().cuid(),
      bookingId: z.string(),
    }),
    z.object({
      id: z.string().cuid(),
    }),
    z.object({
      bookingId: z.string(),
    }),
  ])
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        bookingId: z.string().optional(),
        AND: z
          .union([
            z.lazy(() => MeetSessionWhereInputSchema),
            z.lazy(() => MeetSessionWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => MeetSessionWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => MeetSessionWhereInputSchema),
            z.lazy(() => MeetSessionWhereInputSchema).array(),
          ])
          .optional(),
        meetLink: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        eventId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        joinCode: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        status: z
          .union([
            z.lazy(() => EnumMeetSessionStatusFilterSchema),
            z.lazy(() => MeetSessionStatusSchema),
          ])
          .optional(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        booking: z
          .union([z.lazy(() => BookingRelationFilterSchema), z.lazy(() => BookingWhereInputSchema)])
          .optional(),
      })
      .strict()
  );

export const MeetSessionOrderByWithAggregationInputSchema: z.ZodType<Prisma.MeetSessionOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      eventId: z.lazy(() => SortOrderSchema).optional(),
      joinCode: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => MeetSessionCountOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => MeetSessionMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => MeetSessionMinOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const MeetSessionScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.MeetSessionScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => MeetSessionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => MeetSessionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => MeetSessionScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => MeetSessionScalarWhereWithAggregatesInputSchema),
          z.lazy(() => MeetSessionScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      bookingId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      meetLink: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      eventId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      joinCode: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumMeetSessionStatusWithAggregatesFilterSchema),
          z.lazy(() => MeetSessionStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const ReviewWhereInputSchema: z.ZodType<Prisma.ReviewWhereInput> = z
  .object({
    AND: z
      .union([z.lazy(() => ReviewWhereInputSchema), z.lazy(() => ReviewWhereInputSchema).array()])
      .optional(),
    OR: z
      .lazy(() => ReviewWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([z.lazy(() => ReviewWhereInputSchema), z.lazy(() => ReviewWhereInputSchema).array()])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    clientId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    bookingId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    rating: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    comment: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    response: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isPublic: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    googleReviewId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([z.lazy(() => EnumReviewStatusFilterSchema), z.lazy(() => ReviewStatusSchema)])
      .optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    serviceProvider: z
      .union([
        z.lazy(() => ServiceProviderRelationFilterSchema),
        z.lazy(() => ServiceProviderWhereInputSchema),
      ])
      .optional(),
    client: z
      .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
      .optional(),
    booking: z
      .union([z.lazy(() => BookingRelationFilterSchema), z.lazy(() => BookingWhereInputSchema)])
      .optional(),
  })
  .strict();

export const ReviewOrderByWithRelationInputSchema: z.ZodType<Prisma.ReviewOrderByWithRelationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      rating: z.lazy(() => SortOrderSchema).optional(),
      comment: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      response: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isPublic: z.lazy(() => SortOrderSchema).optional(),
      googleReviewId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      serviceProvider: z.lazy(() => ServiceProviderOrderByWithRelationInputSchema).optional(),
      client: z.lazy(() => UserOrderByWithRelationInputSchema).optional(),
      booking: z.lazy(() => BookingOrderByWithRelationInputSchema).optional(),
    })
    .strict();

export const ReviewWhereUniqueInputSchema: z.ZodType<Prisma.ReviewWhereUniqueInput> = z
  .union([
    z.object({
      id: z.string().cuid(),
      bookingId: z.string(),
    }),
    z.object({
      id: z.string().cuid(),
    }),
    z.object({
      bookingId: z.string(),
    }),
  ])
  .and(
    z
      .object({
        id: z.string().cuid().optional(),
        bookingId: z.string().optional(),
        AND: z
          .union([
            z.lazy(() => ReviewWhereInputSchema),
            z.lazy(() => ReviewWhereInputSchema).array(),
          ])
          .optional(),
        OR: z
          .lazy(() => ReviewWhereInputSchema)
          .array()
          .optional(),
        NOT: z
          .union([
            z.lazy(() => ReviewWhereInputSchema),
            z.lazy(() => ReviewWhereInputSchema).array(),
          ])
          .optional(),
        serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        clientId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
        rating: z.union([z.lazy(() => IntFilterSchema), z.number().int()]).optional(),
        comment: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        response: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        isPublic: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
        googleReviewId: z
          .union([z.lazy(() => StringNullableFilterSchema), z.string()])
          .optional()
          .nullable(),
        status: z
          .union([z.lazy(() => EnumReviewStatusFilterSchema), z.lazy(() => ReviewStatusSchema)])
          .optional(),
        createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
        serviceProvider: z
          .union([
            z.lazy(() => ServiceProviderRelationFilterSchema),
            z.lazy(() => ServiceProviderWhereInputSchema),
          ])
          .optional(),
        client: z
          .union([z.lazy(() => UserRelationFilterSchema), z.lazy(() => UserWhereInputSchema)])
          .optional(),
        booking: z
          .union([z.lazy(() => BookingRelationFilterSchema), z.lazy(() => BookingWhereInputSchema)])
          .optional(),
      })
      .strict()
  );

export const ReviewOrderByWithAggregationInputSchema: z.ZodType<Prisma.ReviewOrderByWithAggregationInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      rating: z.lazy(() => SortOrderSchema).optional(),
      comment: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      response: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      isPublic: z.lazy(() => SortOrderSchema).optional(),
      googleReviewId: z
        .union([z.lazy(() => SortOrderSchema), z.lazy(() => SortOrderInputSchema)])
        .optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      _count: z.lazy(() => ReviewCountOrderByAggregateInputSchema).optional(),
      _avg: z.lazy(() => ReviewAvgOrderByAggregateInputSchema).optional(),
      _max: z.lazy(() => ReviewMaxOrderByAggregateInputSchema).optional(),
      _min: z.lazy(() => ReviewMinOrderByAggregateInputSchema).optional(),
      _sum: z.lazy(() => ReviewSumOrderByAggregateInputSchema).optional(),
    })
    .strict();

export const ReviewScalarWhereWithAggregatesInputSchema: z.ZodType<Prisma.ReviewScalarWhereWithAggregatesInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ReviewScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ReviewScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ReviewScalarWhereWithAggregatesInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ReviewScalarWhereWithAggregatesInputSchema),
          z.lazy(() => ReviewScalarWhereWithAggregatesInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      serviceProviderId: z
        .union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()])
        .optional(),
      clientId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      bookingId: z.union([z.lazy(() => StringWithAggregatesFilterSchema), z.string()]).optional(),
      rating: z.union([z.lazy(() => IntWithAggregatesFilterSchema), z.number()]).optional(),
      comment: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      response: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      isPublic: z.union([z.lazy(() => BoolWithAggregatesFilterSchema), z.boolean()]).optional(),
      googleReviewId: z
        .union([z.lazy(() => StringNullableWithAggregatesFilterSchema), z.string()])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => EnumReviewStatusWithAggregatesFilterSchema),
          z.lazy(() => ReviewStatusSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
      updatedAt: z
        .union([z.lazy(() => DateTimeWithAggregatesFilterSchema), z.coerce.date()])
        .optional(),
    })
    .strict();

export const UserCreateInputSchema: z.ZodType<Prisma.UserCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    emailVerified: z.coerce.date().optional().nullable(),
    phone: z.string().optional().nullable(),
    phoneVerified: z.coerce.date().optional().nullable(),
    whatsapp: z.string().optional().nullable(),
    whatsappVerified: z.coerce.date().optional().nullable(),
    password: z.string().optional().nullable(),
    image: z.string().optional().nullable(),
    role: z.lazy(() => UserRoleSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
    serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema).optional(),
    bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
    bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
    bookingsConfirmed: z
      .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
      .optional(),
    communicationPreferences: z
      .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
      .optional(),
    organizationMemberships: z
      .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
      .optional(),
    membershipHistoryChanges: z
      .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
      .optional(),
    availabilitiesCreated: z
      .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
      .optional(),
    availabilitiesAccepted: z
      .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
      .optional(),
    organizationsApproved: z
      .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
      .optional(),
    providersApproved: z
      .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
      .optional(),
    sentInvitations: z
      .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
      .optional(),
    reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
    validatedRequirements: z
      .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
      .optional(),
  })
  .strict();

export const UserUncheckedCreateInputSchema: z.ZodType<Prisma.UserUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    emailVerified: z.coerce.date().optional().nullable(),
    phone: z.string().optional().nullable(),
    phoneVerified: z.coerce.date().optional().nullable(),
    whatsapp: z.string().optional().nullable(),
    whatsappVerified: z.coerce.date().optional().nullable(),
    password: z.string().optional().nullable(),
    image: z.string().optional().nullable(),
    role: z.lazy(() => UserRoleSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
    serviceProvider: z
      .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
      .optional(),
    bookingsAsClient: z
      .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
      .optional(),
    bookingsCreated: z
      .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
      .optional(),
    bookingsConfirmed: z
      .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
      .optional(),
    communicationPreferences: z
      .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
      .optional(),
    organizationMemberships: z
      .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
      .optional(),
    membershipHistoryChanges: z
      .lazy(() => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema)
      .optional(),
    availabilitiesCreated: z
      .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
      .optional(),
    availabilitiesAccepted: z
      .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
      .optional(),
    organizationsApproved: z
      .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
      .optional(),
    providersApproved: z
      .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
      .optional(),
    sentInvitations: z
      .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
      .optional(),
    reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
    validatedRequirements: z
      .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
      .optional(),
  })
  .strict();

export const UserUpdateInputSchema: z.ZodType<Prisma.UserUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    emailVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phoneVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsapp: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsappVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    password: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    image: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    role: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
    serviceProvider: z.lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema).optional(),
    bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
    bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
    bookingsConfirmed: z
      .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
      .optional(),
    communicationPreferences: z
      .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    organizationMemberships: z
      .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    membershipHistoryChanges: z
      .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
      .optional(),
    availabilitiesCreated: z
      .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
      .optional(),
    availabilitiesAccepted: z
      .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
      .optional(),
    organizationsApproved: z
      .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
      .optional(),
    providersApproved: z
      .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
      .optional(),
    sentInvitations: z
      .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
      .optional(),
    reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
    validatedRequirements: z
      .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
      .optional(),
  })
  .strict();

export const UserUncheckedUpdateInputSchema: z.ZodType<Prisma.UserUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    emailVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phoneVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsapp: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsappVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    password: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    image: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    role: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
    serviceProvider: z
      .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
      .optional(),
    bookingsAsClient: z
      .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
      .optional(),
    bookingsCreated: z
      .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
      .optional(),
    bookingsConfirmed: z
      .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
      .optional(),
    communicationPreferences: z
      .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    organizationMemberships: z
      .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
      .optional(),
    membershipHistoryChanges: z
      .lazy(() => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema)
      .optional(),
    availabilitiesCreated: z
      .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
      .optional(),
    availabilitiesAccepted: z
      .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
      .optional(),
    organizationsApproved: z
      .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
      .optional(),
    providersApproved: z
      .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
      .optional(),
    sentInvitations: z
      .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
      .optional(),
    reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
    validatedRequirements: z
      .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
      .optional(),
  })
  .strict();

export const UserCreateManyInputSchema: z.ZodType<Prisma.UserCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    emailVerified: z.coerce.date().optional().nullable(),
    phone: z.string().optional().nullable(),
    phoneVerified: z.coerce.date().optional().nullable(),
    whatsapp: z.string().optional().nullable(),
    whatsappVerified: z.coerce.date().optional().nullable(),
    password: z.string().optional().nullable(),
    image: z.string().optional().nullable(),
    role: z.lazy(() => UserRoleSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const UserUpdateManyMutationInputSchema: z.ZodType<Prisma.UserUpdateManyMutationInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    emailVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phoneVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsapp: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsappVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    password: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    image: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    role: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
  })
  .strict();

export const UserUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UserUncheckedUpdateManyInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    emailVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phoneVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsapp: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    whatsappVerified: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    password: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    image: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    role: z
      .union([
        z.lazy(() => UserRoleSchema),
        z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
  })
  .strict();

export const AccountCreateInputSchema: z.ZodType<Prisma.AccountCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    type: z.string(),
    provider: z.string(),
    providerAccountId: z.string(),
    refresh_token: z.string().optional().nullable(),
    access_token: z.string().optional().nullable(),
    expires_at: z.number().int().optional().nullable(),
    token_type: z.string().optional().nullable(),
    scope: z.string().optional().nullable(),
    id_token: z.string().optional().nullable(),
    session_state: z.string().optional().nullable(),
    user: z.lazy(() => UserCreateNestedOneWithoutAccountsInputSchema),
  })
  .strict();

export const AccountUncheckedCreateInputSchema: z.ZodType<Prisma.AccountUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    userId: z.string(),
    type: z.string(),
    provider: z.string(),
    providerAccountId: z.string(),
    refresh_token: z.string().optional().nullable(),
    access_token: z.string().optional().nullable(),
    expires_at: z.number().int().optional().nullable(),
    token_type: z.string().optional().nullable(),
    scope: z.string().optional().nullable(),
    id_token: z.string().optional().nullable(),
    session_state: z.string().optional().nullable(),
  })
  .strict();

export const AccountUpdateInputSchema: z.ZodType<Prisma.AccountUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    provider: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    providerAccountId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    refresh_token: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    access_token: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    expires_at: z
      .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    token_type: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    scope: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    id_token: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    session_state: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    user: z.lazy(() => UserUpdateOneRequiredWithoutAccountsNestedInputSchema).optional(),
  })
  .strict();

export const AccountUncheckedUpdateInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    userId: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    provider: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    providerAccountId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    refresh_token: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    access_token: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    expires_at: z
      .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    token_type: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    scope: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    id_token: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    session_state: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const AccountCreateManyInputSchema: z.ZodType<Prisma.AccountCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    userId: z.string(),
    type: z.string(),
    provider: z.string(),
    providerAccountId: z.string(),
    refresh_token: z.string().optional().nullable(),
    access_token: z.string().optional().nullable(),
    expires_at: z.number().int().optional().nullable(),
    token_type: z.string().optional().nullable(),
    scope: z.string().optional().nullable(),
    id_token: z.string().optional().nullable(),
    session_state: z.string().optional().nullable(),
  })
  .strict();

export const AccountUpdateManyMutationInputSchema: z.ZodType<Prisma.AccountUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      providerAccountId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refresh_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      access_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      token_type: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      scope: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      id_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      session_state: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const AccountUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      providerAccountId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refresh_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      access_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      token_type: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      scope: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      id_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      session_state: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const ServiceProviderTypeCreateInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirements: z
        .lazy(() => RequirementTypeCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedCreateInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirements: z
        .lazy(() => RequirementTypeUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirements: z
        .lazy(() => RequirementTypeUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedUpdateInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirements: z
        .lazy(() => RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateManyInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateManyMutationInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceProviderCreateInputSchema: z.ZodType<Prisma.ServiceProviderCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    bio: z.string().optional().nullable(),
    image: z.string(),
    languages: z
      .union([
        z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
        z.lazy(() => LanguagesSchema).array(),
      ])
      .optional(),
    website: z.string().optional().nullable(),
    email: z.string().optional(),
    whatsapp: z.string().optional(),
    status: z.lazy(() => ServiceProviderStatusSchema).optional(),
    approvedAt: z.coerce.date().optional().nullable(),
    rejectedAt: z.coerce.date().optional().nullable(),
    rejectionReason: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    averageRating: z.number().optional().nullable(),
    totalReviews: z.number().int().optional(),
    trialStarted: z.coerce.date().optional().nullable(),
    trialEnded: z.coerce.date().optional().nullable(),
    trialStatus: z
      .lazy(() => TrialStatusSchema)
      .optional()
      .nullable(),
    paymentMethodAdded: z.boolean().optional(),
    trialReminderSent: z.boolean().optional(),
    trialConversionDate: z.coerce.date().optional().nullable(),
    selfPaidBookingsEnabled: z.boolean().optional(),
    user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
    serviceProviderType: z.lazy(
      () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
    ),
    approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
    reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
    requirementSubmissions: z
      .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
      .optional(),
    services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
    availabilityConfigs: z
      .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
      .optional(),
    availabilities: z
      .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
      .optional(),
    calendarIntegration: z
      .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
      .optional(),
    providerConnections: z
      .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
      .optional(),
    subscriptions: z
      .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
      .optional(),
  })
  .strict();

export const ServiceProviderUncheckedCreateInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateInputSchema: z.ZodType<Prisma.ServiceProviderUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    bio: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    languages: z
      .union([
        z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
        z.lazy(() => LanguagesSchema).array(),
      ])
      .optional(),
    website: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    whatsapp: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => ServiceProviderStatusSchema),
        z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    approvedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    rejectedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    rejectionReason: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    averageRating: z
      .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    totalReviews: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    trialStarted: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    trialEnded: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    trialStatus: z
      .union([
        z.lazy(() => TrialStatusSchema),
        z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    paymentMethodAdded: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    trialReminderSent: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    trialConversionDate: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    selfPaidBookingsEnabled: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
    serviceProviderType: z
      .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
      .optional(),
    approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
    reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
    requirementSubmissions: z
      .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
      .optional(),
    services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
    availabilityConfigs: z
      .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
      .optional(),
    availabilities: z
      .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
      .optional(),
    calendarIntegration: z
      .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
      .optional(),
    providerConnections: z
      .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
      .optional(),
    subscriptions: z
      .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
      .optional(),
  })
  .strict();

export const ServiceProviderUncheckedUpdateInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateManyInputSchema: z.ZodType<Prisma.ServiceProviderCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderUpdateManyMutationInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationCreateInputSchema: z.ZodType<Prisma.OrganizationCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    phone: z.string().optional().nullable(),
    website: z.string().optional().nullable(),
    logo: z.string().optional().nullable(),
    status: z.lazy(() => OrganizationStatusSchema).optional(),
    approvedAt: z.coerce.date().optional().nullable(),
    rejectedAt: z.coerce.date().optional().nullable(),
    rejectionReason: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
    trialStarted: z.coerce.date().optional().nullable(),
    trialEnded: z.coerce.date().optional().nullable(),
    trialStatus: z
      .lazy(() => TrialStatusSchema)
      .optional()
      .nullable(),
    paymentMethodAdded: z.boolean().optional(),
    trialReminderSent: z.boolean().optional(),
    trialConversionDate: z.coerce.date().optional().nullable(),
    approvedBy: z.lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema).optional(),
    subscriptions: z
      .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
      .optional(),
    invitations: z
      .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
      .optional(),
    memberships: z
      .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
      .optional(),
    providerConnections: z
      .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
      .optional(),
    locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
    availabilities: z
      .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
      .optional(),
  })
  .strict();

export const OrganizationUncheckedCreateInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUpdateInputSchema: z.ZodType<Prisma.OrganizationUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    description: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    website: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    logo: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => OrganizationStatusSchema),
        z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    approvedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    rejectedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    rejectionReason: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    billingModel: z
      .union([
        z.lazy(() => OrganizationBillingModelSchema),
        z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    trialStarted: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    trialEnded: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    trialStatus: z
      .union([
        z.lazy(() => TrialStatusSchema),
        z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    paymentMethodAdded: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    trialReminderSent: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    trialConversionDate: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    approvedBy: z.lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema).optional(),
    subscriptions: z
      .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
      .optional(),
    invitations: z
      .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
      .optional(),
    memberships: z
      .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
      .optional(),
    providerConnections: z
      .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
      .optional(),
    locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
    availabilities: z
      .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
      .optional(),
  })
  .strict();

export const OrganizationUncheckedUpdateInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateManyInputSchema: z.ZodType<Prisma.OrganizationCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    phone: z.string().optional().nullable(),
    website: z.string().optional().nullable(),
    logo: z.string().optional().nullable(),
    status: z.lazy(() => OrganizationStatusSchema).optional(),
    approvedById: z.string().optional().nullable(),
    approvedAt: z.coerce.date().optional().nullable(),
    rejectedAt: z.coerce.date().optional().nullable(),
    rejectionReason: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
    trialStarted: z.coerce.date().optional().nullable(),
    trialEnded: z.coerce.date().optional().nullable(),
    trialStatus: z
      .lazy(() => TrialStatusSchema)
      .optional()
      .nullable(),
    paymentMethodAdded: z.boolean().optional(),
    trialReminderSent: z.boolean().optional(),
    trialConversionDate: z.coerce.date().optional().nullable(),
  })
  .strict();

export const OrganizationUpdateManyMutationInputSchema: z.ZodType<Prisma.OrganizationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationCreateInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutInvitationsInputSchema),
      invitedBy: z.lazy(() => UserCreateNestedOneWithoutSentInvitationsInputSchema),
      membership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutInvitationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      invitedById: z.string(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      membershipId: z.string().optional().nullable(),
    })
    .strict();

export const OrganizationInvitationUpdateInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutInvitationsNestedInputSchema)
        .optional(),
      invitedBy: z
        .lazy(() => UserUpdateOneRequiredWithoutSentInvitationsNestedInputSchema)
        .optional(),
      membership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutInvitationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationCreateManyInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      invitedById: z.string(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      membershipId: z.string().optional().nullable(),
    })
    .strict();

export const OrganizationInvitationUpdateManyMutationInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipCreateInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutMembershipsInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutOrganizationMembershipsInputSchema),
      invitation: z
        .lazy(() => OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema)
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateManyInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipUpdateManyMutationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      membership: z.lazy(() => OrganizationMembershipCreateNestedOneWithoutHistoryInputSchema),
      changedBy: z.lazy(() => UserCreateNestedOneWithoutMembershipHistoryChangesInputSchema),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedCreateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      membershipId: z.string(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changedById: z.string(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      membership: z
        .lazy(() => OrganizationMembershipUpdateOneRequiredWithoutHistoryNestedInputSchema)
        .optional(),
      changedBy: z
        .lazy(() => UserUpdateOneRequiredWithoutMembershipHistoryChangesNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      membershipId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      membershipId: z.string(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changedById: z.string(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateManyMutationInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      membershipId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const LocationCreateInputSchema: z.ZodType<Prisma.LocationCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    googlePlaceId: z.string(),
    formattedAddress: z.string(),
    coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    city: z.string(),
    country: z.string().optional(),
    phone: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    organization: z.lazy(() => OrganizationCreateNestedOneWithoutLocationsInputSchema),
    subscriptions: z.lazy(() => SubscriptionCreateNestedManyWithoutLocationInputSchema).optional(),
    availabilities: z.lazy(() => AvailabilityCreateNestedManyWithoutLocationInputSchema).optional(),
  })
  .strict();

export const LocationUncheckedCreateInputSchema: z.ZodType<Prisma.LocationUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    organizationId: z.string(),
    name: z.string(),
    googlePlaceId: z.string(),
    formattedAddress: z.string(),
    coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    city: z.string(),
    country: z.string().optional(),
    phone: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    subscriptions: z
      .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutLocationInputSchema)
      .optional(),
    availabilities: z
      .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutLocationInputSchema)
      .optional(),
  })
  .strict();

export const LocationUpdateInputSchema: z.ZodType<Prisma.LocationUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    googlePlaceId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    formattedAddress: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]).optional(),
    addressComponents: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    country: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    organization: z
      .lazy(() => OrganizationUpdateOneRequiredWithoutLocationsNestedInputSchema)
      .optional(),
    subscriptions: z.lazy(() => SubscriptionUpdateManyWithoutLocationNestedInputSchema).optional(),
    availabilities: z.lazy(() => AvailabilityUpdateManyWithoutLocationNestedInputSchema).optional(),
  })
  .strict();

export const LocationUncheckedUpdateInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    organizationId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    googlePlaceId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    formattedAddress: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]).optional(),
    addressComponents: z
      .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    country: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    phone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    email: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    subscriptions: z
      .lazy(() => SubscriptionUncheckedUpdateManyWithoutLocationNestedInputSchema)
      .optional(),
    availabilities: z
      .lazy(() => AvailabilityUncheckedUpdateManyWithoutLocationNestedInputSchema)
      .optional(),
  })
  .strict();

export const LocationCreateManyInputSchema: z.ZodType<Prisma.LocationCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    organizationId: z.string(),
    name: z.string(),
    googlePlaceId: z.string(),
    formattedAddress: z.string(),
    coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    city: z.string(),
    country: z.string().optional(),
    phone: z.string().optional().nullable(),
    email: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const LocationUpdateManyMutationInputSchema: z.ZodType<Prisma.LocationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const LocationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutProviderConnectionsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutProviderConnectionsInputSchema
      ),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutProviderConnectionInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedCreateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutProviderConnectionInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutProviderConnectionNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutProviderConnectionNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateManyMutationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const SubscriptionCreateInputSchema: z.ZodType<Prisma.SubscriptionCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    status: z.lazy(() => SubscriptionStatusSchema),
    type: z.lazy(() => SubscriptionTypeSchema).optional(),
    isActive: z.boolean().optional(),
    trialStart: z.coerce.date().optional().nullable(),
    trialEnd: z.coerce.date().optional().nullable(),
    startDate: z.coerce.date(),
    endDate: z.coerce.date().optional().nullable(),
    cancelledAt: z.coerce.date().optional().nullable(),
    cancelReason: z.string().optional().nullable(),
    stripeCustomerId: z.string().optional().nullable(),
    stripeSubscriptionId: z.string().optional().nullable(),
    currentMonthSlots: z.number().int().optional(),
    billingCycleStart: z.coerce.date(),
    billingCycleEnd: z.coerce.date(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    organization: z
      .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
      .optional(),
    location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
    serviceProvider: z
      .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
      .optional(),
    plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
    payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
    usageRecords: z
      .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
      .optional(),
    billedSlots: z
      .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema)
      .optional(),
    defaultForAvailabilities: z
      .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
      .optional(),
  })
  .strict();

export const SubscriptionUncheckedCreateInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUpdateInputSchema: z.ZodType<Prisma.SubscriptionUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => SubscriptionStatusSchema),
        z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    type: z
      .union([
        z.lazy(() => SubscriptionTypeSchema),
        z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    isActive: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    trialStart: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    trialEnd: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    startDate: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    endDate: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    cancelledAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    cancelReason: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    stripeCustomerId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    stripeSubscriptionId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    currentMonthSlots: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    billingCycleStart: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    billingCycleEnd: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    organization: z
      .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
      .optional(),
    location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
    serviceProvider: z
      .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
      .optional(),
    plan: z
      .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
      .optional(),
    payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
    usageRecords: z
      .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
      .optional(),
    billedSlots: z
      .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema)
      .optional(),
    defaultForAvailabilities: z
      .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
      .optional(),
  })
  .strict();

export const SubscriptionUncheckedUpdateInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateManyInputSchema: z.ZodType<Prisma.SubscriptionCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    organizationId: z.string().optional().nullable(),
    locationId: z.string().optional().nullable(),
    serviceProviderId: z.string().optional().nullable(),
    status: z.lazy(() => SubscriptionStatusSchema),
    type: z.lazy(() => SubscriptionTypeSchema).optional(),
    planId: z.string(),
    isActive: z.boolean().optional(),
    trialStart: z.coerce.date().optional().nullable(),
    trialEnd: z.coerce.date().optional().nullable(),
    startDate: z.coerce.date(),
    endDate: z.coerce.date().optional().nullable(),
    cancelledAt: z.coerce.date().optional().nullable(),
    cancelReason: z.string().optional().nullable(),
    stripeCustomerId: z.string().optional().nullable(),
    stripeSubscriptionId: z.string().optional().nullable(),
    currentMonthSlots: z.number().int().optional(),
    billingCycleStart: z.coerce.date(),
    billingCycleEnd: z.coerce.date(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const SubscriptionUpdateManyMutationInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionPlanCreateInputSchema: z.ZodType<Prisma.SubscriptionPlanCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    basePrice: z.number().positive(),
    currency: z.string().optional(),
    interval: z.lazy(() => BillingIntervalSchema),
    includedSlots: z.number().int().optional(),
    tierPricing: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
    features: z
      .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    maxProviders: z.number().int().optional().nullable(),
    maxLocations: z.number().int().optional().nullable(),
    isActive: z.boolean().optional(),
    stripePriceId: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    subscriptions: z.lazy(() => SubscriptionCreateNestedManyWithoutPlanInputSchema).optional(),
  })
  .strict();

export const SubscriptionPlanUncheckedCreateInputSchema: z.ZodType<Prisma.SubscriptionPlanUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      basePrice: z.number().positive(),
      currency: z.string().optional(),
      interval: z.lazy(() => BillingIntervalSchema),
      includedSlots: z.number().int().optional(),
      tierPricing: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z.number().int().optional().nullable(),
      maxLocations: z.number().int().optional().nullable(),
      isActive: z.boolean().optional(),
      stripePriceId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutPlanInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionPlanUpdateInputSchema: z.ZodType<Prisma.SubscriptionPlanUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    description: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    basePrice: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    currency: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    interval: z
      .union([
        z.lazy(() => BillingIntervalSchema),
        z.lazy(() => EnumBillingIntervalFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    includedSlots: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    tierPricing: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]).optional(),
    features: z
      .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    maxProviders: z
      .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    maxLocations: z
      .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    isActive: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    stripePriceId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    subscriptions: z.lazy(() => SubscriptionUpdateManyWithoutPlanNestedInputSchema).optional(),
  })
  .strict();

export const SubscriptionPlanUncheckedUpdateInputSchema: z.ZodType<Prisma.SubscriptionPlanUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      interval: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => EnumBillingIntervalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      includedSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      tierPricing: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      maxLocations: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      stripePriceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutPlanNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionPlanCreateManyInputSchema: z.ZodType<Prisma.SubscriptionPlanCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      basePrice: z.number().positive(),
      currency: z.string().optional(),
      interval: z.lazy(() => BillingIntervalSchema),
      includedSlots: z.number().int().optional(),
      tierPricing: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z.number().int().optional().nullable(),
      maxLocations: z.number().int().optional().nullable(),
      isActive: z.boolean().optional(),
      stripePriceId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SubscriptionPlanUpdateManyMutationInputSchema: z.ZodType<Prisma.SubscriptionPlanUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      interval: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => EnumBillingIntervalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      includedSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      tierPricing: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      maxLocations: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      stripePriceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionPlanUncheckedUpdateManyInputSchema: z.ZodType<Prisma.SubscriptionPlanUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      interval: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => EnumBillingIntervalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      includedSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      tierPricing: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      maxLocations: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      stripePriceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UsageRecordCreateInputSchema: z.ZodType<Prisma.UsageRecordCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    slotId: z.string(),
    slotDate: z.coerce.date(),
    slotStatus: z.lazy(() => SlotStatusSchema),
    billingCycle: z.string(),
    serviceProviderId: z.string(),
    serviceId: z.string(),
    tierUsed: z.number().int(),
    priceCharged: z.number().positive(),
    processed: z.boolean().optional(),
    processedAt: z.coerce.date().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    subscription: z.lazy(() => SubscriptionCreateNestedOneWithoutUsageRecordsInputSchema),
  })
  .strict();

export const UsageRecordUncheckedCreateInputSchema: z.ZodType<Prisma.UsageRecordUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      subscriptionId: z.string(),
      slotId: z.string(),
      slotDate: z.coerce.date(),
      slotStatus: z.lazy(() => SlotStatusSchema),
      billingCycle: z.string(),
      serviceProviderId: z.string(),
      serviceId: z.string(),
      tierUsed: z.number().int(),
      priceCharged: z.number().positive(),
      processed: z.boolean().optional(),
      processedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const UsageRecordUpdateInputSchema: z.ZodType<Prisma.UsageRecordUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    slotId: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    slotDate: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    slotStatus: z
      .union([
        z.lazy(() => SlotStatusSchema),
        z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    billingCycle: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceProviderId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    tierUsed: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    priceCharged: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    processed: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    processedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    subscription: z
      .lazy(() => SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInputSchema)
      .optional(),
  })
  .strict();

export const UsageRecordUncheckedUpdateInputSchema: z.ZodType<Prisma.UsageRecordUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptionId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      tierUsed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      priceCharged: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      processed: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      processedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UsageRecordCreateManyInputSchema: z.ZodType<Prisma.UsageRecordCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    subscriptionId: z.string(),
    slotId: z.string(),
    slotDate: z.coerce.date(),
    slotStatus: z.lazy(() => SlotStatusSchema),
    billingCycle: z.string(),
    serviceProviderId: z.string(),
    serviceId: z.string(),
    tierUsed: z.number().int(),
    priceCharged: z.number().positive(),
    processed: z.boolean().optional(),
    processedAt: z.coerce.date().optional().nullable(),
    createdAt: z.coerce.date().optional(),
  })
  .strict();

export const UsageRecordUpdateManyMutationInputSchema: z.ZodType<Prisma.UsageRecordUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      tierUsed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      priceCharged: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      processed: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      processedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UsageRecordUncheckedUpdateManyInputSchema: z.ZodType<Prisma.UsageRecordUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptionId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      tierUsed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      priceCharged: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      processed: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      processedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const PaymentCreateInputSchema: z.ZodType<Prisma.PaymentCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    amount: z.number().positive(),
    baseAmount: z.number().positive().optional().nullable(),
    usageAmount: z.number().positive().optional().nullable(),
    currency: z.string(),
    status: z.lazy(() => PaymentStatusSchema),
    stripePaymentId: z.string().optional().nullable(),
    stripeInvoiceId: z.string().optional().nullable(),
    paidAt: z.coerce.date().optional().nullable(),
    failureReason: z.string().optional().nullable(),
    billingPeriodStart: z.coerce.date().optional().nullable(),
    billingPeriodEnd: z.coerce.date().optional().nullable(),
    slotsCovered: z.number().int().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    subscription: z.lazy(() => SubscriptionCreateNestedOneWithoutPaymentsInputSchema),
  })
  .strict();

export const PaymentUncheckedCreateInputSchema: z.ZodType<Prisma.PaymentUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    subscriptionId: z.string(),
    amount: z.number().positive(),
    baseAmount: z.number().positive().optional().nullable(),
    usageAmount: z.number().positive().optional().nullable(),
    currency: z.string(),
    status: z.lazy(() => PaymentStatusSchema),
    stripePaymentId: z.string().optional().nullable(),
    stripeInvoiceId: z.string().optional().nullable(),
    paidAt: z.coerce.date().optional().nullable(),
    failureReason: z.string().optional().nullable(),
    billingPeriodStart: z.coerce.date().optional().nullable(),
    billingPeriodEnd: z.coerce.date().optional().nullable(),
    slotsCovered: z.number().int().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const PaymentUpdateInputSchema: z.ZodType<Prisma.PaymentUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    amount: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    baseAmount: z
      .union([z.number().positive(), z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    usageAmount: z
      .union([z.number().positive(), z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    currency: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => PaymentStatusSchema),
        z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    stripePaymentId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    stripeInvoiceId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    paidAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    failureReason: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    billingPeriodStart: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    billingPeriodEnd: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    slotsCovered: z
      .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    subscription: z
      .lazy(() => SubscriptionUpdateOneRequiredWithoutPaymentsNestedInputSchema)
      .optional(),
  })
  .strict();

export const PaymentUncheckedUpdateInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    subscriptionId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    amount: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    baseAmount: z
      .union([z.number().positive(), z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    usageAmount: z
      .union([z.number().positive(), z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    currency: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => PaymentStatusSchema),
        z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    stripePaymentId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    stripeInvoiceId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    paidAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    failureReason: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    billingPeriodStart: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    billingPeriodEnd: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    slotsCovered: z
      .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
  })
  .strict();

export const PaymentCreateManyInputSchema: z.ZodType<Prisma.PaymentCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    subscriptionId: z.string(),
    amount: z.number().positive(),
    baseAmount: z.number().positive().optional().nullable(),
    usageAmount: z.number().positive().optional().nullable(),
    currency: z.string(),
    status: z.lazy(() => PaymentStatusSchema),
    stripePaymentId: z.string().optional().nullable(),
    stripeInvoiceId: z.string().optional().nullable(),
    paidAt: z.coerce.date().optional().nullable(),
    failureReason: z.string().optional().nullable(),
    billingPeriodStart: z.coerce.date().optional().nullable(),
    billingPeriodEnd: z.coerce.date().optional().nullable(),
    slotsCovered: z.number().int().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const PaymentUpdateManyMutationInputSchema: z.ZodType<Prisma.PaymentUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      amount: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      baseAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      usageAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stripePaymentId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeInvoiceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      paidAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      failureReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      slotsCovered: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const PaymentUncheckedUpdateManyInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptionId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      amount: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      baseAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      usageAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stripePaymentId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeInvoiceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      paidAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      failureReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      slotsCovered: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementTypeCreateInputSchema: z.ZodType<Prisma.RequirementTypeCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    isRequired: z.boolean().optional(),
    validationType: z.lazy(() => RequirementValidationTypeSchema),
    validationConfig: z
      .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    displayPriority: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    serviceProviderType: z.lazy(
      () => ServiceProviderTypeCreateNestedOneWithoutRequirementsInputSchema
    ),
    submissions: z
      .lazy(() => RequirementSubmissionCreateNestedManyWithoutRequirementTypeInputSchema)
      .optional(),
  })
  .strict();

export const RequirementTypeUncheckedCreateInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      serviceProviderTypeId: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      submissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutRequirementTypeInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeUpdateInputSchema: z.ZodType<Prisma.RequirementTypeUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    description: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    isRequired: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    validationType: z
      .union([
        z.lazy(() => RequirementValidationTypeSchema),
        z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    validationConfig: z
      .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
      .optional(),
    displayPriority: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceProviderType: z
      .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutRequirementsNestedInputSchema)
      .optional(),
    submissions: z
      .lazy(() => RequirementSubmissionUpdateManyWithoutRequirementTypeNestedInputSchema)
      .optional(),
  })
  .strict();

export const RequirementTypeUncheckedUpdateInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      submissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeCreateManyInputSchema: z.ZodType<Prisma.RequirementTypeCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      serviceProviderTypeId: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementTypeUpdateManyMutationInputSchema: z.ZodType<Prisma.RequirementTypeUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionCreateInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirementType: z.lazy(() => RequirementTypeCreateNestedOneWithoutSubmissionsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutRequirementSubmissionsInputSchema
      ),
      validatedBy: z
        .lazy(() => UserCreateNestedOneWithoutValidatedRequirementsInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      requirementTypeId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      validatedById: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionUpdateInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementType: z
        .lazy(() => RequirementTypeUpdateOneRequiredWithoutSubmissionsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutRequirementSubmissionsNestedInputSchema)
        .optional(),
      validatedBy: z
        .lazy(() => UserUpdateOneWithoutValidatedRequirementsNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionCreateManyInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      requirementTypeId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      validatedById: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionUpdateManyMutationInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceCreateInputSchema: z.ZodType<Prisma.ServiceCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    displayPriority: z.number().int().optional(),
    defaultDuration: z.number().int(),
    defaultPrice: z.number().positive(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    serviceProviderType: z.lazy(() => ServiceProviderTypeCreateNestedOneWithoutServicesInputSchema),
    providers: z.lazy(() => ServiceProviderCreateNestedManyWithoutServicesInputSchema).optional(),
    availabilityConfigs: z
      .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceInputSchema)
      .optional(),
    calculatedSlots: z
      .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceInputSchema)
      .optional(),
  })
  .strict();

export const ServiceUncheckedCreateInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    serviceProviderTypeId: z.string(),
    displayPriority: z.number().int().optional(),
    defaultDuration: z.number().int(),
    defaultPrice: z.number().positive(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    providers: z
      .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServicesInputSchema)
      .optional(),
    availabilityConfigs: z
      .lazy(() => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceInputSchema)
      .optional(),
    calculatedSlots: z
      .lazy(() => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceInputSchema)
      .optional(),
  })
  .strict();

export const ServiceUpdateInputSchema: z.ZodType<Prisma.ServiceUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    description: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    displayPriority: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    defaultDuration: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    defaultPrice: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceProviderType: z
      .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServicesNestedInputSchema)
      .optional(),
    providers: z.lazy(() => ServiceProviderUpdateManyWithoutServicesNestedInputSchema).optional(),
    availabilityConfigs: z
      .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceNestedInputSchema)
      .optional(),
    calculatedSlots: z
      .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceNestedInputSchema)
      .optional(),
  })
  .strict();

export const ServiceUncheckedUpdateInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    description: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    serviceProviderTypeId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    displayPriority: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    defaultDuration: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    defaultPrice: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    providers: z
      .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServicesNestedInputSchema)
      .optional(),
    availabilityConfigs: z
      .lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceNestedInputSchema)
      .optional(),
    calculatedSlots: z
      .lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceNestedInputSchema)
      .optional(),
  })
  .strict();

export const ServiceCreateManyInputSchema: z.ZodType<Prisma.ServiceCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    name: z.string(),
    description: z.string().optional().nullable(),
    serviceProviderTypeId: z.string(),
    displayPriority: z.number().int().optional(),
    defaultDuration: z.number().int(),
    defaultPrice: z.number().positive(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const ServiceUpdateManyMutationInputSchema: z.ZodType<Prisma.ServiceUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      service: z.lazy(() => ServiceCreateNestedOneWithoutAvailabilityConfigsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutAvailabilityConfigsInputSchema
      ),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceConfigInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      serviceProviderId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceConfigInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceConfigNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      serviceProviderId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyMutationInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityCreateInputSchema: z.ZodType<Prisma.AvailabilityCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    startTime: z.coerce.date(),
    endTime: z.coerce.date(),
    isProviderCreated: z.boolean().optional(),
    status: z.lazy(() => AvailabilityStatusSchema).optional(),
    acceptedAt: z.coerce.date().optional().nullable(),
    requiresConfirmation: z.boolean().optional(),
    billingEntity: z
      .lazy(() => BillingEntitySchema)
      .optional()
      .nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
    organization: z
      .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
      .optional(),
    location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
    providerConnection: z
      .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
      .optional(),
    createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
    createdByMembership: z
      .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
      .optional(),
    acceptedBy: z
      .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
      .optional(),
    defaultSubscription: z
      .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
      .optional(),
    availableServices: z
      .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
      .optional(),
    calculatedSlots: z
      .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
      .optional(),
  })
  .strict();

export const AvailabilityUncheckedCreateInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUpdateInputSchema: z.ZodType<Prisma.AvailabilityUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    startTime: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    endTime: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    isProviderCreated: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => AvailabilityStatusSchema),
        z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    acceptedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    requiresConfirmation: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    billingEntity: z
      .union([
        z.lazy(() => BillingEntitySchema),
        z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
      ])
      .optional()
      .nullable(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceProvider: z
      .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
      .optional(),
    organization: z
      .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
      .optional(),
    location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
    providerConnection: z
      .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
      .optional(),
    createdBy: z
      .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
      .optional(),
    createdByMembership: z
      .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
      .optional(),
    acceptedBy: z
      .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
      .optional(),
    defaultSubscription: z
      .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
      .optional(),
    availableServices: z
      .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
      .optional(),
    calculatedSlots: z
      .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
      .optional(),
  })
  .strict();

export const AvailabilityUncheckedUpdateInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateManyInputSchema: z.ZodType<Prisma.AvailabilityCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    serviceProviderId: z.string(),
    organizationId: z.string().optional().nullable(),
    locationId: z.string().optional().nullable(),
    connectionId: z.string().optional().nullable(),
    startTime: z.coerce.date(),
    endTime: z.coerce.date(),
    createdById: z.string(),
    createdByMembershipId: z.string().optional().nullable(),
    isProviderCreated: z.boolean().optional(),
    status: z.lazy(() => AvailabilityStatusSchema).optional(),
    acceptedById: z.string().optional().nullable(),
    acceptedAt: z.coerce.date().optional().nullable(),
    requiresConfirmation: z.boolean().optional(),
    billingEntity: z
      .lazy(() => BillingEntitySchema)
      .optional()
      .nullable(),
    defaultSubscriptionId: z.string().optional().nullable(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const AvailabilityUpdateManyMutationInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availability: z.lazy(() => AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema),
      service: z.lazy(() => ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema),
      serviceConfig: z.lazy(
        () => ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema
      ),
      booking: z.lazy(() => BookingCreateNestedOneWithoutSlotInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      booking: z.lazy(() => BookingUncheckedCreateNestedOneWithoutSlotInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availability: z
        .lazy(() => AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      serviceConfig: z
        .lazy(
          () => ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema
        )
        .optional(),
      booking: z.lazy(() => BookingUpdateOneWithoutSlotNestedInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingUncheckedUpdateOneWithoutSlotNestedInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyMutationInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const BookingCreateInputSchema: z.ZodType<Prisma.BookingCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    isProviderCreated: z.boolean().optional(),
    isGuestBooking: z.boolean().optional(),
    isGuestSelfBooking: z.boolean().optional(),
    confirmedAt: z.coerce.date().optional().nullable(),
    guestName: z.string().optional().nullable(),
    guestEmail: z.string().optional().nullable(),
    guestPhone: z.string().optional().nullable(),
    guestWhatsapp: z.string().optional().nullable(),
    price: z.number().positive(),
    isOnline: z.boolean(),
    isInPerson: z.boolean().optional(),
    status: z.lazy(() => BookingStatusSchema).optional(),
    notes: z.string().optional().nullable(),
    meetLink: z.string().optional().nullable(),
    calendarEventId: z.string().optional().nullable(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    slot: z
      .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
      .optional(),
    createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
    createdByMembership: z
      .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
      .optional(),
    confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
    client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
    communications: z
      .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
      .optional(),
    review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
    meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
  })
  .strict();

export const BookingUncheckedCreateInputSchema: z.ZodType<Prisma.BookingUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    slotId: z.string().optional().nullable(),
    createdById: z.string().optional().nullable(),
    createdByMembershipId: z.string().optional().nullable(),
    isProviderCreated: z.boolean().optional(),
    isGuestBooking: z.boolean().optional(),
    isGuestSelfBooking: z.boolean().optional(),
    confirmedById: z.string().optional().nullable(),
    confirmedAt: z.coerce.date().optional().nullable(),
    clientId: z.string().optional().nullable(),
    guestName: z.string().optional().nullable(),
    guestEmail: z.string().optional().nullable(),
    guestPhone: z.string().optional().nullable(),
    guestWhatsapp: z.string().optional().nullable(),
    price: z.number().positive(),
    isOnline: z.boolean(),
    isInPerson: z.boolean().optional(),
    status: z.lazy(() => BookingStatusSchema).optional(),
    notes: z.string().optional().nullable(),
    meetLink: z.string().optional().nullable(),
    calendarEventId: z.string().optional().nullable(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    communications: z
      .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
      .optional(),
    review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
    meetSession: z
      .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
      .optional(),
  })
  .strict();

export const BookingUpdateInputSchema: z.ZodType<Prisma.BookingUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    isProviderCreated: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    isGuestBooking: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    isGuestSelfBooking: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    confirmedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestName: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestEmail: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestPhone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestWhatsapp: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    price: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    isOnline: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    isInPerson: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => BookingStatusSchema),
        z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    notes: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    meetLink: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    calendarEventId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    version: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    slot: z
      .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
      .optional(),
    createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
    createdByMembership: z
      .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
      .optional(),
    confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
    client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
    communications: z
      .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
      .optional(),
    review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
    meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
  })
  .strict();

export const BookingUncheckedUpdateInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    slotId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdById: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    createdByMembershipId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    isProviderCreated: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    isGuestBooking: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    isGuestSelfBooking: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    confirmedById: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    confirmedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    clientId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestName: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestEmail: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestPhone: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    guestWhatsapp: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    price: z
      .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
      .optional(),
    isOnline: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    isInPerson: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    status: z
      .union([
        z.lazy(() => BookingStatusSchema),
        z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    notes: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    meetLink: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    calendarEventId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    version: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    communications: z
      .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
      .optional(),
    review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
    meetSession: z
      .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
      .optional(),
  })
  .strict();

export const BookingCreateManyInputSchema: z.ZodType<Prisma.BookingCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    slotId: z.string().optional().nullable(),
    createdById: z.string().optional().nullable(),
    createdByMembershipId: z.string().optional().nullable(),
    isProviderCreated: z.boolean().optional(),
    isGuestBooking: z.boolean().optional(),
    isGuestSelfBooking: z.boolean().optional(),
    confirmedById: z.string().optional().nullable(),
    confirmedAt: z.coerce.date().optional().nullable(),
    clientId: z.string().optional().nullable(),
    guestName: z.string().optional().nullable(),
    guestEmail: z.string().optional().nullable(),
    guestPhone: z.string().optional().nullable(),
    guestWhatsapp: z.string().optional().nullable(),
    price: z.number().positive(),
    isOnline: z.boolean(),
    isInPerson: z.boolean().optional(),
    status: z.lazy(() => BookingStatusSchema).optional(),
    notes: z.string().optional().nullable(),
    meetLink: z.string().optional().nullable(),
    calendarEventId: z.string().optional().nullable(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const BookingUpdateManyMutationInputSchema: z.ZodType<Prisma.BookingUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceCreateInputSchema: z.ZodType<Prisma.CommunicationPreferenceCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.string().optional().nullable(),
      whatsappNumber: z.string().optional().nullable(),
      reminderHours: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutCommunicationPreferencesInputSchema),
    })
    .strict();

export const CommunicationPreferenceUncheckedCreateInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.string().optional().nullable(),
      whatsappNumber: z.string().optional().nullable(),
      reminderHours: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CommunicationPreferenceUpdateInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutCommunicationPreferencesNestedInputSchema)
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedUpdateInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceCreateManyInputSchema: z.ZodType<Prisma.CommunicationPreferenceCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.string().optional().nullable(),
      whatsappNumber: z.string().optional().nullable(),
      reminderHours: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CommunicationPreferenceUpdateManyMutationInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationLogCreateInputSchema: z.ZodType<Prisma.CommunicationLogCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    bookingReference: z.string().optional().nullable(),
    serviceProviderName: z.string().optional().nullable(),
    clientName: z.string().optional().nullable(),
    serviceName: z.string().optional().nullable(),
    appointmentTime: z.coerce.date().optional().nullable(),
    type: z.lazy(() => CommunicationTypeSchema),
    channel: z.lazy(() => CommunicationChannelSchema),
    content: z.string(),
    status: z.string(),
    sentAt: z.coerce.date().optional(),
    deliveredAt: z.coerce.date().optional().nullable(),
    booking: z.lazy(() => BookingCreateNestedOneWithoutCommunicationsInputSchema).optional(),
  })
  .strict();

export const CommunicationLogUncheckedCreateInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      bookingId: z.string().optional().nullable(),
      bookingReference: z.string().optional().nullable(),
      serviceProviderName: z.string().optional().nullable(),
      clientName: z.string().optional().nullable(),
      serviceName: z.string().optional().nullable(),
      appointmentTime: z.coerce.date().optional().nullable(),
      type: z.lazy(() => CommunicationTypeSchema),
      channel: z.lazy(() => CommunicationChannelSchema),
      content: z.string(),
      status: z.string(),
      sentAt: z.coerce.date().optional(),
      deliveredAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const CommunicationLogUpdateInputSchema: z.ZodType<Prisma.CommunicationLogUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    bookingReference: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    serviceProviderName: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    clientName: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    serviceName: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    appointmentTime: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    type: z
      .union([
        z.lazy(() => CommunicationTypeSchema),
        z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    channel: z
      .union([
        z.lazy(() => CommunicationChannelSchema),
        z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    content: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    status: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    sentAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    deliveredAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    booking: z.lazy(() => BookingUpdateOneWithoutCommunicationsNestedInputSchema).optional(),
  })
  .strict();

export const CommunicationLogUncheckedUpdateInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      bookingReference: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      content: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      sentAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      deliveredAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const CommunicationLogCreateManyInputSchema: z.ZodType<Prisma.CommunicationLogCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      bookingId: z.string().optional().nullable(),
      bookingReference: z.string().optional().nullable(),
      serviceProviderName: z.string().optional().nullable(),
      clientName: z.string().optional().nullable(),
      serviceName: z.string().optional().nullable(),
      appointmentTime: z.coerce.date().optional().nullable(),
      type: z.lazy(() => CommunicationTypeSchema),
      channel: z.lazy(() => CommunicationChannelSchema),
      content: z.string(),
      status: z.string(),
      sentAt: z.coerce.date().optional(),
      deliveredAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const CommunicationLogUpdateManyMutationInputSchema: z.ZodType<Prisma.CommunicationLogUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingReference: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      content: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      sentAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      deliveredAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const CommunicationLogUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      bookingReference: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      content: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      sentAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      deliveredAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const CalendarIntegrationCreateInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutCalendarIntegrationInputSchema
      ),
      calendarEvents: z
        .lazy(() => CalendarEventCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
      syncOperations: z
        .lazy(() => CalendarSyncOperationCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedCreateInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
      syncOperations: z
        .lazy(
          () => CalendarSyncOperationUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarIntegrationUpdateInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      syncOperations: z
        .lazy(() => CalendarSyncOperationUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedUpdateInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      syncOperations: z
        .lazy(
          () => CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateManyInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarIntegrationUpdateManyMutationInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarEventCreateInputSchema: z.ZodType<Prisma.CalendarEventCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    externalEventId: z.string(),
    externalCalendarId: z.string(),
    etag: z.string().optional().nullable(),
    title: z.string(),
    startTime: z.coerce.date(),
    endTime: z.coerce.date(),
    isAllDay: z.boolean().optional(),
    lastSyncedAt: z.coerce.date().optional(),
    eventType: z.string().optional().nullable(),
    blocksAvailability: z.boolean().optional(),
    syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
    lastModifiedInExternal: z.coerce.date().optional().nullable(),
    hasConflict: z.boolean().optional(),
    conflictDetails: z.string().optional().nullable(),
    conflictResolvedAt: z.coerce.date().optional().nullable(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    calendarIntegration: z.lazy(
      () => CalendarIntegrationCreateNestedOneWithoutCalendarEventsInputSchema
    ),
    blockedSlots: z
      .lazy(
        () => CalculatedAvailabilitySlotCreateNestedManyWithoutBlockedByCalendarEventInputSchema
      )
      .optional(),
  })
  .strict();

export const CalendarEventUncheckedCreateInputSchema: z.ZodType<Prisma.CalendarEventUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      calendarIntegrationId: z.string(),
      externalEventId: z.string(),
      externalCalendarId: z.string(),
      etag: z.string().optional().nullable(),
      title: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isAllDay: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional(),
      eventType: z.string().optional().nullable(),
      blocksAvailability: z.boolean().optional(),
      syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      lastModifiedInExternal: z.coerce.date().optional().nullable(),
      hasConflict: z.boolean().optional(),
      conflictDetails: z.string().optional().nullable(),
      conflictResolvedAt: z.coerce.date().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBlockedByCalendarEventInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarEventUpdateInputSchema: z.ZodType<Prisma.CalendarEventUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    externalEventId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    externalCalendarId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    etag: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    startTime: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    endTime: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    isAllDay: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    lastSyncedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    eventType: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    blocksAvailability: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    syncStatus: z
      .union([
        z.lazy(() => CalendarEventSyncStatusSchema),
        z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    lastModifiedInExternal: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    hasConflict: z
      .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
      .optional(),
    conflictDetails: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    conflictResolvedAt: z
      .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    version: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    calendarIntegration: z
      .lazy(() => CalendarIntegrationUpdateOneRequiredWithoutCalendarEventsNestedInputSchema)
      .optional(),
    blockedSlots: z
      .lazy(
        () => CalculatedAvailabilitySlotUpdateManyWithoutBlockedByCalendarEventNestedInputSchema
      )
      .optional(),
  })
  .strict();

export const CalendarEventUncheckedUpdateInputSchema: z.ZodType<Prisma.CalendarEventUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegrationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      blockedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarEventCreateManyInputSchema: z.ZodType<Prisma.CalendarEventCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    calendarIntegrationId: z.string(),
    externalEventId: z.string(),
    externalCalendarId: z.string(),
    etag: z.string().optional().nullable(),
    title: z.string(),
    startTime: z.coerce.date(),
    endTime: z.coerce.date(),
    isAllDay: z.boolean().optional(),
    lastSyncedAt: z.coerce.date().optional(),
    eventType: z.string().optional().nullable(),
    blocksAvailability: z.boolean().optional(),
    syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
    lastModifiedInExternal: z.coerce.date().optional().nullable(),
    hasConflict: z.boolean().optional(),
    conflictDetails: z.string().optional().nullable(),
    conflictResolvedAt: z.coerce.date().optional().nullable(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const CalendarEventUpdateManyMutationInputSchema: z.ZodType<Prisma.CalendarEventUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CalendarEventUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegrationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationCreateInputSchema: z.ZodType<Prisma.CalendarSyncOperationCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      operationType: z.lazy(() => CalendarSyncOperationTypeSchema),
      sourceSystem: z.lazy(() => CalendarSyncSourceSchema),
      status: z.lazy(() => CalendarSyncStatusSchema).optional(),
      entityType: z.lazy(() => CalendarEntityTypeSchema),
      entityId: z.string().optional().nullable(),
      externalEventId: z.string().optional().nullable(),
      startedAt: z.coerce.date().optional(),
      completedAt: z.coerce.date().optional().nullable(),
      retryCount: z.number().int().optional(),
      maxRetries: z.number().int().optional(),
      errorMessage: z.string().optional().nullable(),
      conflictResolution: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      syncWindowStart: z.coerce.date().optional().nullable(),
      syncWindowEnd: z.coerce.date().optional().nullable(),
      eventsProcessed: z.number().int().optional(),
      eventsSucceeded: z.number().int().optional(),
      eventsFailed: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calendarIntegration: z.lazy(
        () => CalendarIntegrationCreateNestedOneWithoutSyncOperationsInputSchema
      ),
    })
    .strict();

export const CalendarSyncOperationUncheckedCreateInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      calendarIntegrationId: z.string(),
      operationType: z.lazy(() => CalendarSyncOperationTypeSchema),
      sourceSystem: z.lazy(() => CalendarSyncSourceSchema),
      status: z.lazy(() => CalendarSyncStatusSchema).optional(),
      entityType: z.lazy(() => CalendarEntityTypeSchema),
      entityId: z.string().optional().nullable(),
      externalEventId: z.string().optional().nullable(),
      startedAt: z.coerce.date().optional(),
      completedAt: z.coerce.date().optional().nullable(),
      retryCount: z.number().int().optional(),
      maxRetries: z.number().int().optional(),
      errorMessage: z.string().optional().nullable(),
      conflictResolution: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      syncWindowStart: z.coerce.date().optional().nullable(),
      syncWindowEnd: z.coerce.date().optional().nullable(),
      eventsProcessed: z.number().int().optional(),
      eventsSucceeded: z.number().int().optional(),
      eventsFailed: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarSyncOperationUpdateInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedUpdateInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegrationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationCreateManyInputSchema: z.ZodType<Prisma.CalendarSyncOperationCreateManyInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      calendarIntegrationId: z.string(),
      operationType: z.lazy(() => CalendarSyncOperationTypeSchema),
      sourceSystem: z.lazy(() => CalendarSyncSourceSchema),
      status: z.lazy(() => CalendarSyncStatusSchema).optional(),
      entityType: z.lazy(() => CalendarEntityTypeSchema),
      entityId: z.string().optional().nullable(),
      externalEventId: z.string().optional().nullable(),
      startedAt: z.coerce.date().optional(),
      completedAt: z.coerce.date().optional().nullable(),
      retryCount: z.number().int().optional(),
      maxRetries: z.number().int().optional(),
      errorMessage: z.string().optional().nullable(),
      conflictResolution: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      syncWindowStart: z.coerce.date().optional().nullable(),
      syncWindowEnd: z.coerce.date().optional().nullable(),
      eventsProcessed: z.number().int().optional(),
      eventsSucceeded: z.number().int().optional(),
      eventsFailed: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarSyncOperationUpdateManyMutationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedUpdateManyInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegrationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const MeetSessionCreateInputSchema: z.ZodType<Prisma.MeetSessionCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    meetLink: z.string(),
    eventId: z.string(),
    joinCode: z.string().optional().nullable(),
    status: z.lazy(() => MeetSessionStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    booking: z.lazy(() => BookingCreateNestedOneWithoutMeetSessionInputSchema),
  })
  .strict();

export const MeetSessionUncheckedCreateInputSchema: z.ZodType<Prisma.MeetSessionUncheckedCreateInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      bookingId: z.string(),
      meetLink: z.string(),
      eventId: z.string(),
      joinCode: z.string().optional().nullable(),
      status: z.lazy(() => MeetSessionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const MeetSessionUpdateInputSchema: z.ZodType<Prisma.MeetSessionUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    meetLink: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    eventId: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
    joinCode: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => MeetSessionStatusSchema),
        z.lazy(() => EnumMeetSessionStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    booking: z.lazy(() => BookingUpdateOneRequiredWithoutMeetSessionNestedInputSchema).optional(),
  })
  .strict();

export const MeetSessionUncheckedUpdateInputSchema: z.ZodType<Prisma.MeetSessionUncheckedUpdateInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      meetLink: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      eventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      joinCode: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => EnumMeetSessionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const MeetSessionCreateManyInputSchema: z.ZodType<Prisma.MeetSessionCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    bookingId: z.string(),
    meetLink: z.string(),
    eventId: z.string(),
    joinCode: z.string().optional().nullable(),
    status: z.lazy(() => MeetSessionStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const MeetSessionUpdateManyMutationInputSchema: z.ZodType<Prisma.MeetSessionUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      meetLink: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      eventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      joinCode: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => EnumMeetSessionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const MeetSessionUncheckedUpdateManyInputSchema: z.ZodType<Prisma.MeetSessionUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      meetLink: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      eventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      joinCode: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => EnumMeetSessionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ReviewCreateInputSchema: z.ZodType<Prisma.ReviewCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    rating: z.number().int(),
    comment: z.string().optional().nullable(),
    response: z.string().optional().nullable(),
    isPublic: z.boolean().optional(),
    googleReviewId: z.string().optional().nullable(),
    status: z.lazy(() => ReviewStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
    serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutReviewsInputSchema),
    client: z.lazy(() => UserCreateNestedOneWithoutReviewsInputSchema),
    booking: z.lazy(() => BookingCreateNestedOneWithoutReviewInputSchema),
  })
  .strict();

export const ReviewUncheckedCreateInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateInput> = z
  .object({
    id: z.string().cuid().optional(),
    serviceProviderId: z.string(),
    clientId: z.string(),
    bookingId: z.string(),
    rating: z.number().int(),
    comment: z.string().optional().nullable(),
    response: z.string().optional().nullable(),
    isPublic: z.boolean().optional(),
    googleReviewId: z.string().optional().nullable(),
    status: z.lazy(() => ReviewStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const ReviewUpdateInputSchema: z.ZodType<Prisma.ReviewUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    rating: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    comment: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    response: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    isPublic: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    googleReviewId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => ReviewStatusSchema),
        z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceProvider: z
      .lazy(() => ServiceProviderUpdateOneRequiredWithoutReviewsNestedInputSchema)
      .optional(),
    client: z.lazy(() => UserUpdateOneRequiredWithoutReviewsNestedInputSchema).optional(),
    booking: z.lazy(() => BookingUpdateOneRequiredWithoutReviewNestedInputSchema).optional(),
  })
  .strict();

export const ReviewUncheckedUpdateInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateInput> = z
  .object({
    id: z
      .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    serviceProviderId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    clientId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    bookingId: z
      .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
      .optional(),
    rating: z
      .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
      .optional(),
    comment: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    response: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    isPublic: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
    googleReviewId: z
      .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => ReviewStatusSchema),
        z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
      ])
      .optional(),
    createdAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
    updatedAt: z
      .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
      .optional(),
  })
  .strict();

export const ReviewCreateManyInputSchema: z.ZodType<Prisma.ReviewCreateManyInput> = z
  .object({
    id: z.string().cuid().optional(),
    serviceProviderId: z.string(),
    clientId: z.string(),
    bookingId: z.string(),
    rating: z.number().int(),
    comment: z.string().optional().nullable(),
    response: z.string().optional().nullable(),
    isPublic: z.boolean().optional(),
    googleReviewId: z.string().optional().nullable(),
    status: z.lazy(() => ReviewStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const ReviewUpdateManyMutationInputSchema: z.ZodType<Prisma.ReviewUpdateManyMutationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ReviewUncheckedUpdateManyInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateManyInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      clientId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const StringFilterSchema: z.ZodType<Prisma.StringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    not: z.union([z.string(), z.lazy(() => NestedStringFilterSchema)]).optional(),
  })
  .strict();

export const StringNullableFilterSchema: z.ZodType<Prisma.StringNullableFilter> = z
  .object({
    equals: z.string().optional().nullable(),
    in: z.string().array().optional().nullable(),
    notIn: z.string().array().optional().nullable(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const DateTimeNullableFilterSchema: z.ZodType<Prisma.DateTimeNullableFilter> = z
  .object({
    equals: z.coerce.date().optional().nullable(),
    in: z.coerce.date().array().optional().nullable(),
    notIn: z.coerce.date().array().optional().nullable(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z
      .union([z.coerce.date(), z.lazy(() => NestedDateTimeNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const EnumUserRoleFilterSchema: z.ZodType<Prisma.EnumUserRoleFilter> = z
  .object({
    equals: z.lazy(() => UserRoleSchema).optional(),
    in: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => UserRoleSchema), z.lazy(() => NestedEnumUserRoleFilterSchema)])
      .optional(),
  })
  .strict();

export const DateTimeFilterSchema: z.ZodType<Prisma.DateTimeFilter> = z
  .object({
    equals: z.coerce.date().optional(),
    in: z.coerce.date().array().optional(),
    notIn: z.coerce.date().array().optional(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z.union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)]).optional(),
  })
  .strict();

export const AccountListRelationFilterSchema: z.ZodType<Prisma.AccountListRelationFilter> = z
  .object({
    every: z.lazy(() => AccountWhereInputSchema).optional(),
    some: z.lazy(() => AccountWhereInputSchema).optional(),
    none: z.lazy(() => AccountWhereInputSchema).optional(),
  })
  .strict();

export const ServiceProviderNullableRelationFilterSchema: z.ZodType<Prisma.ServiceProviderNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => ServiceProviderWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => ServiceProviderWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const BookingListRelationFilterSchema: z.ZodType<Prisma.BookingListRelationFilter> = z
  .object({
    every: z.lazy(() => BookingWhereInputSchema).optional(),
    some: z.lazy(() => BookingWhereInputSchema).optional(),
    none: z.lazy(() => BookingWhereInputSchema).optional(),
  })
  .strict();

export const CommunicationPreferenceListRelationFilterSchema: z.ZodType<Prisma.CommunicationPreferenceListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CommunicationPreferenceWhereInputSchema).optional(),
      some: z.lazy(() => CommunicationPreferenceWhereInputSchema).optional(),
      none: z.lazy(() => CommunicationPreferenceWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipListRelationFilterSchema: z.ZodType<Prisma.OrganizationMembershipListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      some: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      none: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryListRelationFilterSchema: z.ZodType<Prisma.OrganizationMembershipHistoryListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).optional(),
      some: z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).optional(),
      none: z.lazy(() => OrganizationMembershipHistoryWhereInputSchema).optional(),
    })
    .strict();

export const AvailabilityListRelationFilterSchema: z.ZodType<Prisma.AvailabilityListRelationFilter> =
  z
    .object({
      every: z.lazy(() => AvailabilityWhereInputSchema).optional(),
      some: z.lazy(() => AvailabilityWhereInputSchema).optional(),
      none: z.lazy(() => AvailabilityWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationListRelationFilterSchema: z.ZodType<Prisma.OrganizationListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrganizationWhereInputSchema).optional(),
      some: z.lazy(() => OrganizationWhereInputSchema).optional(),
      none: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderListRelationFilterSchema: z.ZodType<Prisma.ServiceProviderListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      some: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      none: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationInvitationListRelationFilterSchema: z.ZodType<Prisma.OrganizationInvitationListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrganizationInvitationWhereInputSchema).optional(),
      some: z.lazy(() => OrganizationInvitationWhereInputSchema).optional(),
      none: z.lazy(() => OrganizationInvitationWhereInputSchema).optional(),
    })
    .strict();

export const ReviewListRelationFilterSchema: z.ZodType<Prisma.ReviewListRelationFilter> = z
  .object({
    every: z.lazy(() => ReviewWhereInputSchema).optional(),
    some: z.lazy(() => ReviewWhereInputSchema).optional(),
    none: z.lazy(() => ReviewWhereInputSchema).optional(),
  })
  .strict();

export const RequirementSubmissionListRelationFilterSchema: z.ZodType<Prisma.RequirementSubmissionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => RequirementSubmissionWhereInputSchema).optional(),
      some: z.lazy(() => RequirementSubmissionWhereInputSchema).optional(),
      none: z.lazy(() => RequirementSubmissionWhereInputSchema).optional(),
    })
    .strict();

export const SortOrderInputSchema: z.ZodType<Prisma.SortOrderInput> = z
  .object({
    sort: z.lazy(() => SortOrderSchema),
    nulls: z.lazy(() => NullsOrderSchema).optional(),
  })
  .strict();

export const AccountOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AccountOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BookingOrderByRelationAggregateInputSchema: z.ZodType<Prisma.BookingOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CommunicationPreferenceOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMembershipOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AvailabilityOrderByRelationAggregateInputSchema: z.ZodType<Prisma.AvailabilityOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrganizationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ServiceProviderOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationInvitationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrganizationInvitationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ReviewOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ReviewOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementSubmissionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.RequirementSubmissionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UserCountOrderByAggregateInputSchema: z.ZodType<Prisma.UserCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      emailVerified: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      phoneVerified: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      whatsappVerified: z.lazy(() => SortOrderSchema).optional(),
      password: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UserMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UserMaxOrderByAggregateInput> = z
  .object({
    id: z.lazy(() => SortOrderSchema).optional(),
    name: z.lazy(() => SortOrderSchema).optional(),
    email: z.lazy(() => SortOrderSchema).optional(),
    emailVerified: z.lazy(() => SortOrderSchema).optional(),
    phone: z.lazy(() => SortOrderSchema).optional(),
    phoneVerified: z.lazy(() => SortOrderSchema).optional(),
    whatsapp: z.lazy(() => SortOrderSchema).optional(),
    whatsappVerified: z.lazy(() => SortOrderSchema).optional(),
    password: z.lazy(() => SortOrderSchema).optional(),
    image: z.lazy(() => SortOrderSchema).optional(),
    role: z.lazy(() => SortOrderSchema).optional(),
    createdAt: z.lazy(() => SortOrderSchema).optional(),
    updatedAt: z.lazy(() => SortOrderSchema).optional(),
  })
  .strict();

export const UserMinOrderByAggregateInputSchema: z.ZodType<Prisma.UserMinOrderByAggregateInput> = z
  .object({
    id: z.lazy(() => SortOrderSchema).optional(),
    name: z.lazy(() => SortOrderSchema).optional(),
    email: z.lazy(() => SortOrderSchema).optional(),
    emailVerified: z.lazy(() => SortOrderSchema).optional(),
    phone: z.lazy(() => SortOrderSchema).optional(),
    phoneVerified: z.lazy(() => SortOrderSchema).optional(),
    whatsapp: z.lazy(() => SortOrderSchema).optional(),
    whatsappVerified: z.lazy(() => SortOrderSchema).optional(),
    password: z.lazy(() => SortOrderSchema).optional(),
    image: z.lazy(() => SortOrderSchema).optional(),
    role: z.lazy(() => SortOrderSchema).optional(),
    createdAt: z.lazy(() => SortOrderSchema).optional(),
    updatedAt: z.lazy(() => SortOrderSchema).optional(),
  })
  .strict();

export const StringWithAggregatesFilterSchema: z.ZodType<Prisma.StringWithAggregatesFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    mode: z.lazy(() => QueryModeSchema).optional(),
    not: z.union([z.string(), z.lazy(() => NestedStringWithAggregatesFilterSchema)]).optional(),
    _count: z.lazy(() => NestedIntFilterSchema).optional(),
    _min: z.lazy(() => NestedStringFilterSchema).optional(),
    _max: z.lazy(() => NestedStringFilterSchema).optional(),
  })
  .strict();

export const StringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.StringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      mode: z.lazy(() => QueryModeSchema).optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional(),
    })
    .strict();

export const DateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([z.coerce.date(), z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
    })
    .strict();

export const EnumUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.EnumUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
    })
    .strict();

export const DateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.DateTimeWithAggregatesFilter> = z
  .object({
    equals: z.coerce.date().optional(),
    in: z.coerce.date().array().optional(),
    notIn: z.coerce.date().array().optional(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z
      .union([z.coerce.date(), z.lazy(() => NestedDateTimeWithAggregatesFilterSchema)])
      .optional(),
    _count: z.lazy(() => NestedIntFilterSchema).optional(),
    _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
    _max: z.lazy(() => NestedDateTimeFilterSchema).optional(),
  })
  .strict();

export const IntNullableFilterSchema: z.ZodType<Prisma.IntNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const UserRelationFilterSchema: z.ZodType<Prisma.UserRelationFilter> = z
  .object({
    is: z.lazy(() => UserWhereInputSchema).optional(),
    isNot: z.lazy(() => UserWhereInputSchema).optional(),
  })
  .strict();

export const AccountProviderProviderAccountIdCompoundUniqueInputSchema: z.ZodType<Prisma.AccountProviderProviderAccountIdCompoundUniqueInput> =
  z
    .object({
      provider: z.string(),
      providerAccountId: z.string(),
    })
    .strict();

export const AccountCountOrderByAggregateInputSchema: z.ZodType<Prisma.AccountCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z.lazy(() => SortOrderSchema).optional(),
      access_token: z.lazy(() => SortOrderSchema).optional(),
      expires_at: z.lazy(() => SortOrderSchema).optional(),
      token_type: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      id_token: z.lazy(() => SortOrderSchema).optional(),
      session_state: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountAvgOrderByAggregateInputSchema: z.ZodType<Prisma.AccountAvgOrderByAggregateInput> =
  z
    .object({
      expires_at: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z.lazy(() => SortOrderSchema).optional(),
      access_token: z.lazy(() => SortOrderSchema).optional(),
      expires_at: z.lazy(() => SortOrderSchema).optional(),
      token_type: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      id_token: z.lazy(() => SortOrderSchema).optional(),
      session_state: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountMinOrderByAggregateInputSchema: z.ZodType<Prisma.AccountMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      providerAccountId: z.lazy(() => SortOrderSchema).optional(),
      refresh_token: z.lazy(() => SortOrderSchema).optional(),
      access_token: z.lazy(() => SortOrderSchema).optional(),
      expires_at: z.lazy(() => SortOrderSchema).optional(),
      token_type: z.lazy(() => SortOrderSchema).optional(),
      scope: z.lazy(() => SortOrderSchema).optional(),
      id_token: z.lazy(() => SortOrderSchema).optional(),
      session_state: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AccountSumOrderByAggregateInputSchema: z.ZodType<Prisma.AccountSumOrderByAggregateInput> =
  z
    .object({
      expires_at: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const IntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.IntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional(),
    })
    .strict();

export const RequirementTypeListRelationFilterSchema: z.ZodType<Prisma.RequirementTypeListRelationFilter> =
  z
    .object({
      every: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
      some: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
      none: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
    })
    .strict();

export const ServiceListRelationFilterSchema: z.ZodType<Prisma.ServiceListRelationFilter> = z
  .object({
    every: z.lazy(() => ServiceWhereInputSchema).optional(),
    some: z.lazy(() => ServiceWhereInputSchema).optional(),
    none: z.lazy(() => ServiceWhereInputSchema).optional(),
  })
  .strict();

export const RequirementTypeOrderByRelationAggregateInputSchema: z.ZodType<Prisma.RequirementTypeOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ServiceOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeCountOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderTypeCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderTypeMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeMinOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderTypeMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumLanguagesNullableListFilterSchema: z.ZodType<Prisma.EnumLanguagesNullableListFilter> =
  z
    .object({
      equals: z
        .lazy(() => LanguagesSchema)
        .array()
        .optional()
        .nullable(),
      has: z
        .lazy(() => LanguagesSchema)
        .optional()
        .nullable(),
      hasEvery: z
        .lazy(() => LanguagesSchema)
        .array()
        .optional(),
      hasSome: z
        .lazy(() => LanguagesSchema)
        .array()
        .optional(),
      isEmpty: z.boolean().optional(),
    })
    .strict();

export const EnumServiceProviderStatusFilterSchema: z.ZodType<Prisma.EnumServiceProviderStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ServiceProviderStatusSchema).optional(),
      in: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => NestedEnumServiceProviderStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const FloatNullableFilterSchema: z.ZodType<Prisma.FloatNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedFloatNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const IntFilterSchema: z.ZodType<Prisma.IntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional(),
  })
  .strict();

export const EnumTrialStatusNullableFilterSchema: z.ZodType<Prisma.EnumTrialStatusNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NestedEnumTrialStatusNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const BoolFilterSchema: z.ZodType<Prisma.BoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z.union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)]).optional(),
  })
  .strict();

export const ServiceProviderTypeRelationFilterSchema: z.ZodType<Prisma.ServiceProviderTypeRelationFilter> =
  z
    .object({
      is: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
      isNot: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
    })
    .strict();

export const UserNullableRelationFilterSchema: z.ZodType<Prisma.UserNullableRelationFilter> = z
  .object({
    is: z
      .lazy(() => UserWhereInputSchema)
      .optional()
      .nullable(),
    isNot: z
      .lazy(() => UserWhereInputSchema)
      .optional()
      .nullable(),
  })
  .strict();

export const ServiceAvailabilityConfigListRelationFilterSchema: z.ZodType<Prisma.ServiceAvailabilityConfigListRelationFilter> =
  z
    .object({
      every: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
      some: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
      none: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
    })
    .strict();

export const CalendarIntegrationNullableRelationFilterSchema: z.ZodType<Prisma.CalendarIntegrationNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CalendarIntegrationWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CalendarIntegrationWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationProviderConnectionListRelationFilterSchema: z.ZodType<Prisma.OrganizationProviderConnectionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => OrganizationProviderConnectionWhereInputSchema).optional(),
      some: z.lazy(() => OrganizationProviderConnectionWhereInputSchema).optional(),
      none: z.lazy(() => OrganizationProviderConnectionWhereInputSchema).optional(),
    })
    .strict();

export const SubscriptionListRelationFilterSchema: z.ZodType<Prisma.SubscriptionListRelationFilter> =
  z
    .object({
      every: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      some: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      none: z.lazy(() => SubscriptionWhereInputSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigOrderByRelationAggregateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionOrderByRelationAggregateInputSchema: z.ZodType<Prisma.SubscriptionOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderCountOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      bio: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      languages: z.lazy(() => SortOrderSchema).optional(),
      website: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectionReason: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      averageRating: z.lazy(() => SortOrderSchema).optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z.lazy(() => SortOrderSchema).optional(),
      trialEnded: z.lazy(() => SortOrderSchema).optional(),
      trialStatus: z.lazy(() => SortOrderSchema).optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z.lazy(() => SortOrderSchema).optional(),
      selfPaidBookingsEnabled: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderAvgOrderByAggregateInput> =
  z
    .object({
      averageRating: z.lazy(() => SortOrderSchema).optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      bio: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      website: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectionReason: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      averageRating: z.lazy(() => SortOrderSchema).optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z.lazy(() => SortOrderSchema).optional(),
      trialEnded: z.lazy(() => SortOrderSchema).optional(),
      trialStatus: z.lazy(() => SortOrderSchema).optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z.lazy(() => SortOrderSchema).optional(),
      selfPaidBookingsEnabled: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderMinOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      bio: z.lazy(() => SortOrderSchema).optional(),
      image: z.lazy(() => SortOrderSchema).optional(),
      website: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectionReason: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      averageRating: z.lazy(() => SortOrderSchema).optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z.lazy(() => SortOrderSchema).optional(),
      trialEnded: z.lazy(() => SortOrderSchema).optional(),
      trialStatus: z.lazy(() => SortOrderSchema).optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z.lazy(() => SortOrderSchema).optional(),
      selfPaidBookingsEnabled: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceProviderSumOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceProviderSumOrderByAggregateInput> =
  z
    .object({
      averageRating: z.lazy(() => SortOrderSchema).optional(),
      totalReviews: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumServiceProviderStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumServiceProviderStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ServiceProviderStatusSchema).optional(),
      in: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => NestedEnumServiceProviderStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumServiceProviderStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumServiceProviderStatusFilterSchema).optional(),
    })
    .strict();

export const FloatNullableWithAggregatesFilterSchema: z.ZodType<Prisma.FloatNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedFloatNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
    })
    .strict();

export const IntWithAggregatesFilterSchema: z.ZodType<Prisma.IntWithAggregatesFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)]).optional(),
    _count: z.lazy(() => NestedIntFilterSchema).optional(),
    _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
    _sum: z.lazy(() => NestedIntFilterSchema).optional(),
    _min: z.lazy(() => NestedIntFilterSchema).optional(),
    _max: z.lazy(() => NestedIntFilterSchema).optional(),
  })
  .strict();

export const EnumTrialStatusNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumTrialStatusNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NestedEnumTrialStatusNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumTrialStatusNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumTrialStatusNullableFilterSchema).optional(),
    })
    .strict();

export const BoolWithAggregatesFilterSchema: z.ZodType<Prisma.BoolWithAggregatesFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z.union([z.boolean(), z.lazy(() => NestedBoolWithAggregatesFilterSchema)]).optional(),
    _count: z.lazy(() => NestedIntFilterSchema).optional(),
    _min: z.lazy(() => NestedBoolFilterSchema).optional(),
    _max: z.lazy(() => NestedBoolFilterSchema).optional(),
  })
  .strict();

export const EnumOrganizationStatusFilterSchema: z.ZodType<Prisma.EnumOrganizationStatusFilter> = z
  .object({
    equals: z.lazy(() => OrganizationStatusSchema).optional(),
    in: z
      .lazy(() => OrganizationStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => OrganizationStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => OrganizationStatusSchema),
        z.lazy(() => NestedEnumOrganizationStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumOrganizationBillingModelFilterSchema: z.ZodType<Prisma.EnumOrganizationBillingModelFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationBillingModelSchema).optional(),
      in: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => NestedEnumOrganizationBillingModelFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const LocationListRelationFilterSchema: z.ZodType<Prisma.LocationListRelationFilter> = z
  .object({
    every: z.lazy(() => LocationWhereInputSchema).optional(),
    some: z.lazy(() => LocationWhereInputSchema).optional(),
    none: z.lazy(() => LocationWhereInputSchema).optional(),
  })
  .strict();

export const LocationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.LocationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      website: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectionReason: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      billingModel: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z.lazy(() => SortOrderSchema).optional(),
      trialEnded: z.lazy(() => SortOrderSchema).optional(),
      trialStatus: z.lazy(() => SortOrderSchema).optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      website: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectionReason: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      billingModel: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z.lazy(() => SortOrderSchema).optional(),
      trialEnded: z.lazy(() => SortOrderSchema).optional(),
      trialStatus: z.lazy(() => SortOrderSchema).optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      website: z.lazy(() => SortOrderSchema).optional(),
      logo: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      approvedById: z.lazy(() => SortOrderSchema).optional(),
      approvedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectedAt: z.lazy(() => SortOrderSchema).optional(),
      rejectionReason: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      billingModel: z.lazy(() => SortOrderSchema).optional(),
      trialStarted: z.lazy(() => SortOrderSchema).optional(),
      trialEnded: z.lazy(() => SortOrderSchema).optional(),
      trialStatus: z.lazy(() => SortOrderSchema).optional(),
      paymentMethodAdded: z.lazy(() => SortOrderSchema).optional(),
      trialReminderSent: z.lazy(() => SortOrderSchema).optional(),
      trialConversionDate: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumOrganizationStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumOrganizationStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationStatusSchema).optional(),
      in: z
        .lazy(() => OrganizationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => NestedEnumOrganizationStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationStatusFilterSchema).optional(),
    })
    .strict();

export const EnumOrganizationBillingModelWithAggregatesFilterSchema: z.ZodType<Prisma.EnumOrganizationBillingModelWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationBillingModelSchema).optional(),
      in: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => NestedEnumOrganizationBillingModelWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationBillingModelFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationBillingModelFilterSchema).optional(),
    })
    .strict();

export const EnumOrganizationRoleFilterSchema: z.ZodType<Prisma.EnumOrganizationRoleFilter> = z
  .object({
    equals: z.lazy(() => OrganizationRoleSchema).optional(),
    in: z
      .lazy(() => OrganizationRoleSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => OrganizationRoleSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => OrganizationRoleSchema),
        z.lazy(() => NestedEnumOrganizationRoleFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumOrganizationPermissionNullableListFilterSchema: z.ZodType<Prisma.EnumOrganizationPermissionNullableListFilter> =
  z
    .object({
      equals: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional()
        .nullable(),
      has: z
        .lazy(() => OrganizationPermissionSchema)
        .optional()
        .nullable(),
      hasEvery: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional(),
      hasSome: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional(),
      isEmpty: z.boolean().optional(),
    })
    .strict();

export const EnumInvitationStatusFilterSchema: z.ZodType<Prisma.EnumInvitationStatusFilter> = z
  .object({
    equals: z.lazy(() => InvitationStatusSchema).optional(),
    in: z
      .lazy(() => InvitationStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => InvitationStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => InvitationStatusSchema),
        z.lazy(() => NestedEnumInvitationStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const OrganizationRelationFilterSchema: z.ZodType<Prisma.OrganizationRelationFilter> = z
  .object({
    is: z.lazy(() => OrganizationWhereInputSchema).optional(),
    isNot: z.lazy(() => OrganizationWhereInputSchema).optional(),
  })
  .strict();

export const OrganizationMembershipNullableRelationFilterSchema: z.ZodType<Prisma.OrganizationMembershipNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => OrganizationMembershipWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => OrganizationMembershipWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationInvitationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      permissions: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      invitedById: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationInvitationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationInvitationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      invitedById: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationInvitationMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationInvitationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      token: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      invitedById: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumOrganizationRoleWithAggregatesFilterSchema: z.ZodType<Prisma.EnumOrganizationRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationRoleSchema).optional(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationRoleFilterSchema).optional(),
    })
    .strict();

export const EnumInvitationStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumInvitationStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => InvitationStatusSchema).optional(),
      in: z
        .lazy(() => InvitationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvitationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => NestedEnumInvitationStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumInvitationStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumInvitationStatusFilterSchema).optional(),
    })
    .strict();

export const EnumMembershipStatusFilterSchema: z.ZodType<Prisma.EnumMembershipStatusFilter> = z
  .object({
    equals: z.lazy(() => MembershipStatusSchema).optional(),
    in: z
      .lazy(() => MembershipStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => MembershipStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => MembershipStatusSchema),
        z.lazy(() => NestedEnumMembershipStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const OrganizationInvitationNullableRelationFilterSchema: z.ZodType<Prisma.OrganizationInvitationNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => OrganizationInvitationWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => OrganizationInvitationWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipOrganizationIdUserIdCompoundUniqueInputSchema: z.ZodType<Prisma.OrganizationMembershipOrganizationIdUserIdCompoundUniqueInput> =
  z
    .object({
      organizationId: z.string(),
      userId: z.string(),
    })
    .strict();

export const OrganizationMembershipCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      permissions: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMembershipMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMembershipMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      role: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumMembershipStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumMembershipStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipStatusSchema).optional(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMembershipStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMembershipStatusFilterSchema).optional(),
    })
    .strict();

export const EnumMembershipChangeTypeFilterSchema: z.ZodType<Prisma.EnumMembershipChangeTypeFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipChangeTypeSchema).optional(),
      in: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => NestedEnumMembershipChangeTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const EnumOrganizationRoleNullableFilterSchema: z.ZodType<Prisma.EnumOrganizationRoleNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const EnumMembershipStatusNullableFilterSchema: z.ZodType<Prisma.EnumMembershipStatusNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipRelationFilterSchema: z.ZodType<Prisma.OrganizationMembershipRelationFilter> =
  z
    .object({
      is: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      isNot: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
      changeType: z.lazy(() => SortOrderSchema).optional(),
      oldRole: z.lazy(() => SortOrderSchema).optional(),
      newRole: z.lazy(() => SortOrderSchema).optional(),
      oldPermissions: z.lazy(() => SortOrderSchema).optional(),
      newPermissions: z.lazy(() => SortOrderSchema).optional(),
      oldStatus: z.lazy(() => SortOrderSchema).optional(),
      newStatus: z.lazy(() => SortOrderSchema).optional(),
      changedById: z.lazy(() => SortOrderSchema).optional(),
      changeReason: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
      changeType: z.lazy(() => SortOrderSchema).optional(),
      oldRole: z.lazy(() => SortOrderSchema).optional(),
      newRole: z.lazy(() => SortOrderSchema).optional(),
      oldStatus: z.lazy(() => SortOrderSchema).optional(),
      newStatus: z.lazy(() => SortOrderSchema).optional(),
      changedById: z.lazy(() => SortOrderSchema).optional(),
      changeReason: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      membershipId: z.lazy(() => SortOrderSchema).optional(),
      changeType: z.lazy(() => SortOrderSchema).optional(),
      oldRole: z.lazy(() => SortOrderSchema).optional(),
      newRole: z.lazy(() => SortOrderSchema).optional(),
      oldStatus: z.lazy(() => SortOrderSchema).optional(),
      newStatus: z.lazy(() => SortOrderSchema).optional(),
      changedById: z.lazy(() => SortOrderSchema).optional(),
      changeReason: z.lazy(() => SortOrderSchema).optional(),
      ipAddress: z.lazy(() => SortOrderSchema).optional(),
      userAgent: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumMembershipChangeTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumMembershipChangeTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipChangeTypeSchema).optional(),
      in: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => NestedEnumMembershipChangeTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMembershipChangeTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMembershipChangeTypeFilterSchema).optional(),
    })
    .strict();

export const EnumOrganizationRoleNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumOrganizationRoleNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationRoleNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationRoleNullableFilterSchema).optional(),
    })
    .strict();

export const EnumMembershipStatusNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumMembershipStatusNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMembershipStatusNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMembershipStatusNullableFilterSchema).optional(),
    })
    .strict();

export const JsonFilterSchema: z.ZodType<Prisma.JsonFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional(),
  })
  .strict();

export const LocationCountOrderByAggregateInputSchema: z.ZodType<Prisma.LocationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      googlePlaceId: z.lazy(() => SortOrderSchema).optional(),
      formattedAddress: z.lazy(() => SortOrderSchema).optional(),
      coordinates: z.lazy(() => SortOrderSchema).optional(),
      addressComponents: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const LocationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.LocationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      googlePlaceId: z.lazy(() => SortOrderSchema).optional(),
      formattedAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const LocationMinOrderByAggregateInputSchema: z.ZodType<Prisma.LocationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      googlePlaceId: z.lazy(() => SortOrderSchema).optional(),
      formattedAddress: z.lazy(() => SortOrderSchema).optional(),
      city: z.lazy(() => SortOrderSchema).optional(),
      country: z.lazy(() => SortOrderSchema).optional(),
      phone: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const JsonWithAggregatesFilterSchema: z.ZodType<Prisma.JsonWithAggregatesFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional(),
    _count: z.lazy(() => NestedIntFilterSchema).optional(),
    _min: z.lazy(() => NestedJsonFilterSchema).optional(),
    _max: z.lazy(() => NestedJsonFilterSchema).optional(),
  })
  .strict();

export const EnumConnectionStatusFilterSchema: z.ZodType<Prisma.EnumConnectionStatusFilter> = z
  .object({
    equals: z.lazy(() => ConnectionStatusSchema).optional(),
    in: z
      .lazy(() => ConnectionStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => ConnectionStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => ConnectionStatusSchema),
        z.lazy(() => NestedEnumConnectionStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumBillingEntityFilterSchema: z.ZodType<Prisma.EnumBillingEntityFilter> = z
  .object({
    equals: z.lazy(() => BillingEntitySchema).optional(),
    in: z
      .lazy(() => BillingEntitySchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => BillingEntitySchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => BillingEntitySchema), z.lazy(() => NestedEnumBillingEntityFilterSchema)])
      .optional(),
  })
  .strict();

export const ServiceProviderRelationFilterSchema: z.ZodType<Prisma.ServiceProviderRelationFilter> =
  z
    .object({
      is: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      isNot: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionOrganizationIdServiceProviderIdCompoundUniqueInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionOrganizationIdServiceProviderIdCompoundUniqueInput> =
  z
    .object({
      organizationId: z.string(),
      serviceProviderId: z.string(),
    })
    .strict();

export const OrganizationProviderConnectionCountOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      defaultBilledBy: z.lazy(() => SortOrderSchema).optional(),
      requestedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      defaultBilledBy: z.lazy(() => SortOrderSchema).optional(),
      requestedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionMinOrderByAggregateInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      defaultBilledBy: z.lazy(() => SortOrderSchema).optional(),
      requestedAt: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumConnectionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumConnectionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ConnectionStatusSchema).optional(),
      in: z
        .lazy(() => ConnectionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConnectionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => NestedEnumConnectionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumConnectionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumConnectionStatusFilterSchema).optional(),
    })
    .strict();

export const EnumBillingEntityWithAggregatesFilterSchema: z.ZodType<Prisma.EnumBillingEntityWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => BillingEntitySchema).optional(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBillingEntityFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBillingEntityFilterSchema).optional(),
    })
    .strict();

export const EnumSubscriptionStatusFilterSchema: z.ZodType<Prisma.EnumSubscriptionStatusFilter> = z
  .object({
    equals: z.lazy(() => SubscriptionStatusSchema).optional(),
    in: z
      .lazy(() => SubscriptionStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => SubscriptionStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => SubscriptionStatusSchema),
        z.lazy(() => NestedEnumSubscriptionStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumSubscriptionTypeFilterSchema: z.ZodType<Prisma.EnumSubscriptionTypeFilter> = z
  .object({
    equals: z.lazy(() => SubscriptionTypeSchema).optional(),
    in: z
      .lazy(() => SubscriptionTypeSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => SubscriptionTypeSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => SubscriptionTypeSchema),
        z.lazy(() => NestedEnumSubscriptionTypeFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const OrganizationNullableRelationFilterSchema: z.ZodType<Prisma.OrganizationNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => OrganizationWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => OrganizationWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const LocationNullableRelationFilterSchema: z.ZodType<Prisma.LocationNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => LocationWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => LocationWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const SubscriptionPlanRelationFilterSchema: z.ZodType<Prisma.SubscriptionPlanRelationFilter> =
  z
    .object({
      is: z.lazy(() => SubscriptionPlanWhereInputSchema).optional(),
      isNot: z.lazy(() => SubscriptionPlanWhereInputSchema).optional(),
    })
    .strict();

export const PaymentListRelationFilterSchema: z.ZodType<Prisma.PaymentListRelationFilter> = z
  .object({
    every: z.lazy(() => PaymentWhereInputSchema).optional(),
    some: z.lazy(() => PaymentWhereInputSchema).optional(),
    none: z.lazy(() => PaymentWhereInputSchema).optional(),
  })
  .strict();

export const UsageRecordListRelationFilterSchema: z.ZodType<Prisma.UsageRecordListRelationFilter> =
  z
    .object({
      every: z.lazy(() => UsageRecordWhereInputSchema).optional(),
      some: z.lazy(() => UsageRecordWhereInputSchema).optional(),
      none: z.lazy(() => UsageRecordWhereInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotListRelationFilterSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).optional(),
      some: z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).optional(),
      none: z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).optional(),
    })
    .strict();

export const PaymentOrderByRelationAggregateInputSchema: z.ZodType<Prisma.PaymentOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UsageRecordOrderByRelationAggregateInputSchema: z.ZodType<Prisma.UsageRecordOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionCountOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      locationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      planId: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      trialStart: z.lazy(() => SortOrderSchema).optional(),
      trialEnd: z.lazy(() => SortOrderSchema).optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z.lazy(() => SortOrderSchema).optional(),
      cancelledAt: z.lazy(() => SortOrderSchema).optional(),
      cancelReason: z.lazy(() => SortOrderSchema).optional(),
      stripeCustomerId: z.lazy(() => SortOrderSchema).optional(),
      stripeSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
      billingCycleStart: z.lazy(() => SortOrderSchema).optional(),
      billingCycleEnd: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionAvgOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionAvgOrderByAggregateInput> =
  z
    .object({
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      locationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      planId: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      trialStart: z.lazy(() => SortOrderSchema).optional(),
      trialEnd: z.lazy(() => SortOrderSchema).optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z.lazy(() => SortOrderSchema).optional(),
      cancelledAt: z.lazy(() => SortOrderSchema).optional(),
      cancelReason: z.lazy(() => SortOrderSchema).optional(),
      stripeCustomerId: z.lazy(() => SortOrderSchema).optional(),
      stripeSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
      billingCycleStart: z.lazy(() => SortOrderSchema).optional(),
      billingCycleEnd: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionMinOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      locationId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      planId: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      trialStart: z.lazy(() => SortOrderSchema).optional(),
      trialEnd: z.lazy(() => SortOrderSchema).optional(),
      startDate: z.lazy(() => SortOrderSchema).optional(),
      endDate: z.lazy(() => SortOrderSchema).optional(),
      cancelledAt: z.lazy(() => SortOrderSchema).optional(),
      cancelReason: z.lazy(() => SortOrderSchema).optional(),
      stripeCustomerId: z.lazy(() => SortOrderSchema).optional(),
      stripeSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
      billingCycleStart: z.lazy(() => SortOrderSchema).optional(),
      billingCycleEnd: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionSumOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionSumOrderByAggregateInput> =
  z
    .object({
      currentMonthSlots: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumSubscriptionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumSubscriptionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional(),
    })
    .strict();

export const EnumSubscriptionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumSubscriptionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionTypeSchema).optional(),
      in: z
        .lazy(() => SubscriptionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => NestedEnumSubscriptionTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSubscriptionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSubscriptionTypeFilterSchema).optional(),
    })
    .strict();

export const DecimalFilterSchema: z.ZodType<Prisma.DecimalFilter> = z
  .object({
    equals: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    in: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional(),
    notIn: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional(),
    lt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    lte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    not: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        z.lazy(() => NestedDecimalFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumBillingIntervalFilterSchema: z.ZodType<Prisma.EnumBillingIntervalFilter> = z
  .object({
    equals: z.lazy(() => BillingIntervalSchema).optional(),
    in: z
      .lazy(() => BillingIntervalSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => BillingIntervalSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => BillingIntervalSchema),
        z.lazy(() => NestedEnumBillingIntervalFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const JsonNullableFilterSchema: z.ZodType<Prisma.JsonNullableFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional(),
  })
  .strict();

export const SubscriptionPlanCountOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionPlanCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      tierPricing: z.lazy(() => SortOrderSchema).optional(),
      features: z.lazy(() => SortOrderSchema).optional(),
      maxProviders: z.lazy(() => SortOrderSchema).optional(),
      maxLocations: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      stripePriceId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionPlanAvgOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionPlanAvgOrderByAggregateInput> =
  z
    .object({
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      maxProviders: z.lazy(() => SortOrderSchema).optional(),
      maxLocations: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionPlanMaxOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionPlanMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      maxProviders: z.lazy(() => SortOrderSchema).optional(),
      maxLocations: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      stripePriceId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionPlanMinOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionPlanMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      interval: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      maxProviders: z.lazy(() => SortOrderSchema).optional(),
      maxLocations: z.lazy(() => SortOrderSchema).optional(),
      isActive: z.lazy(() => SortOrderSchema).optional(),
      stripePriceId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const SubscriptionPlanSumOrderByAggregateInputSchema: z.ZodType<Prisma.SubscriptionPlanSumOrderByAggregateInput> =
  z
    .object({
      basePrice: z.lazy(() => SortOrderSchema).optional(),
      includedSlots: z.lazy(() => SortOrderSchema).optional(),
      maxProviders: z.lazy(() => SortOrderSchema).optional(),
      maxLocations: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const DecimalWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalWithAggregatesFilter> = z
  .object({
    equals: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    in: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional(),
    notIn: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional(),
    lt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    lte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    not: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        z.lazy(() => NestedDecimalWithAggregatesFilterSchema),
      ])
      .optional(),
    _count: z.lazy(() => NestedIntFilterSchema).optional(),
    _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
    _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
    _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
    _max: z.lazy(() => NestedDecimalFilterSchema).optional(),
  })
  .strict();

export const EnumBillingIntervalWithAggregatesFilterSchema: z.ZodType<Prisma.EnumBillingIntervalWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => BillingIntervalSchema).optional(),
      in: z
        .lazy(() => BillingIntervalSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BillingIntervalSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => NestedEnumBillingIntervalWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBillingIntervalFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBillingIntervalFilterSchema).optional(),
    })
    .strict();

export const JsonNullableWithAggregatesFilterSchema: z.ZodType<Prisma.JsonNullableWithAggregatesFilter> =
  z
    .object({
      equals: InputJsonValueSchema.optional(),
      path: z.string().array().optional(),
      string_contains: z.string().optional(),
      string_starts_with: z.string().optional(),
      string_ends_with: z.string().optional(),
      array_contains: InputJsonValueSchema.optional().nullable(),
      array_starts_with: InputJsonValueSchema.optional().nullable(),
      array_ends_with: InputJsonValueSchema.optional().nullable(),
      lt: InputJsonValueSchema.optional(),
      lte: InputJsonValueSchema.optional(),
      gt: InputJsonValueSchema.optional(),
      gte: InputJsonValueSchema.optional(),
      not: InputJsonValueSchema.optional(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedJsonNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedJsonNullableFilterSchema).optional(),
    })
    .strict();

export const EnumSlotStatusFilterSchema: z.ZodType<Prisma.EnumSlotStatusFilter> = z
  .object({
    equals: z.lazy(() => SlotStatusSchema).optional(),
    in: z
      .lazy(() => SlotStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => SlotStatusSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => SlotStatusSchema), z.lazy(() => NestedEnumSlotStatusFilterSchema)])
      .optional(),
  })
  .strict();

export const SubscriptionRelationFilterSchema: z.ZodType<Prisma.SubscriptionRelationFilter> = z
  .object({
    is: z.lazy(() => SubscriptionWhereInputSchema).optional(),
    isNot: z.lazy(() => SubscriptionWhereInputSchema).optional(),
  })
  .strict();

export const UsageRecordCountOrderByAggregateInputSchema: z.ZodType<Prisma.UsageRecordCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      slotDate: z.lazy(() => SortOrderSchema).optional(),
      slotStatus: z.lazy(() => SortOrderSchema).optional(),
      billingCycle: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
      processed: z.lazy(() => SortOrderSchema).optional(),
      processedAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UsageRecordAvgOrderByAggregateInputSchema: z.ZodType<Prisma.UsageRecordAvgOrderByAggregateInput> =
  z
    .object({
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UsageRecordMaxOrderByAggregateInputSchema: z.ZodType<Prisma.UsageRecordMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      slotDate: z.lazy(() => SortOrderSchema).optional(),
      slotStatus: z.lazy(() => SortOrderSchema).optional(),
      billingCycle: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
      processed: z.lazy(() => SortOrderSchema).optional(),
      processedAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UsageRecordMinOrderByAggregateInputSchema: z.ZodType<Prisma.UsageRecordMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      slotDate: z.lazy(() => SortOrderSchema).optional(),
      slotStatus: z.lazy(() => SortOrderSchema).optional(),
      billingCycle: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
      processed: z.lazy(() => SortOrderSchema).optional(),
      processedAt: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const UsageRecordSumOrderByAggregateInputSchema: z.ZodType<Prisma.UsageRecordSumOrderByAggregateInput> =
  z
    .object({
      tierUsed: z.lazy(() => SortOrderSchema).optional(),
      priceCharged: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumSlotStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumSlotStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SlotStatusSchema).optional(),
      in: z
        .lazy(() => SlotStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SlotStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => NestedEnumSlotStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSlotStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSlotStatusFilterSchema).optional(),
    })
    .strict();

export const DecimalNullableFilterSchema: z.ZodType<Prisma.DecimalNullableFilter> = z
  .object({
    equals: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional()
      .nullable(),
    in: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional()
      .nullable(),
    notIn: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional()
      .nullable(),
    lt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    lte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    not: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        z.lazy(() => NestedDecimalNullableFilterSchema),
      ])
      .optional()
      .nullable(),
  })
  .strict();

export const EnumPaymentStatusFilterSchema: z.ZodType<Prisma.EnumPaymentStatusFilter> = z
  .object({
    equals: z.lazy(() => PaymentStatusSchema).optional(),
    in: z
      .lazy(() => PaymentStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => PaymentStatusSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => PaymentStatusSchema), z.lazy(() => NestedEnumPaymentStatusFilterSchema)])
      .optional(),
  })
  .strict();

export const PaymentCountOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z.lazy(() => SortOrderSchema).optional(),
      usageAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      stripePaymentId: z.lazy(() => SortOrderSchema).optional(),
      stripeInvoiceId: z.lazy(() => SortOrderSchema).optional(),
      paidAt: z.lazy(() => SortOrderSchema).optional(),
      failureReason: z.lazy(() => SortOrderSchema).optional(),
      billingPeriodStart: z.lazy(() => SortOrderSchema).optional(),
      billingPeriodEnd: z.lazy(() => SortOrderSchema).optional(),
      slotsCovered: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const PaymentAvgOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentAvgOrderByAggregateInput> =
  z
    .object({
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z.lazy(() => SortOrderSchema).optional(),
      usageAmount: z.lazy(() => SortOrderSchema).optional(),
      slotsCovered: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const PaymentMaxOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z.lazy(() => SortOrderSchema).optional(),
      usageAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      stripePaymentId: z.lazy(() => SortOrderSchema).optional(),
      stripeInvoiceId: z.lazy(() => SortOrderSchema).optional(),
      paidAt: z.lazy(() => SortOrderSchema).optional(),
      failureReason: z.lazy(() => SortOrderSchema).optional(),
      billingPeriodStart: z.lazy(() => SortOrderSchema).optional(),
      billingPeriodEnd: z.lazy(() => SortOrderSchema).optional(),
      slotsCovered: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const PaymentMinOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      subscriptionId: z.lazy(() => SortOrderSchema).optional(),
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z.lazy(() => SortOrderSchema).optional(),
      usageAmount: z.lazy(() => SortOrderSchema).optional(),
      currency: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      stripePaymentId: z.lazy(() => SortOrderSchema).optional(),
      stripeInvoiceId: z.lazy(() => SortOrderSchema).optional(),
      paidAt: z.lazy(() => SortOrderSchema).optional(),
      failureReason: z.lazy(() => SortOrderSchema).optional(),
      billingPeriodStart: z.lazy(() => SortOrderSchema).optional(),
      billingPeriodEnd: z.lazy(() => SortOrderSchema).optional(),
      slotsCovered: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const PaymentSumOrderByAggregateInputSchema: z.ZodType<Prisma.PaymentSumOrderByAggregateInput> =
  z
    .object({
      amount: z.lazy(() => SortOrderSchema).optional(),
      baseAmount: z.lazy(() => SortOrderSchema).optional(),
      usageAmount: z.lazy(() => SortOrderSchema).optional(),
      slotsCovered: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const DecimalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.DecimalNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
          message: 'Must be a Decimal',
        })
        .optional()
        .nullable(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
          message: 'Must be a Decimal',
        })
        .optional()
        .nullable(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
          z.lazy(() => NestedDecimalNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
    })
    .strict();

export const EnumPaymentStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumPaymentStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
    })
    .strict();

export const EnumRequirementValidationTypeFilterSchema: z.ZodType<Prisma.EnumRequirementValidationTypeFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementValidationTypeSchema).optional(),
      in: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => NestedEnumRequirementValidationTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeCountOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementTypeCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isRequired: z.lazy(() => SortOrderSchema).optional(),
      validationType: z.lazy(() => SortOrderSchema).optional(),
      validationConfig: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementTypeAvgOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementTypeAvgOrderByAggregateInput> =
  z
    .object({
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementTypeMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementTypeMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isRequired: z.lazy(() => SortOrderSchema).optional(),
      validationType: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementTypeMinOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementTypeMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      isRequired: z.lazy(() => SortOrderSchema).optional(),
      validationType: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementTypeSumOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementTypeSumOrderByAggregateInput> =
  z
    .object({
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumRequirementValidationTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumRequirementValidationTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementValidationTypeSchema).optional(),
      in: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => NestedEnumRequirementValidationTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumRequirementValidationTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumRequirementValidationTypeFilterSchema).optional(),
    })
    .strict();

export const EnumRequirementsValidationStatusFilterSchema: z.ZodType<Prisma.EnumRequirementsValidationStatusFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      in: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => NestedEnumRequirementsValidationStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeRelationFilterSchema: z.ZodType<Prisma.RequirementTypeRelationFilter> =
  z
    .object({
      is: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
      isNot: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
    })
    .strict();

export const RequirementSubmissionRequirementTypeIdServiceProviderIdCompoundUniqueInputSchema: z.ZodType<Prisma.RequirementSubmissionRequirementTypeIdServiceProviderIdCompoundUniqueInput> =
  z
    .object({
      requirementTypeId: z.string(),
      serviceProviderId: z.string(),
    })
    .strict();

export const RequirementSubmissionCountOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementSubmissionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      requirementTypeId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      documentUrl: z.lazy(() => SortOrderSchema).optional(),
      documentMetadata: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      validatedAt: z.lazy(() => SortOrderSchema).optional(),
      validatedById: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementSubmissionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementSubmissionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      requirementTypeId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      documentUrl: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      validatedAt: z.lazy(() => SortOrderSchema).optional(),
      validatedById: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const RequirementSubmissionMinOrderByAggregateInputSchema: z.ZodType<Prisma.RequirementSubmissionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      requirementTypeId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      documentUrl: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      validatedAt: z.lazy(() => SortOrderSchema).optional(),
      validatedById: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumRequirementsValidationStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumRequirementsValidationStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      in: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => NestedEnumRequirementsValidationStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumRequirementsValidationStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumRequirementsValidationStatusFilterSchema).optional(),
    })
    .strict();

export const ServiceCountOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceAvgOrderByAggregateInput> =
  z
    .object({
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceMinOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      name: z.lazy(() => SortOrderSchema).optional(),
      description: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderTypeId: z.lazy(() => SortOrderSchema).optional(),
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceSumOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceSumOrderByAggregateInput> =
  z
    .object({
      displayPriority: z.lazy(() => SortOrderSchema).optional(),
      defaultDuration: z.lazy(() => SortOrderSchema).optional(),
      defaultPrice: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceRelationFilterSchema: z.ZodType<Prisma.ServiceRelationFilter> = z
  .object({
    is: z.lazy(() => ServiceWhereInputSchema).optional(),
    isNot: z.lazy(() => ServiceWhereInputSchema).optional(),
  })
  .strict();

export const ServiceAvailabilityConfigServiceIdServiceProviderIdCompoundUniqueInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigServiceIdServiceProviderIdCompoundUniqueInput> =
  z
    .object({
      serviceId: z.string(),
      serviceProviderId: z.string(),
    })
    .strict();

export const ServiceAvailabilityConfigCountOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnlineAvailable: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      location: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigAvgOrderByAggregateInput> =
  z
    .object({
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnlineAvailable: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      location: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigMinOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnlineAvailable: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      location: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigSumOrderByAggregateInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigSumOrderByAggregateInput> =
  z
    .object({
      duration: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumAvailabilityStatusFilterSchema: z.ZodType<Prisma.EnumAvailabilityStatusFilter> = z
  .object({
    equals: z.lazy(() => AvailabilityStatusSchema).optional(),
    in: z
      .lazy(() => AvailabilityStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => AvailabilityStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => AvailabilityStatusSchema),
        z.lazy(() => NestedEnumAvailabilityStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumBillingEntityNullableFilterSchema: z.ZodType<Prisma.EnumBillingEntityNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationProviderConnectionNullableRelationFilterSchema: z.ZodType<Prisma.OrganizationProviderConnectionNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => OrganizationProviderConnectionWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => OrganizationProviderConnectionWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const SubscriptionNullableRelationFilterSchema: z.ZodType<Prisma.SubscriptionNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => SubscriptionWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => SubscriptionWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const AvailabilityCountOrderByAggregateInputSchema: z.ZodType<Prisma.AvailabilityCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      locationId: z.lazy(() => SortOrderSchema).optional(),
      connectionId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z.lazy(() => SortOrderSchema).optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      acceptedById: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
      requiresConfirmation: z.lazy(() => SortOrderSchema).optional(),
      billingEntity: z.lazy(() => SortOrderSchema).optional(),
      defaultSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AvailabilityMaxOrderByAggregateInputSchema: z.ZodType<Prisma.AvailabilityMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      locationId: z.lazy(() => SortOrderSchema).optional(),
      connectionId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z.lazy(() => SortOrderSchema).optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      acceptedById: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
      requiresConfirmation: z.lazy(() => SortOrderSchema).optional(),
      billingEntity: z.lazy(() => SortOrderSchema).optional(),
      defaultSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const AvailabilityMinOrderByAggregateInputSchema: z.ZodType<Prisma.AvailabilityMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      organizationId: z.lazy(() => SortOrderSchema).optional(),
      locationId: z.lazy(() => SortOrderSchema).optional(),
      connectionId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z.lazy(() => SortOrderSchema).optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      acceptedById: z.lazy(() => SortOrderSchema).optional(),
      acceptedAt: z.lazy(() => SortOrderSchema).optional(),
      requiresConfirmation: z.lazy(() => SortOrderSchema).optional(),
      billingEntity: z.lazy(() => SortOrderSchema).optional(),
      defaultSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumAvailabilityStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumAvailabilityStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AvailabilityStatusSchema).optional(),
      in: z
        .lazy(() => AvailabilityStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AvailabilityStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => NestedEnumAvailabilityStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAvailabilityStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAvailabilityStatusFilterSchema).optional(),
    })
    .strict();

export const EnumBillingEntityNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumBillingEntityNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBillingEntityNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBillingEntityNullableFilterSchema).optional(),
    })
    .strict();

export const AvailabilityRelationFilterSchema: z.ZodType<Prisma.AvailabilityRelationFilter> = z
  .object({
    is: z.lazy(() => AvailabilityWhereInputSchema).optional(),
    isNot: z.lazy(() => AvailabilityWhereInputSchema).optional(),
  })
  .strict();

export const ServiceAvailabilityConfigRelationFilterSchema: z.ZodType<Prisma.ServiceAvailabilityConfigRelationFilter> =
  z
    .object({
      is: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
      isNot: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
    })
    .strict();

export const BookingNullableRelationFilterSchema: z.ZodType<Prisma.BookingNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => BookingWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => BookingWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const CalendarEventNullableRelationFilterSchema: z.ZodType<Prisma.CalendarEventNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CalendarEventWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CalendarEventWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const CalculatedAvailabilitySlotCountOrderByAggregateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      availabilityId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceConfigId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      lastCalculated: z.lazy(() => SortOrderSchema).optional(),
      billedToSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      blockedByEventId: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotAvgOrderByAggregateInput> =
  z
    .object({
      version: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      availabilityId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceConfigId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      lastCalculated: z.lazy(() => SortOrderSchema).optional(),
      billedToSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      blockedByEventId: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotMinOrderByAggregateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      availabilityId: z.lazy(() => SortOrderSchema).optional(),
      serviceId: z.lazy(() => SortOrderSchema).optional(),
      serviceConfigId: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      lastCalculated: z.lazy(() => SortOrderSchema).optional(),
      billedToSubscriptionId: z.lazy(() => SortOrderSchema).optional(),
      blockedByEventId: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotSumOrderByAggregateInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotSumOrderByAggregateInput> =
  z
    .object({
      version: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumBookingStatusFilterSchema: z.ZodType<Prisma.EnumBookingStatusFilter> = z
  .object({
    equals: z.lazy(() => BookingStatusSchema).optional(),
    in: z
      .lazy(() => BookingStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => BookingStatusSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => BookingStatusSchema), z.lazy(() => NestedEnumBookingStatusFilterSchema)])
      .optional(),
  })
  .strict();

export const CalculatedAvailabilitySlotNullableRelationFilterSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => CalculatedAvailabilitySlotWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => CalculatedAvailabilitySlotWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const CommunicationLogListRelationFilterSchema: z.ZodType<Prisma.CommunicationLogListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CommunicationLogWhereInputSchema).optional(),
      some: z.lazy(() => CommunicationLogWhereInputSchema).optional(),
      none: z.lazy(() => CommunicationLogWhereInputSchema).optional(),
    })
    .strict();

export const ReviewNullableRelationFilterSchema: z.ZodType<Prisma.ReviewNullableRelationFilter> = z
  .object({
    is: z
      .lazy(() => ReviewWhereInputSchema)
      .optional()
      .nullable(),
    isNot: z
      .lazy(() => ReviewWhereInputSchema)
      .optional()
      .nullable(),
  })
  .strict();

export const MeetSessionNullableRelationFilterSchema: z.ZodType<Prisma.MeetSessionNullableRelationFilter> =
  z
    .object({
      is: z
        .lazy(() => MeetSessionWhereInputSchema)
        .optional()
        .nullable(),
      isNot: z
        .lazy(() => MeetSessionWhereInputSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const CommunicationLogOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CommunicationLogOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BookingCountOrderByAggregateInputSchema: z.ZodType<Prisma.BookingCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z.lazy(() => SortOrderSchema).optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      isGuestBooking: z.lazy(() => SortOrderSchema).optional(),
      isGuestSelfBooking: z.lazy(() => SortOrderSchema).optional(),
      confirmedById: z.lazy(() => SortOrderSchema).optional(),
      confirmedAt: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      guestName: z.lazy(() => SortOrderSchema).optional(),
      guestEmail: z.lazy(() => SortOrderSchema).optional(),
      guestPhone: z.lazy(() => SortOrderSchema).optional(),
      guestWhatsapp: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnline: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      calendarEventId: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BookingAvgOrderByAggregateInputSchema: z.ZodType<Prisma.BookingAvgOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BookingMaxOrderByAggregateInputSchema: z.ZodType<Prisma.BookingMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z.lazy(() => SortOrderSchema).optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      isGuestBooking: z.lazy(() => SortOrderSchema).optional(),
      isGuestSelfBooking: z.lazy(() => SortOrderSchema).optional(),
      confirmedById: z.lazy(() => SortOrderSchema).optional(),
      confirmedAt: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      guestName: z.lazy(() => SortOrderSchema).optional(),
      guestEmail: z.lazy(() => SortOrderSchema).optional(),
      guestPhone: z.lazy(() => SortOrderSchema).optional(),
      guestWhatsapp: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnline: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      calendarEventId: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BookingMinOrderByAggregateInputSchema: z.ZodType<Prisma.BookingMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      slotId: z.lazy(() => SortOrderSchema).optional(),
      createdById: z.lazy(() => SortOrderSchema).optional(),
      createdByMembershipId: z.lazy(() => SortOrderSchema).optional(),
      isProviderCreated: z.lazy(() => SortOrderSchema).optional(),
      isGuestBooking: z.lazy(() => SortOrderSchema).optional(),
      isGuestSelfBooking: z.lazy(() => SortOrderSchema).optional(),
      confirmedById: z.lazy(() => SortOrderSchema).optional(),
      confirmedAt: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      guestName: z.lazy(() => SortOrderSchema).optional(),
      guestEmail: z.lazy(() => SortOrderSchema).optional(),
      guestPhone: z.lazy(() => SortOrderSchema).optional(),
      guestWhatsapp: z.lazy(() => SortOrderSchema).optional(),
      price: z.lazy(() => SortOrderSchema).optional(),
      isOnline: z.lazy(() => SortOrderSchema).optional(),
      isInPerson: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      notes: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      calendarEventId: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const BookingSumOrderByAggregateInputSchema: z.ZodType<Prisma.BookingSumOrderByAggregateInput> =
  z
    .object({
      price: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumBookingStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumBookingStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => BookingStatusSchema).optional(),
      in: z
        .lazy(() => BookingStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BookingStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => NestedEnumBookingStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBookingStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBookingStatusFilterSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceCountOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationPreferenceCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      sms: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      phoneNumber: z.lazy(() => SortOrderSchema).optional(),
      whatsappNumber: z.lazy(() => SortOrderSchema).optional(),
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationPreferenceAvgOrderByAggregateInput> =
  z
    .object({
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationPreferenceMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      sms: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      phoneNumber: z.lazy(() => SortOrderSchema).optional(),
      whatsappNumber: z.lazy(() => SortOrderSchema).optional(),
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceMinOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationPreferenceMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      userId: z.lazy(() => SortOrderSchema).optional(),
      email: z.lazy(() => SortOrderSchema).optional(),
      sms: z.lazy(() => SortOrderSchema).optional(),
      whatsapp: z.lazy(() => SortOrderSchema).optional(),
      phoneNumber: z.lazy(() => SortOrderSchema).optional(),
      whatsappNumber: z.lazy(() => SortOrderSchema).optional(),
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationPreferenceSumOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationPreferenceSumOrderByAggregateInput> =
  z
    .object({
      reminderHours: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumCommunicationTypeFilterSchema: z.ZodType<Prisma.EnumCommunicationTypeFilter> = z
  .object({
    equals: z.lazy(() => CommunicationTypeSchema).optional(),
    in: z
      .lazy(() => CommunicationTypeSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => CommunicationTypeSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => CommunicationTypeSchema),
        z.lazy(() => NestedEnumCommunicationTypeFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumCommunicationChannelFilterSchema: z.ZodType<Prisma.EnumCommunicationChannelFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationChannelSchema).optional(),
      in: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => NestedEnumCommunicationChannelFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const CommunicationLogCountOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationLogCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      bookingReference: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderName: z.lazy(() => SortOrderSchema).optional(),
      clientName: z.lazy(() => SortOrderSchema).optional(),
      serviceName: z.lazy(() => SortOrderSchema).optional(),
      appointmentTime: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      channel: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      sentAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationLogMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationLogMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      bookingReference: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderName: z.lazy(() => SortOrderSchema).optional(),
      clientName: z.lazy(() => SortOrderSchema).optional(),
      serviceName: z.lazy(() => SortOrderSchema).optional(),
      appointmentTime: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      channel: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      sentAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CommunicationLogMinOrderByAggregateInputSchema: z.ZodType<Prisma.CommunicationLogMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      bookingReference: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderName: z.lazy(() => SortOrderSchema).optional(),
      clientName: z.lazy(() => SortOrderSchema).optional(),
      serviceName: z.lazy(() => SortOrderSchema).optional(),
      appointmentTime: z.lazy(() => SortOrderSchema).optional(),
      type: z.lazy(() => SortOrderSchema).optional(),
      channel: z.lazy(() => SortOrderSchema).optional(),
      content: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      sentAt: z.lazy(() => SortOrderSchema).optional(),
      deliveredAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumCommunicationTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCommunicationTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationTypeSchema).optional(),
      in: z
        .lazy(() => CommunicationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => NestedEnumCommunicationTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCommunicationTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCommunicationTypeFilterSchema).optional(),
    })
    .strict();

export const EnumCommunicationChannelWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCommunicationChannelWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationChannelSchema).optional(),
      in: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => NestedEnumCommunicationChannelWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCommunicationChannelFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCommunicationChannelFilterSchema).optional(),
    })
    .strict();

export const StringNullableListFilterSchema: z.ZodType<Prisma.StringNullableListFilter> = z
  .object({
    equals: z.string().array().optional().nullable(),
    has: z.string().optional().nullable(),
    hasEvery: z.string().array().optional(),
    hasSome: z.string().array().optional(),
    isEmpty: z.boolean().optional(),
  })
  .strict();

export const EnumCalendarSyncDirectionFilterSchema: z.ZodType<Prisma.EnumCalendarSyncDirectionFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      in: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => NestedEnumCalendarSyncDirectionFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const CalendarEventListRelationFilterSchema: z.ZodType<Prisma.CalendarEventListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CalendarEventWhereInputSchema).optional(),
      some: z.lazy(() => CalendarEventWhereInputSchema).optional(),
      none: z.lazy(() => CalendarEventWhereInputSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationListRelationFilterSchema: z.ZodType<Prisma.CalendarSyncOperationListRelationFilter> =
  z
    .object({
      every: z.lazy(() => CalendarSyncOperationWhereInputSchema).optional(),
      some: z.lazy(() => CalendarSyncOperationWhereInputSchema).optional(),
      none: z.lazy(() => CalendarSyncOperationWhereInputSchema).optional(),
    })
    .strict();

export const CalendarEventOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CalendarEventOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationOrderByRelationAggregateInputSchema: z.ZodType<Prisma.CalendarSyncOperationOrderByRelationAggregateInput> =
  z
    .object({
      _count: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarIntegrationCountOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarIntegrationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      calendarId: z.lazy(() => SortOrderSchema).optional(),
      syncEnabled: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      googleEmail: z.lazy(() => SortOrderSchema).optional(),
      grantedScopes: z.lazy(() => SortOrderSchema).optional(),
      meetSettings: z.lazy(() => SortOrderSchema).optional(),
      webhookChannelId: z.lazy(() => SortOrderSchema).optional(),
      webhookResourceId: z.lazy(() => SortOrderSchema).optional(),
      webhookExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      nextSyncToken: z.lazy(() => SortOrderSchema).optional(),
      syncDirection: z.lazy(() => SortOrderSchema).optional(),
      blockingEventTypes: z.lazy(() => SortOrderSchema).optional(),
      autoCreateMeetLinks: z.lazy(() => SortOrderSchema).optional(),
      backgroundSyncEnabled: z.lazy(() => SortOrderSchema).optional(),
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      lastFullSyncAt: z.lazy(() => SortOrderSchema).optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarIntegrationAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarIntegrationAvgOrderByAggregateInput> =
  z
    .object({
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarIntegrationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarIntegrationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      calendarId: z.lazy(() => SortOrderSchema).optional(),
      syncEnabled: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      googleEmail: z.lazy(() => SortOrderSchema).optional(),
      webhookChannelId: z.lazy(() => SortOrderSchema).optional(),
      webhookResourceId: z.lazy(() => SortOrderSchema).optional(),
      webhookExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      nextSyncToken: z.lazy(() => SortOrderSchema).optional(),
      syncDirection: z.lazy(() => SortOrderSchema).optional(),
      autoCreateMeetLinks: z.lazy(() => SortOrderSchema).optional(),
      backgroundSyncEnabled: z.lazy(() => SortOrderSchema).optional(),
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      lastFullSyncAt: z.lazy(() => SortOrderSchema).optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarIntegrationMinOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarIntegrationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      provider: z.lazy(() => SortOrderSchema).optional(),
      accessToken: z.lazy(() => SortOrderSchema).optional(),
      refreshToken: z.lazy(() => SortOrderSchema).optional(),
      expiresAt: z.lazy(() => SortOrderSchema).optional(),
      calendarId: z.lazy(() => SortOrderSchema).optional(),
      syncEnabled: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      googleEmail: z.lazy(() => SortOrderSchema).optional(),
      webhookChannelId: z.lazy(() => SortOrderSchema).optional(),
      webhookResourceId: z.lazy(() => SortOrderSchema).optional(),
      webhookExpiresAt: z.lazy(() => SortOrderSchema).optional(),
      nextSyncToken: z.lazy(() => SortOrderSchema).optional(),
      syncDirection: z.lazy(() => SortOrderSchema).optional(),
      autoCreateMeetLinks: z.lazy(() => SortOrderSchema).optional(),
      backgroundSyncEnabled: z.lazy(() => SortOrderSchema).optional(),
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      lastFullSyncAt: z.lazy(() => SortOrderSchema).optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarIntegrationSumOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarIntegrationSumOrderByAggregateInput> =
  z
    .object({
      syncIntervalMinutes: z.lazy(() => SortOrderSchema).optional(),
      syncFailureCount: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncDirectionWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCalendarSyncDirectionWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      in: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => NestedEnumCalendarSyncDirectionWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncDirectionFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncDirectionFilterSchema).optional(),
    })
    .strict();

export const EnumCalendarEventSyncStatusFilterSchema: z.ZodType<Prisma.EnumCalendarEventSyncStatusFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarEventSyncStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationRelationFilterSchema: z.ZodType<Prisma.CalendarIntegrationRelationFilter> =
  z
    .object({
      is: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
      isNot: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
    })
    .strict();

export const CalendarEventCalendarIntegrationIdExternalEventIdCompoundUniqueInputSchema: z.ZodType<Prisma.CalendarEventCalendarIntegrationIdExternalEventIdCompoundUniqueInput> =
  z
    .object({
      calendarIntegrationId: z.string(),
      externalEventId: z.string(),
    })
    .strict();

export const CalendarEventCountOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarEventCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      externalCalendarId: z.lazy(() => SortOrderSchema).optional(),
      etag: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      isAllDay: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      blocksAvailability: z.lazy(() => SortOrderSchema).optional(),
      syncStatus: z.lazy(() => SortOrderSchema).optional(),
      lastModifiedInExternal: z.lazy(() => SortOrderSchema).optional(),
      hasConflict: z.lazy(() => SortOrderSchema).optional(),
      conflictDetails: z.lazy(() => SortOrderSchema).optional(),
      conflictResolvedAt: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarEventAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarEventAvgOrderByAggregateInput> =
  z
    .object({
      version: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarEventMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarEventMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      externalCalendarId: z.lazy(() => SortOrderSchema).optional(),
      etag: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      isAllDay: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      blocksAvailability: z.lazy(() => SortOrderSchema).optional(),
      syncStatus: z.lazy(() => SortOrderSchema).optional(),
      lastModifiedInExternal: z.lazy(() => SortOrderSchema).optional(),
      hasConflict: z.lazy(() => SortOrderSchema).optional(),
      conflictDetails: z.lazy(() => SortOrderSchema).optional(),
      conflictResolvedAt: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarEventMinOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarEventMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      externalCalendarId: z.lazy(() => SortOrderSchema).optional(),
      etag: z.lazy(() => SortOrderSchema).optional(),
      title: z.lazy(() => SortOrderSchema).optional(),
      startTime: z.lazy(() => SortOrderSchema).optional(),
      endTime: z.lazy(() => SortOrderSchema).optional(),
      isAllDay: z.lazy(() => SortOrderSchema).optional(),
      lastSyncedAt: z.lazy(() => SortOrderSchema).optional(),
      eventType: z.lazy(() => SortOrderSchema).optional(),
      blocksAvailability: z.lazy(() => SortOrderSchema).optional(),
      syncStatus: z.lazy(() => SortOrderSchema).optional(),
      lastModifiedInExternal: z.lazy(() => SortOrderSchema).optional(),
      hasConflict: z.lazy(() => SortOrderSchema).optional(),
      conflictDetails: z.lazy(() => SortOrderSchema).optional(),
      conflictResolvedAt: z.lazy(() => SortOrderSchema).optional(),
      version: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarEventSumOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarEventSumOrderByAggregateInput> =
  z
    .object({
      version: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumCalendarEventSyncStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCalendarEventSyncStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarEventSyncStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarEventSyncStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarEventSyncStatusFilterSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncOperationTypeFilterSchema: z.ZodType<Prisma.EnumCalendarSyncOperationTypeFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncOperationTypeSchema).optional(),
      in: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => NestedEnumCalendarSyncOperationTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const EnumCalendarSyncSourceFilterSchema: z.ZodType<Prisma.EnumCalendarSyncSourceFilter> = z
  .object({
    equals: z.lazy(() => CalendarSyncSourceSchema).optional(),
    in: z
      .lazy(() => CalendarSyncSourceSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => CalendarSyncSourceSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => CalendarSyncSourceSchema),
        z.lazy(() => NestedEnumCalendarSyncSourceFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumCalendarSyncStatusFilterSchema: z.ZodType<Prisma.EnumCalendarSyncStatusFilter> = z
  .object({
    equals: z.lazy(() => CalendarSyncStatusSchema).optional(),
    in: z
      .lazy(() => CalendarSyncStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => CalendarSyncStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => CalendarSyncStatusSchema),
        z.lazy(() => NestedEnumCalendarSyncStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumCalendarEntityTypeFilterSchema: z.ZodType<Prisma.EnumCalendarEntityTypeFilter> = z
  .object({
    equals: z.lazy(() => CalendarEntityTypeSchema).optional(),
    in: z
      .lazy(() => CalendarEntityTypeSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => CalendarEntityTypeSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => CalendarEntityTypeSchema),
        z.lazy(() => NestedEnumCalendarEntityTypeFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const EnumConflictResolutionNullableFilterSchema: z.ZodType<Prisma.EnumConflictResolutionNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NestedEnumConflictResolutionNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const CalendarSyncOperationCountOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarSyncOperationCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      operationType: z.lazy(() => SortOrderSchema).optional(),
      sourceSystem: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      completedAt: z.lazy(() => SortOrderSchema).optional(),
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z.lazy(() => SortOrderSchema).optional(),
      conflictResolution: z.lazy(() => SortOrderSchema).optional(),
      syncWindowStart: z.lazy(() => SortOrderSchema).optional(),
      syncWindowEnd: z.lazy(() => SortOrderSchema).optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationAvgOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarSyncOperationAvgOrderByAggregateInput> =
  z
    .object({
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationMaxOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarSyncOperationMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      operationType: z.lazy(() => SortOrderSchema).optional(),
      sourceSystem: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      completedAt: z.lazy(() => SortOrderSchema).optional(),
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z.lazy(() => SortOrderSchema).optional(),
      conflictResolution: z.lazy(() => SortOrderSchema).optional(),
      syncWindowStart: z.lazy(() => SortOrderSchema).optional(),
      syncWindowEnd: z.lazy(() => SortOrderSchema).optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationMinOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarSyncOperationMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      calendarIntegrationId: z.lazy(() => SortOrderSchema).optional(),
      operationType: z.lazy(() => SortOrderSchema).optional(),
      sourceSystem: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      entityType: z.lazy(() => SortOrderSchema).optional(),
      entityId: z.lazy(() => SortOrderSchema).optional(),
      externalEventId: z.lazy(() => SortOrderSchema).optional(),
      startedAt: z.lazy(() => SortOrderSchema).optional(),
      completedAt: z.lazy(() => SortOrderSchema).optional(),
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      errorMessage: z.lazy(() => SortOrderSchema).optional(),
      conflictResolution: z.lazy(() => SortOrderSchema).optional(),
      syncWindowStart: z.lazy(() => SortOrderSchema).optional(),
      syncWindowEnd: z.lazy(() => SortOrderSchema).optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const CalendarSyncOperationSumOrderByAggregateInputSchema: z.ZodType<Prisma.CalendarSyncOperationSumOrderByAggregateInput> =
  z
    .object({
      retryCount: z.lazy(() => SortOrderSchema).optional(),
      maxRetries: z.lazy(() => SortOrderSchema).optional(),
      eventsProcessed: z.lazy(() => SortOrderSchema).optional(),
      eventsSucceeded: z.lazy(() => SortOrderSchema).optional(),
      eventsFailed: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncOperationTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCalendarSyncOperationTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncOperationTypeSchema).optional(),
      in: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => NestedEnumCalendarSyncOperationTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncOperationTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncOperationTypeFilterSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncSourceWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCalendarSyncSourceWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncSourceSchema).optional(),
      in: z
        .lazy(() => CalendarSyncSourceSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncSourceSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => NestedEnumCalendarSyncSourceWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncSourceFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncSourceFilterSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCalendarSyncStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarSyncStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncStatusFilterSchema).optional(),
    })
    .strict();

export const EnumCalendarEntityTypeWithAggregatesFilterSchema: z.ZodType<Prisma.EnumCalendarEntityTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEntityTypeSchema).optional(),
      in: z
        .lazy(() => CalendarEntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => NestedEnumCalendarEntityTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarEntityTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarEntityTypeFilterSchema).optional(),
    })
    .strict();

export const EnumConflictResolutionNullableWithAggregatesFilterSchema: z.ZodType<Prisma.EnumConflictResolutionNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NestedEnumConflictResolutionNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumConflictResolutionNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumConflictResolutionNullableFilterSchema).optional(),
    })
    .strict();

export const EnumMeetSessionStatusFilterSchema: z.ZodType<Prisma.EnumMeetSessionStatusFilter> = z
  .object({
    equals: z.lazy(() => MeetSessionStatusSchema).optional(),
    in: z
      .lazy(() => MeetSessionStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => MeetSessionStatusSchema)
      .array()
      .optional(),
    not: z
      .union([
        z.lazy(() => MeetSessionStatusSchema),
        z.lazy(() => NestedEnumMeetSessionStatusFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const BookingRelationFilterSchema: z.ZodType<Prisma.BookingRelationFilter> = z
  .object({
    is: z.lazy(() => BookingWhereInputSchema).optional(),
    isNot: z.lazy(() => BookingWhereInputSchema).optional(),
  })
  .strict();

export const MeetSessionCountOrderByAggregateInputSchema: z.ZodType<Prisma.MeetSessionCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      eventId: z.lazy(() => SortOrderSchema).optional(),
      joinCode: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const MeetSessionMaxOrderByAggregateInputSchema: z.ZodType<Prisma.MeetSessionMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      eventId: z.lazy(() => SortOrderSchema).optional(),
      joinCode: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const MeetSessionMinOrderByAggregateInputSchema: z.ZodType<Prisma.MeetSessionMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      meetLink: z.lazy(() => SortOrderSchema).optional(),
      eventId: z.lazy(() => SortOrderSchema).optional(),
      joinCode: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumMeetSessionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumMeetSessionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MeetSessionStatusSchema).optional(),
      in: z
        .lazy(() => MeetSessionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MeetSessionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => NestedEnumMeetSessionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMeetSessionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMeetSessionStatusFilterSchema).optional(),
    })
    .strict();

export const EnumReviewStatusFilterSchema: z.ZodType<Prisma.EnumReviewStatusFilter> = z
  .object({
    equals: z.lazy(() => ReviewStatusSchema).optional(),
    in: z
      .lazy(() => ReviewStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => ReviewStatusSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => ReviewStatusSchema), z.lazy(() => NestedEnumReviewStatusFilterSchema)])
      .optional(),
  })
  .strict();

export const ReviewCountOrderByAggregateInputSchema: z.ZodType<Prisma.ReviewCountOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      rating: z.lazy(() => SortOrderSchema).optional(),
      comment: z.lazy(() => SortOrderSchema).optional(),
      response: z.lazy(() => SortOrderSchema).optional(),
      isPublic: z.lazy(() => SortOrderSchema).optional(),
      googleReviewId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ReviewAvgOrderByAggregateInputSchema: z.ZodType<Prisma.ReviewAvgOrderByAggregateInput> =
  z
    .object({
      rating: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ReviewMaxOrderByAggregateInputSchema: z.ZodType<Prisma.ReviewMaxOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      rating: z.lazy(() => SortOrderSchema).optional(),
      comment: z.lazy(() => SortOrderSchema).optional(),
      response: z.lazy(() => SortOrderSchema).optional(),
      isPublic: z.lazy(() => SortOrderSchema).optional(),
      googleReviewId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ReviewMinOrderByAggregateInputSchema: z.ZodType<Prisma.ReviewMinOrderByAggregateInput> =
  z
    .object({
      id: z.lazy(() => SortOrderSchema).optional(),
      serviceProviderId: z.lazy(() => SortOrderSchema).optional(),
      clientId: z.lazy(() => SortOrderSchema).optional(),
      bookingId: z.lazy(() => SortOrderSchema).optional(),
      rating: z.lazy(() => SortOrderSchema).optional(),
      comment: z.lazy(() => SortOrderSchema).optional(),
      response: z.lazy(() => SortOrderSchema).optional(),
      isPublic: z.lazy(() => SortOrderSchema).optional(),
      googleReviewId: z.lazy(() => SortOrderSchema).optional(),
      status: z.lazy(() => SortOrderSchema).optional(),
      createdAt: z.lazy(() => SortOrderSchema).optional(),
      updatedAt: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const ReviewSumOrderByAggregateInputSchema: z.ZodType<Prisma.ReviewSumOrderByAggregateInput> =
  z
    .object({
      rating: z.lazy(() => SortOrderSchema).optional(),
    })
    .strict();

export const EnumReviewStatusWithAggregatesFilterSchema: z.ZodType<Prisma.EnumReviewStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ReviewStatusSchema).optional(),
      in: z
        .lazy(() => ReviewStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ReviewStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => NestedEnumReviewStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumReviewStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumReviewStatusFilterSchema).optional(),
    })
    .strict();

export const AccountCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingCreateNestedManyWithoutClientInputSchema: z.ZodType<Prisma.BookingCreateNestedManyWithoutClientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutClientInputSchema),
          z.lazy(() => BookingCreateWithoutClientInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyClientInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingCreateNestedManyWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingCreateNestedManyWithoutCreatedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingCreateNestedManyWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingCreateNestedManyWithoutConfirmedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyConfirmedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationPreferenceCreateManyUserInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationMembershipCreateManyUserInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyChangedByInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutCreatedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyCreatedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutAcceptedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyAcceptedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationCreateNestedManyWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationCreateNestedManyWithoutApprovedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationCreateManyApprovedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderCreateNestedManyWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedManyWithoutApprovedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceProviderCreateManyApprovedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateNestedManyWithoutInvitedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyInvitedByInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewCreateNestedManyWithoutClientInputSchema: z.ZodType<Prisma.ReviewCreateNestedManyWithoutClientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutClientInputSchema),
          z.lazy(() => ReviewCreateWithoutClientInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyClientInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateNestedManyWithoutValidatedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyValidatedByInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateNestedOneWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutUserInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateNestedManyWithoutClientInputSchema: z.ZodType<Prisma.BookingUncheckedCreateNestedManyWithoutClientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutClientInputSchema),
          z.lazy(() => BookingCreateWithoutClientInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyClientInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUncheckedCreateNestedManyWithoutCreatedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUncheckedCreateNestedManyWithoutConfirmedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyConfirmedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationPreferenceCreateManyUserInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateNestedManyWithoutUserInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationMembershipCreateManyUserInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyChangedByInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutCreatedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyCreatedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyAcceptedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateNestedManyWithoutApprovedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationCreateManyApprovedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceProviderCreateManyApprovedByInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyInvitedByInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUncheckedCreateNestedManyWithoutClientInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateNestedManyWithoutClientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutClientInputSchema),
          z.lazy(() => ReviewCreateWithoutClientInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyClientInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyValidatedByInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const StringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.StringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional(),
    })
    .strict();

export const NullableStringFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableStringFieldUpdateOperationsInput> =
  z
    .object({
      set: z.string().optional().nullable(),
    })
    .strict();

export const NullableDateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional().nullable(),
    })
    .strict();

export const EnumUserRoleFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumUserRoleFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => UserRoleSchema).optional(),
    })
    .strict();

export const DateTimeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DateTimeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.coerce.date().optional(),
    })
    .strict();

export const AccountUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutUserInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => ServiceProviderWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => ServiceProviderWhereInputSchema)]).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutUserInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUpdateManyWithoutClientNestedInputSchema: z.ZodType<Prisma.BookingUpdateManyWithoutClientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutClientInputSchema),
          z.lazy(() => BookingCreateWithoutClientInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyClientInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutClientInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutClientInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingUpdateManyWithoutCreatedByNestedInputSchema: z.ZodType<Prisma.BookingUpdateManyWithoutCreatedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingUpdateManyWithoutConfirmedByNestedInputSchema: z.ZodType<Prisma.BookingUpdateManyWithoutConfirmedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyConfirmedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommunicationPreferenceUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUpsertWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationPreferenceCreateManyUserInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommunicationPreferenceUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUpdateWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommunicationPreferenceUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema),
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationMembershipCreateManyUserInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutChangedByInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutChangedByInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyChangedByInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutChangedByInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutChangedByInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateManyWithWhereWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUpdateManyWithWhereWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutCreatedByNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutCreatedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyCreatedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutAcceptedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyAcceptedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationUpdateManyWithoutApprovedByNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateManyWithoutApprovedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationUpsertWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUpsertWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationCreateManyApprovedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUpdateWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationUpdateManyWithWhereWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUpdateManyWithWhereWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationScalarWhereInputSchema),
          z.lazy(() => OrganizationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyWithoutApprovedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceProviderCreateManyApprovedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateManyWithoutInvitedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutInvitedByInputSchema),
          z
            .lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutInvitedByInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyInvitedByInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutInvitedByInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutInvitedByInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutInvitedByInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutInvitedByInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUpdateManyWithoutClientNestedInputSchema: z.ZodType<Prisma.ReviewUpdateManyWithoutClientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutClientInputSchema),
          z.lazy(() => ReviewCreateWithoutClientInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyClientInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ReviewUpdateManyWithWhereWithoutClientInputSchema),
          z.lazy(() => ReviewUpdateManyWithWhereWithoutClientInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReviewScalarWhereInputSchema),
          z.lazy(() => ReviewScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyWithoutValidatedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutValidatedByInputSchema),
          z
            .lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutValidatedByInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyValidatedByInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutValidatedByInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutValidatedByInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutValidatedByInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutValidatedByInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AccountUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AccountCreateWithoutUserInputSchema),
          z.lazy(() => AccountCreateWithoutUserInputSchema).array(),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => AccountCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => AccountUpsertWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AccountCreateManyUserInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AccountWhereUniqueInputSchema),
          z.lazy(() => AccountWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => AccountUpdateWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => AccountUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AccountScalarWhereInputSchema),
          z.lazy(() => AccountScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateOneWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutUserInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutUserInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutUserInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => ServiceProviderWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => ServiceProviderWhereInputSchema)]).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutUserInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutUserInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutClientNestedInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutClientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutClientInputSchema),
          z.lazy(() => BookingCreateWithoutClientInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyClientInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutClientInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutClientInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutCreatedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutConfirmedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateWithoutConfirmedByInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyConfirmedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutConfirmedByInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutConfirmedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema).array(),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommunicationPreferenceUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUpsertWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationPreferenceCreateManyUserInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
          z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommunicationPreferenceUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUpdateWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommunicationPreferenceUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => CommunicationPreferenceUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema),
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutUserInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationMembershipCreateManyUserInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutUserInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutUserInputSchema),
          z.lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutUserInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutChangedByInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutChangedByInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyChangedByInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutChangedByInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutChangedByInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateManyWithWhereWithoutChangedByInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUpdateManyWithWhereWithoutChangedByInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyCreatedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyAcceptedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAcceptedByInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAcceptedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateManyWithoutApprovedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationUpsertWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUpsertWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => OrganizationCreateManyApprovedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationWhereUniqueInputSchema),
          z.lazy(() => OrganizationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUpdateWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationUpdateManyWithWhereWithoutApprovedByInputSchema),
          z.lazy(() => OrganizationUpdateManyWithWhereWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationScalarWhereInputSchema),
          z.lazy(() => OrganizationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceProviderCreateManyApprovedByInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutApprovedByInputSchema),
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutApprovedByInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutInvitedByInputSchema),
          z
            .lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutInvitedByInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyInvitedByInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutInvitedByInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutInvitedByInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutInvitedByInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutInvitedByInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUncheckedUpdateManyWithoutClientNestedInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateManyWithoutClientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutClientInputSchema),
          z.lazy(() => ReviewCreateWithoutClientInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutClientInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyClientInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutClientInputSchema),
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutClientInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ReviewUpdateManyWithWhereWithoutClientInputSchema),
          z.lazy(() => ReviewUpdateManyWithWhereWithoutClientInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReviewScalarWhereInputSchema),
          z.lazy(() => ReviewScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema),
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutValidatedByInputSchema),
          z
            .lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutValidatedByInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyValidatedByInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutValidatedByInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutValidatedByInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutValidatedByInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutValidatedByInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAccountsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutAccountsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const NullableIntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableIntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional().nullable(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutAccountsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAccountsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutAccountsInputSchema).optional(),
      upsert: z.lazy(() => UserUpsertWithoutAccountsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAccountsInputSchema),
          z.lazy(() => UserUpdateWithoutAccountsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeCreateNestedManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeCreateNestedManyWithoutServiceProviderTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementTypeCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceCreateNestedManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceCreateNestedManyWithoutServiceProviderTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceCreateManyServiceProviderTypeInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderCreateNestedManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedManyWithoutServiceProviderTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceProviderCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedCreateNestedManyWithoutServiceProviderTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementTypeCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateNestedManyWithoutServiceProviderTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceCreateManyServiceProviderTypeInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateNestedManyWithoutServiceProviderTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceProviderCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeUpdateManyWithoutServiceProviderTypeNestedInputSchema: z.ZodType<Prisma.RequirementTypeUpdateManyWithoutServiceProviderTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementTypeUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => RequirementTypeUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementTypeCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementTypeUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => RequirementTypeUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementTypeUpdateManyWithWhereWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => RequirementTypeUpdateManyWithWhereWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementTypeScalarWhereInputSchema),
          z.lazy(() => RequirementTypeScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUpdateManyWithoutServiceProviderTypeNestedInputSchema: z.ZodType<Prisma.ServiceUpdateManyWithoutServiceProviderTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceCreateManyServiceProviderTypeInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceUpdateManyWithWhereWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUpdateManyWithWhereWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceScalarWhereInputSchema),
          z.lazy(() => ServiceScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateManyWithoutServiceProviderTypeNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyWithoutServiceProviderTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceProviderCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => ServiceProviderUpdateManyWithWhereWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementTypeUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => RequirementTypeUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementTypeCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementTypeWhereUniqueInputSchema),
          z.lazy(() => RequirementTypeWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementTypeUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => RequirementTypeUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementTypeUpdateManyWithWhereWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => RequirementTypeUpdateManyWithWhereWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementTypeScalarWhereInputSchema),
          z.lazy(() => RequirementTypeScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateManyWithoutServiceProviderTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ServiceCreateManyServiceProviderTypeInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceUpdateManyWithWhereWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceUpdateManyWithWhereWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceScalarWhereInputSchema),
          z.lazy(() => ServiceScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceProviderCreateManyServiceProviderTypeInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutServiceProviderTypeInputSchema),
          z
            .lazy(() => ServiceProviderUpdateManyWithWhereWithoutServiceProviderTypeInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderCreatelanguagesInputSchema: z.ZodType<Prisma.ServiceProviderCreatelanguagesInput> =
  z
    .object({
      set: z.lazy(() => LanguagesSchema).array(),
    })
    .strict();

export const UserCreateNestedOneWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutServiceProviderInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutServiceProviderInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutServiceProviderInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderTypeCreateWithoutServiceProvidersInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServiceProvidersInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderTypeCreateOrConnectWithoutServiceProvidersInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutProvidersApprovedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutProvidersApprovedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutProvidersApprovedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutProvidersApprovedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ReviewCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyServiceProviderInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceCreateNestedManyWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceCreateNestedManyWithoutProvidersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyServiceProviderInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateNestedOneWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutServiceProviderInputSchema)
        .optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema)
            .array(),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyServiceProviderInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyServiceProviderInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateNestedManyWithoutProvidersInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyServiceProviderInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutServiceProviderInputSchema)
        .optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema)
            .array(),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyServiceProviderInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdatelanguagesInputSchema: z.ZodType<Prisma.ServiceProviderUpdatelanguagesInput> =
  z
    .object({
      set: z
        .lazy(() => LanguagesSchema)
        .array()
        .optional(),
      push: z
        .union([z.lazy(() => LanguagesSchema), z.lazy(() => LanguagesSchema).array()])
        .optional(),
    })
    .strict();

export const EnumServiceProviderStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumServiceProviderStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ServiceProviderStatusSchema).optional(),
    })
    .strict();

export const NullableFloatFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableFloatFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional().nullable(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict();

export const IntFieldUpdateOperationsInputSchema: z.ZodType<Prisma.IntFieldUpdateOperationsInput> =
  z
    .object({
      set: z.number().optional(),
      increment: z.number().optional(),
      decrement: z.number().optional(),
      multiply: z.number().optional(),
      divide: z.number().optional(),
    })
    .strict();

export const NullableEnumTrialStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumTrialStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const BoolFieldUpdateOperationsInputSchema: z.ZodType<Prisma.BoolFieldUpdateOperationsInput> =
  z
    .object({
      set: z.boolean().optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutServiceProviderInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutServiceProviderInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutServiceProviderInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutServiceProviderInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => UserUpdateWithoutServiceProviderInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutServiceProviderInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderTypeCreateWithoutServiceProvidersInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServiceProvidersInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderTypeCreateOrConnectWithoutServiceProvidersInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderTypeUpsertWithoutServiceProvidersInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderTypeUpdateToOneWithWhereWithoutServiceProvidersInputSchema),
          z.lazy(() => ServiceProviderTypeUpdateWithoutServiceProvidersInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutServiceProvidersInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutProvidersApprovedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutProvidersApprovedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutProvidersApprovedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutProvidersApprovedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutProvidersApprovedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutProvidersApprovedInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutProvidersApprovedInputSchema),
          z.lazy(() => UserUpdateWithoutProvidersApprovedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutProvidersApprovedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ReviewUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.ReviewUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyServiceProviderInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ReviewUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUpdateManyWithWhereWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReviewScalarWhereInputSchema),
          z.lazy(() => ReviewScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUpdateManyWithoutProvidersNestedInputSchema: z.ZodType<Prisma.ServiceUpdateManyWithoutProvidersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutProvidersInputSchema),
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutProvidersInputSchema),
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceUpdateManyWithWhereWithoutProvidersInputSchema),
          z.lazy(() => ServiceUpdateManyWithWhereWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceScalarWhereInputSchema),
          z.lazy(() => ServiceScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyServiceProviderInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateOneWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutServiceProviderInputSchema)
        .optional(),
      upsert: z.lazy(() => CalendarIntegrationUpsertWithoutServiceProviderInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CalendarIntegrationWhereInputSchema)])
        .optional(),
      delete: z.union([z.boolean(), z.lazy(() => CalendarIntegrationWhereInputSchema)]).optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateToOneWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUpdateWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutServiceProviderInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema)
            .array(),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              OrganizationProviderConnectionUpsertWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpsertWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              OrganizationProviderConnectionUpdateWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpdateWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateManyWithWhereWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpdateManyWithWhereWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyServiceProviderInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUpsertWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => ReviewCreateManyServiceProviderInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ReviewWhereUniqueInputSchema),
          z.lazy(() => ReviewWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUpdateWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ReviewUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => ReviewUpdateManyWithWhereWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ReviewScalarWhereInputSchema),
          z.lazy(() => ReviewScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateManyWithoutProvidersNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateWithoutProvidersInputSchema).array(),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema),
          z.lazy(() => ServiceCreateOrConnectWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutProvidersInputSchema),
          z.lazy(() => ServiceUpsertWithWhereUniqueWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceWhereUniqueInputSchema),
          z.lazy(() => ServiceWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutProvidersInputSchema),
          z.lazy(() => ServiceUpdateWithWhereUniqueWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceUpdateManyWithWhereWithoutProvidersInputSchema),
          z.lazy(() => ServiceUpdateManyWithWhereWithoutProvidersInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceScalarWhereInputSchema),
          z.lazy(() => ServiceScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyServiceProviderInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutServiceProviderInputSchema)
        .optional(),
      upsert: z.lazy(() => CalendarIntegrationUpsertWithoutServiceProviderInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CalendarIntegrationWhereInputSchema)])
        .optional(),
      delete: z.union([z.boolean(), z.lazy(() => CalendarIntegrationWhereInputSchema)]).optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateToOneWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUpdateWithoutServiceProviderInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutServiceProviderInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema)
            .array(),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              OrganizationProviderConnectionUpsertWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpsertWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyServiceProviderInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              OrganizationProviderConnectionUpdateWithWhereUniqueWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpdateWithWhereUniqueWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateManyWithWhereWithoutServiceProviderInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpdateManyWithWhereWithoutServiceProviderInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyServiceProviderInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutServiceProviderInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutServiceProviderInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutOrganizationsApprovedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOrganizationsApprovedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOrganizationsApprovedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOrganizationsApprovedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SubscriptionCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyOrganizationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const LocationCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => LocationCreateManyOrganizationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyOrganizationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyOrganizationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUncheckedCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => LocationCreateManyOrganizationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutOrganizationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyOrganizationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumOrganizationStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumOrganizationStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationStatusSchema).optional(),
    })
    .strict();

export const EnumOrganizationBillingModelFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumOrganizationBillingModelFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationBillingModelSchema).optional(),
    })
    .strict();

export const UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutOrganizationsApprovedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOrganizationsApprovedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOrganizationsApprovedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOrganizationsApprovedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutOrganizationsApprovedInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutOrganizationsApprovedInputSchema),
          z.lazy(() => UserUpdateWithoutOrganizationsApprovedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutOrganizationsApprovedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyOrganizationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpsertWithWhereUniqueWithoutOrganizationInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpsertWithWhereUniqueWithoutOrganizationInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateWithWhereUniqueWithoutOrganizationInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpdateWithWhereUniqueWithoutOrganizationInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateManyWithWhereWithoutOrganizationInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionUpdateManyWithWhereWithoutOrganizationInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const LocationUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.LocationUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LocationUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => LocationUpsertWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => LocationCreateManyOrganizationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LocationUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => LocationUpdateWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LocationUpdateManyWithWhereWithoutOrganizationInputSchema),
          z.lazy(() => LocationUpdateManyWithWhereWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LocationScalarWhereInputSchema),
          z.lazy(() => LocationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyOrganizationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyOrganizationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutOrganizationInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationInvitationCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
          z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema),
          z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema),
          z
            .lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpsertWithWhereUniqueWithoutOrganizationInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpsertWithWhereUniqueWithoutOrganizationInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationProviderConnectionCreateManyOrganizationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
          z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateWithWhereUniqueWithoutOrganizationInputSchema
          ),
          z
            .lazy(
              () =>
                OrganizationProviderConnectionUpdateWithWhereUniqueWithoutOrganizationInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateManyWithWhereWithoutOrganizationInputSchema
          ),
          z
            .lazy(
              () => OrganizationProviderConnectionUpdateManyWithWhereWithoutOrganizationInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => LocationCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => LocationUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => LocationUpsertWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => LocationCreateManyOrganizationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => LocationWhereUniqueInputSchema),
          z.lazy(() => LocationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => LocationUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => LocationUpdateWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => LocationUpdateManyWithWhereWithoutOrganizationInputSchema),
          z.lazy(() => LocationUpdateManyWithWhereWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => LocationScalarWhereInputSchema),
          z.lazy(() => LocationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyOrganizationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutOrganizationInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutOrganizationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationCreatepermissionsInputSchema: z.ZodType<Prisma.OrganizationInvitationCreatepermissionsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationPermissionSchema).array(),
    })
    .strict();

export const OrganizationCreateNestedOneWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationCreateNestedOneWithoutInvitationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutInvitationsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutInvitationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutInvitationsInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutSentInvitationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSentInvitationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSentInvitationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSentInvitationsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipCreateNestedOneWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateNestedOneWithoutInvitationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutInvitationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutInvitationInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutInvitationInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumOrganizationRoleFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumOrganizationRoleFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationRoleSchema).optional(),
    })
    .strict();

export const OrganizationInvitationUpdatepermissionsInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdatepermissionsInput> =
  z
    .object({
      set: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional(),
      push: z
        .union([
          z.lazy(() => OrganizationPermissionSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumInvitationStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumInvitationStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => InvitationStatusSchema).optional(),
    })
    .strict();

export const OrganizationUpdateOneRequiredWithoutInvitationsNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateOneRequiredWithoutInvitationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutInvitationsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutInvitationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutInvitationsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationUpsertWithoutInvitationsInputSchema).optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateToOneWithWhereWithoutInvitationsInputSchema),
          z.lazy(() => OrganizationUpdateWithoutInvitationsInputSchema),
          z.lazy(() => OrganizationUncheckedUpdateWithoutInvitationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutSentInvitationsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutSentInvitationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutSentInvitationsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutSentInvitationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutSentInvitationsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutSentInvitationsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutSentInvitationsInputSchema),
          z.lazy(() => UserUpdateWithoutSentInvitationsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutSentInvitationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateOneWithoutInvitationNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateOneWithoutInvitationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutInvitationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutInvitationInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutInvitationInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationMembershipUpsertWithoutInvitationInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateToOneWithWhereWithoutInvitationInputSchema),
          z.lazy(() => OrganizationMembershipUpdateWithoutInvitationInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutInvitationInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreatepermissionsInputSchema: z.ZodType<Prisma.OrganizationMembershipCreatepermissionsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationPermissionSchema).array(),
    })
    .strict();

export const OrganizationCreateNestedOneWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationCreateNestedOneWithoutMembershipsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutMembershipsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutMembershipsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutMembershipsInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutOrganizationMembershipsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOrganizationMembershipsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOrganizationMembershipsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOrganizationMembershipsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateNestedOneWithoutMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationInvitationCreateOrConnectWithoutMembershipInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingCreateNestedManyWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingCreateNestedManyWithoutCreatedByMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByMembershipInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutCreatedByMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyCreatedByMembershipInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyMembershipInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationInvitationCreateOrConnectWithoutMembershipInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByMembershipInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyCreatedByMembershipInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyMembershipInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdatepermissionsInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdatepermissionsInput> =
  z
    .object({
      set: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional(),
      push: z
        .union([
          z.lazy(() => OrganizationPermissionSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumMembershipStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumMembershipStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => MembershipStatusSchema).optional(),
    })
    .strict();

export const OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateOneRequiredWithoutMembershipsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutMembershipsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutMembershipsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutMembershipsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationUpsertWithoutMembershipsInputSchema).optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateToOneWithWhereWithoutMembershipsInputSchema),
          z.lazy(() => OrganizationUpdateWithoutMembershipsInputSchema),
          z.lazy(() => OrganizationUncheckedUpdateWithoutMembershipsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutOrganizationMembershipsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutOrganizationMembershipsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutOrganizationMembershipsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutOrganizationMembershipsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutOrganizationMembershipsInputSchema),
          z.lazy(() => UserUpdateWithoutOrganizationMembershipsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutOrganizationMembershipsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateOneWithoutMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationInvitationCreateOrConnectWithoutMembershipInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationInvitationUpsertWithoutMembershipInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => OrganizationInvitationWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => OrganizationInvitationWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateToOneWithWhereWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUpdateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutMembershipInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema: z.ZodType<Prisma.BookingUpdateManyWithoutCreatedByMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByMembershipInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutCreatedByMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyCreatedByMembershipInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByMembershipInputSchema),
          z
            .lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByMembershipInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutMembershipInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutMembershipInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyMembershipInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutMembershipInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutMembershipInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpdateManyWithWhereWithoutMembershipInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpdateManyWithWhereWithoutMembershipInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationInvitationCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationInvitationCreateOrConnectWithoutMembershipInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationInvitationUpsertWithoutMembershipInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => OrganizationInvitationWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => OrganizationInvitationWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationInvitationUpdateToOneWithWhereWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUpdateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutMembershipInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => BookingCreateManyCreatedByMembershipInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => BookingWhereUniqueInputSchema),
          z.lazy(() => BookingWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByMembershipInputSchema),
          z.lazy(() => BookingUpdateManyWithWhereWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => BookingScalarWhereInputSchema),
          z.lazy(() => BookingScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyCreatedByMembershipInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByMembershipInputSchema),
          z
            .lazy(() => AvailabilityUpdateManyWithWhereWithoutCreatedByMembershipInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema),
          z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema).array(),
          z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema),
          z
            .lazy(() => OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutMembershipInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutMembershipInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => OrganizationMembershipHistoryCreateManyMembershipInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
          z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutMembershipInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutMembershipInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => OrganizationMembershipHistoryUpdateManyWithWhereWithoutMembershipInputSchema
          ),
          z
            .lazy(
              () => OrganizationMembershipHistoryUpdateManyWithWhereWithoutMembershipInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateoldPermissionsInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateoldPermissionsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationPermissionSchema).array(),
    })
    .strict();

export const OrganizationMembershipHistoryCreatenewPermissionsInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreatenewPermissionsInput> =
  z
    .object({
      set: z.lazy(() => OrganizationPermissionSchema).array(),
    })
    .strict();

export const OrganizationMembershipCreateNestedOneWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateNestedOneWithoutHistoryInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutHistoryInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutHistoryInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutHistoryInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutMembershipHistoryChangesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutMembershipHistoryChangesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutMembershipHistoryChangesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutMembershipHistoryChangesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumMembershipChangeTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumMembershipChangeTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => MembershipChangeTypeSchema).optional(),
    })
    .strict();

export const NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumOrganizationRoleFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateoldPermissionsInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateoldPermissionsInput> =
  z
    .object({
      set: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional(),
      push: z
        .union([
          z.lazy(() => OrganizationPermissionSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdatenewPermissionsInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdatenewPermissionsInput> =
  z
    .object({
      set: z
        .lazy(() => OrganizationPermissionSchema)
        .array()
        .optional(),
      push: z
        .union([
          z.lazy(() => OrganizationPermissionSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const NullableEnumMembershipStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumMembershipStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipUpdateOneRequiredWithoutHistoryNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateOneRequiredWithoutHistoryNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutHistoryInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutHistoryInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutHistoryInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationMembershipUpsertWithoutHistoryInputSchema).optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateToOneWithWhereWithoutHistoryInputSchema),
          z.lazy(() => OrganizationMembershipUpdateWithoutHistoryInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutHistoryInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutMembershipHistoryChangesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutMembershipHistoryChangesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutMembershipHistoryChangesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutMembershipHistoryChangesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutMembershipHistoryChangesInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutMembershipHistoryChangesInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutMembershipHistoryChangesInputSchema),
          z.lazy(() => UserUpdateWithoutMembershipHistoryChangesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutMembershipHistoryChangesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationCreateNestedOneWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationCreateNestedOneWithoutLocationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutLocationsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutLocationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutLocationsInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SubscriptionCreateNestedManyWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedManyWithoutLocationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyLocationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutLocationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyLocationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateNestedManyWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateNestedManyWithoutLocationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyLocationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutLocationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyLocationInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationUpdateOneRequiredWithoutLocationsNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateOneRequiredWithoutLocationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutLocationsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutLocationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutLocationsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationUpsertWithoutLocationsInputSchema).optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateToOneWithWhereWithoutLocationsInputSchema),
          z.lazy(() => OrganizationUpdateWithoutLocationsInputSchema),
          z.lazy(() => OrganizationUncheckedUpdateWithoutLocationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUpdateManyWithoutLocationNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithoutLocationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyLocationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutLocationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutLocationNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutLocationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyLocationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutLocationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutLocationNestedInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutLocationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateWithoutLocationInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyLocationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutLocationInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutLocationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutLocationNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutLocationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateWithoutLocationInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutLocationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => AvailabilityCreateManyLocationInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutLocationInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutLocationInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutLocationInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationCreateNestedOneWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationCreateNestedOneWithoutProviderConnectionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutProviderConnectionsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutProviderConnectionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutProviderConnectionsInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutProviderConnectionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutProviderConnectionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutProviderConnectionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutProviderConnectionsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutProviderConnectionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyProviderConnectionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutProviderConnectionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyProviderConnectionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumConnectionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumConnectionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ConnectionStatusSchema).optional(),
    })
    .strict();

export const EnumBillingEntityFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumBillingEntityFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => BillingEntitySchema).optional(),
    })
    .strict();

export const OrganizationUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateOneRequiredWithoutProviderConnectionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutProviderConnectionsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutProviderConnectionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutProviderConnectionsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationUpsertWithoutProviderConnectionsInputSchema).optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateToOneWithWhereWithoutProviderConnectionsInputSchema),
          z.lazy(() => OrganizationUpdateWithoutProviderConnectionsInputSchema),
          z.lazy(() => OrganizationUncheckedUpdateWithoutProviderConnectionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneRequiredWithoutProviderConnectionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutProviderConnectionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutProviderConnectionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutProviderConnectionsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutProviderConnectionsInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutProviderConnectionsInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutProviderConnectionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutProviderConnectionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutProviderConnectionNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutProviderConnectionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutProviderConnectionInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutProviderConnectionInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyProviderConnectionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutProviderConnectionInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutProviderConnectionInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutProviderConnectionNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutProviderConnectionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutProviderConnectionInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutProviderConnectionInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyProviderConnectionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutProviderConnectionInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutProviderConnectionInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutProviderConnectionInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutProviderConnectionInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationCreateNestedOneWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationCreateNestedOneWithoutSubscriptionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const LocationCreateNestedOneWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationCreateNestedOneWithoutSubscriptionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => LocationCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => LocationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutSubscriptionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanCreateNestedOneWithoutSubscriptionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionPlanCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => SubscriptionPlanUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionPlanCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      connect: z.lazy(() => SubscriptionPlanWhereUniqueInputSchema).optional(),
    })
    .strict();

export const PaymentCreateNestedManyWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentCreateNestedManyWithoutSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => PaymentCreateManySubscriptionInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UsageRecordCreateNestedManyWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordCreateNestedManyWithoutSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => UsageRecordCreateManySubscriptionInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutDefaultSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyDefaultSubscriptionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUncheckedCreateNestedManyWithoutSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => PaymentCreateManySubscriptionInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => UsageRecordCreateManySubscriptionInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyDefaultSubscriptionInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumSubscriptionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumSubscriptionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => SubscriptionStatusSchema).optional(),
    })
    .strict();

export const EnumSubscriptionTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumSubscriptionTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => SubscriptionTypeSchema).optional(),
    })
    .strict();

export const OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateOneWithoutSubscriptionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationUpsertWithoutSubscriptionsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => OrganizationWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => OrganizationWhereInputSchema)]).optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateToOneWithWhereWithoutSubscriptionsInputSchema),
          z.lazy(() => OrganizationUpdateWithoutSubscriptionsInputSchema),
          z.lazy(() => OrganizationUncheckedUpdateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const LocationUpdateOneWithoutSubscriptionsNestedInputSchema: z.ZodType<Prisma.LocationUpdateOneWithoutSubscriptionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => LocationCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      upsert: z.lazy(() => LocationUpsertWithoutSubscriptionsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => LocationWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => LocationWhereInputSchema)]).optional(),
      connect: z.lazy(() => LocationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => LocationUpdateToOneWithWhereWithoutSubscriptionsInputSchema),
          z.lazy(() => LocationUpdateWithoutSubscriptionsInputSchema),
          z.lazy(() => LocationUncheckedUpdateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneWithoutSubscriptionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutSubscriptionsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => ServiceProviderWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => ServiceProviderWhereInputSchema)]).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutSubscriptionsInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutSubscriptionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema: z.ZodType<Prisma.SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionPlanCreateWithoutSubscriptionsInputSchema),
          z.lazy(() => SubscriptionPlanUncheckedCreateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionPlanCreateOrConnectWithoutSubscriptionsInputSchema)
        .optional(),
      upsert: z.lazy(() => SubscriptionPlanUpsertWithoutSubscriptionsInputSchema).optional(),
      connect: z.lazy(() => SubscriptionPlanWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInputSchema),
          z.lazy(() => SubscriptionPlanUpdateWithoutSubscriptionsInputSchema),
          z.lazy(() => SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const PaymentUpdateManyWithoutSubscriptionNestedInputSchema: z.ZodType<Prisma.PaymentUpdateManyWithoutSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => PaymentUpsertWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUpsertWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => PaymentCreateManySubscriptionInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => PaymentUpdateWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUpdateWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => PaymentUpdateManyWithWhereWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUpdateManyWithWhereWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => PaymentScalarWhereInputSchema),
          z.lazy(() => PaymentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema: z.ZodType<Prisma.UsageRecordUpdateManyWithoutSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => UsageRecordCreateManySubscriptionInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UsageRecordUpdateManyWithWhereWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUpdateManyWithWhereWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UsageRecordScalarWhereInputSchema),
          z.lazy(() => UsageRecordScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutDefaultSubscriptionInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutDefaultSubscriptionInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyDefaultSubscriptionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutDefaultSubscriptionInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutDefaultSubscriptionInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutDefaultSubscriptionInputSchema),
          z
            .lazy(() => AvailabilityUpdateManyWithWhereWithoutDefaultSubscriptionInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => PaymentUpsertWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUpsertWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => PaymentCreateManySubscriptionInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => PaymentWhereUniqueInputSchema),
          z.lazy(() => PaymentWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => PaymentUpdateWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUpdateWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => PaymentUpdateManyWithWhereWithoutSubscriptionInputSchema),
          z.lazy(() => PaymentUpdateManyWithWhereWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => PaymentScalarWhereInputSchema),
          z.lazy(() => PaymentScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema: z.ZodType<Prisma.UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema).array(),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordCreateOrConnectWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => UsageRecordCreateManySubscriptionInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => UsageRecordWhereUniqueInputSchema),
          z.lazy(() => UsageRecordWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => UsageRecordUpdateManyWithWhereWithoutSubscriptionInputSchema),
          z.lazy(() => UsageRecordUpdateManyWithWhereWithoutSubscriptionInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => UsageRecordScalarWhereInputSchema),
          z.lazy(() => UsageRecordScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBilledToSubscriptionInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBilledToSubscriptionInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutDefaultSubscriptionInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutDefaultSubscriptionInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => AvailabilityCreateManyDefaultSubscriptionInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutDefaultSubscriptionInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutDefaultSubscriptionInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutDefaultSubscriptionInputSchema),
          z
            .lazy(() => AvailabilityUpdateManyWithWhereWithoutDefaultSubscriptionInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionCreateNestedManyWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedManyWithoutPlanInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyPlanInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateNestedManyWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateNestedManyWithoutPlanInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyPlanInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const DecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.DecimalFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      increment: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      decrement: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      multiply: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      divide: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict();

export const EnumBillingIntervalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumBillingIntervalFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => BillingIntervalSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateManyWithoutPlanNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithoutPlanNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutPlanInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyPlanInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutPlanInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutPlanInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutPlanNestedInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutPlanNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateWithoutPlanInputSchema).array(),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema),
          z.lazy(() => SubscriptionCreateOrConnectWithoutPlanInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUpsertWithWhereUniqueWithoutPlanInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => SubscriptionCreateManyPlanInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => SubscriptionWhereUniqueInputSchema),
          z.lazy(() => SubscriptionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUpdateWithWhereUniqueWithoutPlanInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutPlanInputSchema),
          z.lazy(() => SubscriptionUpdateManyWithWhereWithoutPlanInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => SubscriptionScalarWhereInputSchema),
          z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionCreateNestedOneWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedOneWithoutUsageRecordsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutUsageRecordsInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutUsageRecordsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutUsageRecordsInputSchema)
        .optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumSlotStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumSlotStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => SlotStatusSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateOneRequiredWithoutUsageRecordsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutUsageRecordsInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutUsageRecordsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutUsageRecordsInputSchema)
        .optional(),
      upsert: z.lazy(() => SubscriptionUpsertWithoutUsageRecordsInputSchema).optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInputSchema),
          z.lazy(() => SubscriptionUpdateWithoutUsageRecordsInputSchema),
          z.lazy(() => SubscriptionUncheckedUpdateWithoutUsageRecordsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionCreateNestedOneWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedOneWithoutPaymentsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPaymentsInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPaymentsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutPaymentsInputSchema)
        .optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const NullableDecimalFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableDecimalFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      increment: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      decrement: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      multiply: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      divide: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
    })
    .strict();

export const EnumPaymentStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumPaymentStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => PaymentStatusSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateOneRequiredWithoutPaymentsNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutPaymentsInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutPaymentsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutPaymentsInputSchema)
        .optional(),
      upsert: z.lazy(() => SubscriptionUpsertWithoutPaymentsInputSchema).optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateToOneWithWhereWithoutPaymentsInputSchema),
          z.lazy(() => SubscriptionUpdateWithoutPaymentsInputSchema),
          z.lazy(() => SubscriptionUncheckedUpdateWithoutPaymentsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateNestedOneWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateNestedOneWithoutRequirementsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderTypeCreateWithoutRequirementsInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutRequirementsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderTypeCreateOrConnectWithoutRequirementsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema).optional(),
    })
    .strict();

export const RequirementSubmissionCreateNestedManyWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateNestedManyWithoutRequirementTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyRequirementTypeInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateNestedManyWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateNestedManyWithoutRequirementTypeInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyRequirementTypeInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumRequirementValidationTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumRequirementValidationTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => RequirementValidationTypeSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateOneRequiredWithoutRequirementsNestedInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateOneRequiredWithoutRequirementsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderTypeCreateWithoutRequirementsInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutRequirementsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderTypeCreateOrConnectWithoutRequirementsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderTypeUpsertWithoutRequirementsInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderTypeUpdateToOneWithWhereWithoutRequirementsInputSchema),
          z.lazy(() => ServiceProviderTypeUpdateWithoutRequirementsInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutRequirementsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUpdateManyWithoutRequirementTypeNestedInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyWithoutRequirementTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyRequirementTypeInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeNestedInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema),
          z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema).array(),
          z.lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUpsertWithWhereUniqueWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => RequirementSubmissionCreateManyRequirementTypeInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
          z.lazy(() => RequirementSubmissionWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateWithWhereUniqueWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutRequirementTypeInputSchema),
          z
            .lazy(() => RequirementSubmissionUpdateManyWithWhereWithoutRequirementTypeInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementTypeCreateNestedOneWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeCreateNestedOneWithoutSubmissionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementTypeCreateWithoutSubmissionsInputSchema),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutSubmissionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RequirementTypeCreateOrConnectWithoutSubmissionsInputSchema)
        .optional(),
      connect: z.lazy(() => RequirementTypeWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutRequirementSubmissionsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutRequirementSubmissionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutRequirementSubmissionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutRequirementSubmissionsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutValidatedRequirementsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutValidatedRequirementsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutValidatedRequirementsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutValidatedRequirementsInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumRequirementsValidationStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => RequirementsValidationStatusSchema).optional(),
    })
    .strict();

export const RequirementTypeUpdateOneRequiredWithoutSubmissionsNestedInputSchema: z.ZodType<Prisma.RequirementTypeUpdateOneRequiredWithoutSubmissionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => RequirementTypeCreateWithoutSubmissionsInputSchema),
          z.lazy(() => RequirementTypeUncheckedCreateWithoutSubmissionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => RequirementTypeCreateOrConnectWithoutSubmissionsInputSchema)
        .optional(),
      upsert: z.lazy(() => RequirementTypeUpsertWithoutSubmissionsInputSchema).optional(),
      connect: z.lazy(() => RequirementTypeWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => RequirementTypeUpdateToOneWithWhereWithoutSubmissionsInputSchema),
          z.lazy(() => RequirementTypeUpdateWithoutSubmissionsInputSchema),
          z.lazy(() => RequirementTypeUncheckedUpdateWithoutSubmissionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateOneRequiredWithoutRequirementSubmissionsNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneRequiredWithoutRequirementSubmissionsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutRequirementSubmissionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutRequirementSubmissionsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutRequirementSubmissionsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ServiceProviderUpsertWithoutRequirementSubmissionsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutRequirementSubmissionsInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutRequirementSubmissionsInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutRequirementSubmissionsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutValidatedRequirementsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutValidatedRequirementsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutValidatedRequirementsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutValidatedRequirementsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutValidatedRequirementsInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutValidatedRequirementsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutValidatedRequirementsInputSchema),
          z.lazy(() => UserUpdateWithoutValidatedRequirementsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutValidatedRequirementsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateNestedOneWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateNestedOneWithoutServicesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderTypeCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServicesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderTypeCreateOrConnectWithoutServicesInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceProviderCreateNestedManyWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedManyWithoutServicesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateNestedManyWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateNestedManyWithoutServiceInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateNestedManyWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateNestedManyWithoutServiceInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateNestedManyWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateNestedManyWithoutServicesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateOneRequiredWithoutServicesNestedInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateOneRequiredWithoutServicesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderTypeCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServicesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderTypeCreateOrConnectWithoutServicesInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderTypeUpsertWithoutServicesInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderTypeUpdateToOneWithWhereWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderTypeUpdateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutServicesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateManyWithoutServicesNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyWithoutServicesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServicesInputSchema).array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServicesInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutServicesInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyWithoutServiceNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyWithoutServiceNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithoutServiceNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithoutServiceNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyWithoutServicesNestedInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyWithoutServicesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema).array(),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderCreateOrConnectWithoutServicesInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUpsertWithWhereUniqueWithoutServicesInputSchema).array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceProviderWhereUniqueInputSchema),
          z.lazy(() => ServiceProviderWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUpdateWithWhereUniqueWithoutServicesInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutServicesInputSchema),
          z.lazy(() => ServiceProviderUpdateManyWithWhereWithoutServicesInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => ServiceAvailabilityConfigCreateManyServiceInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceCreateNestedOneWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceCreateNestedOneWithoutAvailabilityConfigsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutAvailabilityConfigsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceCreateOrConnectWithoutAvailabilityConfigsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutAvailabilityConfigsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilityConfigsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutAvailabilityConfigsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const AvailabilityCreateNestedManyWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedManyWithoutAvailableServicesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateNestedManyWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateNestedManyWithoutServiceConfigInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceConfigInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateNestedManyWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateNestedManyWithoutAvailableServicesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceConfigInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceConfigInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema: z.ZodType<Prisma.ServiceUpdateOneRequiredWithoutAvailabilityConfigsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutAvailabilityConfigsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceCreateOrConnectWithoutAvailabilityConfigsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceUpsertWithoutAvailabilityConfigsInputSchema).optional(),
      connect: z.lazy(() => ServiceWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceUpdateToOneWithWhereWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceUpdateWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceUncheckedUpdateWithoutAvailabilityConfigsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneRequiredWithoutAvailabilityConfigsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilityConfigsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutAvailabilityConfigsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutAvailabilityConfigsInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutAvailabilityConfigsInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutAvailabilityConfigsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateManyWithoutAvailableServicesNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithoutAvailableServicesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAvailableServicesInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAvailableServicesInputSchema)
            .array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAvailableServicesInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAvailableServicesInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithoutServiceConfigNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithoutServiceConfigNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceConfigInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceConfigInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceConfigInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceConfigInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceConfigInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceConfigInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceConfigInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutAvailableServicesNestedInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutAvailableServicesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema).array(),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAvailableServicesInputSchema),
          z
            .lazy(() => AvailabilityUpsertWithWhereUniqueWithoutAvailableServicesInputSchema)
            .array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => AvailabilityWhereUniqueInputSchema),
          z.lazy(() => AvailabilityWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAvailableServicesInputSchema),
          z
            .lazy(() => AvailabilityUpdateWithWhereUniqueWithoutAvailableServicesInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAvailableServicesInputSchema),
          z.lazy(() => AvailabilityUpdateManyWithWhereWithoutAvailableServicesInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => AvailabilityScalarWhereInputSchema),
          z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceConfigInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceConfigInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyServiceConfigInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceConfigInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceConfigInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceConfigInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceConfigInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationCreateNestedOneWithoutAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const LocationCreateNestedOneWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationCreateNestedOneWithoutAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => LocationCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      connect: z.lazy(() => LocationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutAvailabilitiesInputSchema),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedCreateWithoutAvailabilitiesInputSchema
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesCreatedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(
            () => OrganizationMembershipUncheckedCreateWithoutAvailabilitiesCreatedInputSchema
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAvailabilitiesAcceptedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesAcceptedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutDefaultForAvailabilitiesInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutDefaultForAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyAvailabilityInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyAvailabilityInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumAvailabilityStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumAvailabilityStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => AvailabilityStatusSchema).optional(),
    })
    .strict();

export const NullableEnumBillingEntityFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumBillingEntityFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
    })
    .strict();

export const ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutAvailabilitiesInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema: z.ZodType<Prisma.OrganizationUpdateOneWithoutAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => OrganizationUncheckedCreateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      upsert: z.lazy(() => OrganizationUpsertWithoutAvailabilitiesInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => OrganizationWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => OrganizationWhereInputSchema)]).optional(),
      connect: z.lazy(() => OrganizationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationUpdateToOneWithWhereWithoutAvailabilitiesInputSchema),
          z.lazy(() => OrganizationUpdateWithoutAvailabilitiesInputSchema),
          z.lazy(() => OrganizationUncheckedUpdateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const LocationUpdateOneWithoutAvailabilitiesNestedInputSchema: z.ZodType<Prisma.LocationUpdateOneWithoutAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => LocationCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => LocationUncheckedCreateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => LocationCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      upsert: z.lazy(() => LocationUpsertWithoutAvailabilitiesInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => LocationWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => LocationWhereInputSchema)]).optional(),
      connect: z.lazy(() => LocationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => LocationUpdateToOneWithWhereWithoutAvailabilitiesInputSchema),
          z.lazy(() => LocationUpdateWithoutAvailabilitiesInputSchema),
          z.lazy(() => LocationUncheckedUpdateWithoutAvailabilitiesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationProviderConnectionCreateWithoutAvailabilitiesInputSchema),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedCreateWithoutAvailabilitiesInputSchema
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationProviderConnectionCreateOrConnectWithoutAvailabilitiesInputSchema)
        .optional(),
      upsert: z
        .lazy(() => OrganizationProviderConnectionUpsertWithoutAvailabilitiesInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => OrganizationProviderConnectionWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationProviderConnectionUpdateToOneWithWhereWithoutAvailabilitiesInputSchema
          ),
          z.lazy(() => OrganizationProviderConnectionUpdateWithoutAvailabilitiesInputSchema),
          z.lazy(
            () => OrganizationProviderConnectionUncheckedUpdateWithoutAvailabilitiesInputSchema
          ),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesCreatedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutAvailabilitiesCreatedInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(() => UserUpdateWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(
            () => OrganizationMembershipUncheckedCreateWithoutAvailabilitiesCreatedInputSchema
          ),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      upsert: z
        .lazy(() => OrganizationMembershipUpsertWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => OrganizationMembershipUpdateToOneWithWhereWithoutAvailabilitiesCreatedInputSchema
          ),
          z.lazy(() => OrganizationMembershipUpdateWithoutAvailabilitiesCreatedInputSchema),
          z.lazy(
            () => OrganizationMembershipUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema
          ),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutAvailabilitiesAcceptedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutAvailabilitiesAcceptedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesAcceptedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutAvailabilitiesAcceptedInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutAvailabilitiesAcceptedInputSchema),
          z.lazy(() => UserUpdateWithoutAvailabilitiesAcceptedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutAvailabilitiesAcceptedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutDefaultForAvailabilitiesInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutDefaultForAvailabilitiesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      upsert: z.lazy(() => SubscriptionUpsertWithoutDefaultForAvailabilitiesInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => SubscriptionWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => SubscriptionWhereInputSchema)]).optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateToOneWithWhereWithoutDefaultForAvailabilitiesInputSchema),
          z.lazy(() => SubscriptionUpdateWithoutDefaultForAvailabilitiesInputSchema),
          z.lazy(() => SubscriptionUncheckedUpdateWithoutDefaultForAvailabilitiesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutAvailabilitiesInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutAvailabilitiesInputSchema
            )
            .array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutAvailabilitiesInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutAvailabilitiesInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutAvailabilitiesInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutAvailabilitiesInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutAvailabilityInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutAvailabilityInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyAvailabilityInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutAvailabilityInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutAvailabilityInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema),
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema).array(),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema),
          z
            .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutAvailabilitiesInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutAvailabilitiesInputSchema
            )
            .array(),
        ])
        .optional(),
      set: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
          z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutAvailabilitiesInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutAvailabilitiesInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutAvailabilitiesInputSchema
          ),
          z
            .lazy(
              () => ServiceAvailabilityConfigUpdateManyWithWhereWithoutAvailabilitiesInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema).array(),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutAvailabilityInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutAvailabilityInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyAvailabilityInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutAvailabilityInputSchema
          ),
          z
            .lazy(
              () => CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutAvailabilityInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutAvailabilityInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotUpdateManyWithWhereWithoutAvailabilityInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityCreateNestedOneWithoutCalculatedSlotsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => AvailabilityCreateOrConnectWithoutCalculatedSlotsInputSchema)
        .optional(),
      connect: z.lazy(() => AvailabilityWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceCreateNestedOneWithoutCalculatedSlotsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceCreateOrConnectWithoutCalculatedSlotsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceWhereUniqueInputSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutCalculatedSlotsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingCreateNestedOneWithoutSlotInputSchema: z.ZodType<Prisma.BookingCreateNestedOneWithoutSlotInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutSlotInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutSlotInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutSlotInputSchema).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
    })
    .strict();

export const SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionCreateNestedOneWithoutBilledSlotsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutBilledSlotsInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutBilledSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutBilledSlotsInputSchema)
        .optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventCreateNestedOneWithoutBlockedSlotsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarEventCreateWithoutBlockedSlotsInputSchema),
          z.lazy(() => CalendarEventUncheckedCreateWithoutBlockedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarEventCreateOrConnectWithoutBlockedSlotsInputSchema)
        .optional(),
      connect: z.lazy(() => CalendarEventWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateNestedOneWithoutSlotInputSchema: z.ZodType<Prisma.BookingUncheckedCreateNestedOneWithoutSlotInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutSlotInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutSlotInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutSlotInputSchema).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
    })
    .strict();

export const AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema: z.ZodType<Prisma.AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => AvailabilityCreateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => AvailabilityUncheckedCreateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => AvailabilityCreateOrConnectWithoutCalculatedSlotsInputSchema)
        .optional(),
      upsert: z.lazy(() => AvailabilityUpsertWithoutCalculatedSlotsInputSchema).optional(),
      connect: z.lazy(() => AvailabilityWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => AvailabilityUpdateToOneWithWhereWithoutCalculatedSlotsInputSchema),
          z.lazy(() => AvailabilityUpdateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => AvailabilityUncheckedUpdateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema: z.ZodType<Prisma.ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceCreateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceUncheckedCreateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceCreateOrConnectWithoutCalculatedSlotsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceUpsertWithoutCalculatedSlotsInputSchema).optional(),
      connect: z.lazy(() => ServiceWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceUpdateToOneWithWhereWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceUpdateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceUncheckedUpdateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigCreateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceAvailabilityConfigCreateOrConnectWithoutCalculatedSlotsInputSchema)
        .optional(),
      upsert: z
        .lazy(() => ServiceAvailabilityConfigUpsertWithoutCalculatedSlotsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(
            () => ServiceAvailabilityConfigUpdateToOneWithWhereWithoutCalculatedSlotsInputSchema
          ),
          z.lazy(() => ServiceAvailabilityConfigUpdateWithoutCalculatedSlotsInputSchema),
          z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutCalculatedSlotsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUpdateOneWithoutSlotNestedInputSchema: z.ZodType<Prisma.BookingUpdateOneWithoutSlotNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutSlotInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutSlotInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutSlotInputSchema).optional(),
      upsert: z.lazy(() => BookingUpsertWithoutSlotInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => BookingWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => BookingWhereInputSchema)]).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateToOneWithWhereWithoutSlotInputSchema),
          z.lazy(() => BookingUpdateWithoutSlotInputSchema),
          z.lazy(() => BookingUncheckedUpdateWithoutSlotInputSchema),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema: z.ZodType<Prisma.SubscriptionUpdateOneWithoutBilledSlotsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => SubscriptionCreateWithoutBilledSlotsInputSchema),
          z.lazy(() => SubscriptionUncheckedCreateWithoutBilledSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => SubscriptionCreateOrConnectWithoutBilledSlotsInputSchema)
        .optional(),
      upsert: z.lazy(() => SubscriptionUpsertWithoutBilledSlotsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => SubscriptionWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => SubscriptionWhereInputSchema)]).optional(),
      connect: z.lazy(() => SubscriptionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => SubscriptionUpdateToOneWithWhereWithoutBilledSlotsInputSchema),
          z.lazy(() => SubscriptionUpdateWithoutBilledSlotsInputSchema),
          z.lazy(() => SubscriptionUncheckedUpdateWithoutBilledSlotsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema: z.ZodType<Prisma.CalendarEventUpdateOneWithoutBlockedSlotsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarEventCreateWithoutBlockedSlotsInputSchema),
          z.lazy(() => CalendarEventUncheckedCreateWithoutBlockedSlotsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarEventCreateOrConnectWithoutBlockedSlotsInputSchema)
        .optional(),
      upsert: z.lazy(() => CalendarEventUpsertWithoutBlockedSlotsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => CalendarEventWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => CalendarEventWhereInputSchema)]).optional(),
      connect: z.lazy(() => CalendarEventWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CalendarEventUpdateToOneWithWhereWithoutBlockedSlotsInputSchema),
          z.lazy(() => CalendarEventUpdateWithoutBlockedSlotsInputSchema),
          z.lazy(() => CalendarEventUncheckedUpdateWithoutBlockedSlotsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateOneWithoutSlotNestedInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateOneWithoutSlotNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutSlotInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutSlotInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutSlotInputSchema).optional(),
      upsert: z.lazy(() => BookingUpsertWithoutSlotInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => BookingWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => BookingWhereInputSchema)]).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateToOneWithWhereWithoutSlotInputSchema),
          z.lazy(() => BookingUpdateWithoutSlotInputSchema),
          z.lazy(() => BookingUncheckedUpdateWithoutSlotInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBookingInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutBookingInputSchema)
        .optional(),
      connect: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutBookingsCreatedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutBookingsCreatedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutBookingsCreatedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutBookingsCreatedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutBookingsCreatedInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutBookingsCreatedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutBookingsCreatedInputSchema)
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutBookingsConfirmedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutBookingsConfirmedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutBookingsConfirmedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutBookingsConfirmedInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutBookingsAsClientInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutBookingsAsClientInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutBookingsAsClientInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutBookingsAsClientInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const CommunicationLogCreateNestedManyWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogCreateNestedManyWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema).array(),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationLogCreateManyBookingInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewCreateNestedOneWithoutBookingInputSchema: z.ZodType<Prisma.ReviewCreateNestedOneWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutBookingInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => ReviewCreateOrConnectWithoutBookingInputSchema).optional(),
      connect: z.lazy(() => ReviewWhereUniqueInputSchema).optional(),
    })
    .strict();

export const MeetSessionCreateNestedOneWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionCreateNestedOneWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MeetSessionCreateWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => MeetSessionCreateOrConnectWithoutBookingInputSchema).optional(),
      connect: z.lazy(() => MeetSessionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedCreateNestedManyWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema).array(),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationLogCreateManyBookingInputEnvelopeSchema).optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUncheckedCreateNestedOneWithoutBookingInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateNestedOneWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutBookingInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => ReviewCreateOrConnectWithoutBookingInputSchema).optional(),
      connect: z.lazy(() => ReviewWhereUniqueInputSchema).optional(),
    })
    .strict();

export const MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionUncheckedCreateNestedOneWithoutBookingInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MeetSessionCreateWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => MeetSessionCreateOrConnectWithoutBookingInputSchema).optional(),
      connect: z.lazy(() => MeetSessionWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumBookingStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumBookingStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => BookingStatusSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBookingInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalculatedAvailabilitySlotCreateOrConnectWithoutBookingInputSchema)
        .optional(),
      upsert: z.lazy(() => CalculatedAvailabilitySlotUpsertWithoutBookingInputSchema).optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotUpdateToOneWithWhereWithoutBookingInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBookingInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutBookingInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutBookingsCreatedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutBookingsCreatedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutBookingsCreatedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutBookingsCreatedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutBookingsCreatedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutBookingsCreatedInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutBookingsCreatedInputSchema),
          z.lazy(() => UserUpdateWithoutBookingsCreatedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutBookingsCreatedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => OrganizationMembershipCreateWithoutBookingsCreatedInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedCreateWithoutBookingsCreatedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => OrganizationMembershipCreateOrConnectWithoutBookingsCreatedInputSchema)
        .optional(),
      upsert: z
        .lazy(() => OrganizationMembershipUpsertWithoutBookingsCreatedInputSchema)
        .optional(),
      disconnect: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipWhereInputSchema)])
        .optional(),
      delete: z
        .union([z.boolean(), z.lazy(() => OrganizationMembershipWhereInputSchema)])
        .optional(),
      connect: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => OrganizationMembershipUpdateToOneWithWhereWithoutBookingsCreatedInputSchema),
          z.lazy(() => OrganizationMembershipUpdateWithoutBookingsCreatedInputSchema),
          z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutBookingsCreatedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutBookingsConfirmedNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutBookingsConfirmedNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutBookingsConfirmedInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutBookingsConfirmedInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutBookingsConfirmedInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutBookingsConfirmedInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutBookingsConfirmedInputSchema),
          z.lazy(() => UserUpdateWithoutBookingsConfirmedInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutBookingsConfirmedInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneWithoutBookingsAsClientNestedInputSchema: z.ZodType<Prisma.UserUpdateOneWithoutBookingsAsClientNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutBookingsAsClientInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutBookingsAsClientInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutBookingsAsClientInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutBookingsAsClientInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => UserWhereInputSchema)]).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutBookingsAsClientInputSchema),
          z.lazy(() => UserUpdateWithoutBookingsAsClientInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutBookingsAsClientInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CommunicationLogUpdateManyWithoutBookingNestedInputSchema: z.ZodType<Prisma.CommunicationLogUpdateManyWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema).array(),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommunicationLogUpsertWithWhereUniqueWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUpsertWithWhereUniqueWithoutBookingInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationLogCreateManyBookingInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommunicationLogUpdateWithWhereUniqueWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUpdateWithWhereUniqueWithoutBookingInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommunicationLogUpdateManyWithWhereWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUpdateManyWithWhereWithoutBookingInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommunicationLogScalarWhereInputSchema),
          z.lazy(() => CommunicationLogScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUpdateOneWithoutBookingNestedInputSchema: z.ZodType<Prisma.ReviewUpdateOneWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutBookingInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => ReviewCreateOrConnectWithoutBookingInputSchema).optional(),
      upsert: z.lazy(() => ReviewUpsertWithoutBookingInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => ReviewWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => ReviewWhereInputSchema)]).optional(),
      connect: z.lazy(() => ReviewWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ReviewUpdateToOneWithWhereWithoutBookingInputSchema),
          z.lazy(() => ReviewUpdateWithoutBookingInputSchema),
          z.lazy(() => ReviewUncheckedUpdateWithoutBookingInputSchema),
        ])
        .optional(),
    })
    .strict();

export const MeetSessionUpdateOneWithoutBookingNestedInputSchema: z.ZodType<Prisma.MeetSessionUpdateOneWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MeetSessionCreateWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => MeetSessionCreateOrConnectWithoutBookingInputSchema).optional(),
      upsert: z.lazy(() => MeetSessionUpsertWithoutBookingInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => MeetSessionWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => MeetSessionWhereInputSchema)]).optional(),
      connect: z.lazy(() => MeetSessionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => MeetSessionUpdateToOneWithWhereWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUpdateWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUncheckedUpdateWithoutBookingInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedUpdateManyWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema).array(),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogCreateOrConnectWithoutBookingInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CommunicationLogUpsertWithWhereUniqueWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUpsertWithWhereUniqueWithoutBookingInputSchema).array(),
        ])
        .optional(),
      createMany: z.lazy(() => CommunicationLogCreateManyBookingInputEnvelopeSchema).optional(),
      set: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CommunicationLogWhereUniqueInputSchema),
          z.lazy(() => CommunicationLogWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CommunicationLogUpdateWithWhereUniqueWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUpdateWithWhereUniqueWithoutBookingInputSchema).array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CommunicationLogUpdateManyWithWhereWithoutBookingInputSchema),
          z.lazy(() => CommunicationLogUpdateManyWithWhereWithoutBookingInputSchema).array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CommunicationLogScalarWhereInputSchema),
          z.lazy(() => CommunicationLogScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateOneWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ReviewCreateWithoutBookingInputSchema),
          z.lazy(() => ReviewUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => ReviewCreateOrConnectWithoutBookingInputSchema).optional(),
      upsert: z.lazy(() => ReviewUpsertWithoutBookingInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => ReviewWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => ReviewWhereInputSchema)]).optional(),
      connect: z.lazy(() => ReviewWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ReviewUpdateToOneWithWhereWithoutBookingInputSchema),
          z.lazy(() => ReviewUpdateWithoutBookingInputSchema),
          z.lazy(() => ReviewUncheckedUpdateWithoutBookingInputSchema),
        ])
        .optional(),
    })
    .strict();

export const MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema: z.ZodType<Prisma.MeetSessionUncheckedUpdateOneWithoutBookingNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => MeetSessionCreateWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUncheckedCreateWithoutBookingInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => MeetSessionCreateOrConnectWithoutBookingInputSchema).optional(),
      upsert: z.lazy(() => MeetSessionUpsertWithoutBookingInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => MeetSessionWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => MeetSessionWhereInputSchema)]).optional(),
      connect: z.lazy(() => MeetSessionWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => MeetSessionUpdateToOneWithWhereWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUpdateWithoutBookingInputSchema),
          z.lazy(() => MeetSessionUncheckedUpdateWithoutBookingInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutCommunicationPreferencesInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCommunicationPreferencesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCommunicationPreferencesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCommunicationPreferencesInputSchema)
        .optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutCommunicationPreferencesNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutCommunicationPreferencesNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutCommunicationPreferencesInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutCommunicationPreferencesInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => UserCreateOrConnectWithoutCommunicationPreferencesInputSchema)
        .optional(),
      upsert: z.lazy(() => UserUpsertWithoutCommunicationPreferencesInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutCommunicationPreferencesInputSchema),
          z.lazy(() => UserUpdateWithoutCommunicationPreferencesInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutCommunicationPreferencesInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingCreateNestedOneWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingCreateNestedOneWithoutCommunicationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCommunicationsInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCommunicationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BookingCreateOrConnectWithoutCommunicationsInputSchema)
        .optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumCommunicationTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCommunicationTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CommunicationTypeSchema).optional(),
    })
    .strict();

export const EnumCommunicationChannelFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCommunicationChannelFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CommunicationChannelSchema).optional(),
    })
    .strict();

export const BookingUpdateOneWithoutCommunicationsNestedInputSchema: z.ZodType<Prisma.BookingUpdateOneWithoutCommunicationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutCommunicationsInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutCommunicationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => BookingCreateOrConnectWithoutCommunicationsInputSchema)
        .optional(),
      upsert: z.lazy(() => BookingUpsertWithoutCommunicationsInputSchema).optional(),
      disconnect: z.union([z.boolean(), z.lazy(() => BookingWhereInputSchema)]).optional(),
      delete: z.union([z.boolean(), z.lazy(() => BookingWhereInputSchema)]).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateToOneWithWhereWithoutCommunicationsInputSchema),
          z.lazy(() => BookingUpdateWithoutCommunicationsInputSchema),
          z.lazy(() => BookingUncheckedUpdateWithoutCommunicationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreategrantedScopesInputSchema: z.ZodType<Prisma.CalendarIntegrationCreategrantedScopesInput> =
  z
    .object({
      set: z.string().array(),
    })
    .strict();

export const CalendarIntegrationCreateblockingEventTypesInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateblockingEventTypesInput> =
  z
    .object({
      set: z.string().array(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutCalendarIntegrationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutCalendarIntegrationInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutCalendarIntegrationInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const CalendarEventCreateNestedManyWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventCreateNestedManyWithoutCalendarIntegrationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarEventCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationCreateNestedManyWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationCreateNestedManyWithoutCalendarIntegrationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarSyncOperationCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUncheckedCreateNestedManyWithoutCalendarIntegrationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarEventCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedCreateNestedManyWithoutCalendarIntegrationInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarSyncOperationCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationUpdategrantedScopesInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdategrantedScopesInput> =
  z
    .object({
      set: z.string().array().optional(),
      push: z.union([z.string(), z.string().array()]).optional(),
    })
    .strict();

export const EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCalendarSyncDirectionFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CalendarSyncDirectionSchema).optional(),
    })
    .strict();

export const CalendarIntegrationUpdateblockingEventTypesInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateblockingEventTypesInput> =
  z
    .object({
      set: z.string().array().optional(),
      push: z.union([z.string(), z.string().array()]).optional(),
    })
    .strict();

export const ServiceProviderUpdateOneRequiredWithoutCalendarIntegrationNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneRequiredWithoutCalendarIntegrationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutCalendarIntegrationInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutCalendarIntegrationInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutCalendarIntegrationInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutCalendarIntegrationInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutCalendarIntegrationInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CalendarEventUpdateManyWithoutCalendarIntegrationNestedInputSchema: z.ZodType<Prisma.CalendarEventUpdateManyWithoutCalendarIntegrationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CalendarEventUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarEventUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarEventCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CalendarEventUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarEventUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CalendarEventUpdateManyWithWhereWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarEventUpdateManyWithWhereWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalendarEventScalarWhereInputSchema),
          z.lazy(() => CalendarEventScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUpdateManyWithoutCalendarIntegrationNestedInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateManyWithoutCalendarIntegrationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CalendarSyncOperationUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema
          ),
          z
            .lazy(
              () => CalendarSyncOperationUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarSyncOperationCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CalendarSyncOperationUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema
          ),
          z
            .lazy(
              () => CalendarSyncOperationUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => CalendarSyncOperationUpdateManyWithWhereWithoutCalendarIntegrationInputSchema
          ),
          z
            .lazy(
              () => CalendarSyncOperationUpdateManyWithWhereWithoutCalendarIntegrationInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema),
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema: z.ZodType<Prisma.CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema).array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(() => CalendarEventUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarEventUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarEventCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarEventWhereUniqueInputSchema),
          z.lazy(() => CalendarEventWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(() => CalendarEventUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarEventUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(() => CalendarEventUpdateManyWithWhereWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarEventUpdateManyWithWhereWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalendarEventScalarWhereInputSchema),
          z.lazy(() => CalendarEventScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema),
          z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema).array(),
          z.lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema),
          z
            .lazy(() => CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema)
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () => CalendarSyncOperationUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema
          ),
          z
            .lazy(
              () => CalendarSyncOperationUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalendarSyncOperationCreateManyCalendarIntegrationInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
          z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () => CalendarSyncOperationUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema
          ),
          z
            .lazy(
              () => CalendarSyncOperationUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () => CalendarSyncOperationUpdateManyWithWhereWithoutCalendarIntegrationInputSchema
          ),
          z
            .lazy(
              () => CalendarSyncOperationUpdateManyWithWhereWithoutCalendarIntegrationInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema),
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateNestedOneWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateNestedOneWithoutCalendarEventsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutCalendarEventsInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutCalendarEventsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutCalendarEventsInputSchema)
        .optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateNestedManyWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateNestedManyWithoutBlockedByCalendarEventInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBlockedByCalendarEventInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputEnvelopeSchema)
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCalendarEventSyncStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
    })
    .strict();

export const CalendarIntegrationUpdateOneRequiredWithoutCalendarEventsNestedInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateOneRequiredWithoutCalendarEventsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutCalendarEventsInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutCalendarEventsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutCalendarEventsInputSchema)
        .optional(),
      upsert: z.lazy(() => CalendarIntegrationUpsertWithoutCalendarEventsInputSchema).optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateToOneWithWhereWithoutCalendarEventsInputSchema),
          z.lazy(() => CalendarIntegrationUpdateWithoutCalendarEventsInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutCalendarEventsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithoutBlockedByCalendarEventNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithoutBlockedByCalendarEventNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventNestedInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema),
          z
            .lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema)
            .array(),
          z.lazy(
            () => CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      connectOrCreate: z
        .union([
          z.lazy(
            () => CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      upsert: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      createMany: z
        .lazy(() => CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputEnvelopeSchema)
        .optional(),
      set: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      disconnect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      delete: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      connect: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema).array(),
        ])
        .optional(),
      update: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      updateMany: z
        .union([
          z.lazy(
            () =>
              CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBlockedByCalendarEventInputSchema
          ),
          z
            .lazy(
              () =>
                CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBlockedByCalendarEventInputSchema
            )
            .array(),
        ])
        .optional(),
      deleteMany: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateNestedOneWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateNestedOneWithoutSyncOperationsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutSyncOperationsInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutSyncOperationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutSyncOperationsInputSchema)
        .optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCalendarSyncOperationTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CalendarSyncOperationTypeSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncSourceFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCalendarSyncSourceFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CalendarSyncSourceSchema).optional(),
    })
    .strict();

export const EnumCalendarSyncStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCalendarSyncStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CalendarSyncStatusSchema).optional(),
    })
    .strict();

export const EnumCalendarEntityTypeFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumCalendarEntityTypeFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => CalendarEntityTypeSchema).optional(),
    })
    .strict();

export const NullableEnumConflictResolutionFieldUpdateOperationsInputSchema: z.ZodType<Prisma.NullableEnumConflictResolutionFieldUpdateOperationsInput> =
  z
    .object({
      set: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
    })
    .strict();

export const CalendarIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateOneRequiredWithoutSyncOperationsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => CalendarIntegrationCreateWithoutSyncOperationsInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedCreateWithoutSyncOperationsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => CalendarIntegrationCreateOrConnectWithoutSyncOperationsInputSchema)
        .optional(),
      upsert: z.lazy(() => CalendarIntegrationUpsertWithoutSyncOperationsInputSchema).optional(),
      connect: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateToOneWithWhereWithoutSyncOperationsInputSchema),
          z.lazy(() => CalendarIntegrationUpdateWithoutSyncOperationsInputSchema),
          z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutSyncOperationsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingCreateNestedOneWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingCreateNestedOneWithoutMeetSessionInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutMeetSessionInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutMeetSessionInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutMeetSessionInputSchema).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumMeetSessionStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumMeetSessionStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => MeetSessionStatusSchema).optional(),
    })
    .strict();

export const BookingUpdateOneRequiredWithoutMeetSessionNestedInputSchema: z.ZodType<Prisma.BookingUpdateOneRequiredWithoutMeetSessionNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutMeetSessionInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutMeetSessionInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutMeetSessionInputSchema).optional(),
      upsert: z.lazy(() => BookingUpsertWithoutMeetSessionInputSchema).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateToOneWithWhereWithoutMeetSessionInputSchema),
          z.lazy(() => BookingUpdateWithoutMeetSessionInputSchema),
          z.lazy(() => BookingUncheckedUpdateWithoutMeetSessionInputSchema),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderCreateNestedOneWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderCreateNestedOneWithoutReviewsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutReviewsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutReviewsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutReviewsInputSchema)
        .optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
    })
    .strict();

export const UserCreateNestedOneWithoutReviewsInputSchema: z.ZodType<Prisma.UserCreateNestedOneWithoutReviewsInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReviewsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReviewsInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutReviewsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
    })
    .strict();

export const BookingCreateNestedOneWithoutReviewInputSchema: z.ZodType<Prisma.BookingCreateNestedOneWithoutReviewInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutReviewInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutReviewInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutReviewInputSchema).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
    })
    .strict();

export const EnumReviewStatusFieldUpdateOperationsInputSchema: z.ZodType<Prisma.EnumReviewStatusFieldUpdateOperationsInput> =
  z
    .object({
      set: z.lazy(() => ReviewStatusSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateOneRequiredWithoutReviewsNestedInputSchema: z.ZodType<Prisma.ServiceProviderUpdateOneRequiredWithoutReviewsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => ServiceProviderCreateWithoutReviewsInputSchema),
          z.lazy(() => ServiceProviderUncheckedCreateWithoutReviewsInputSchema),
        ])
        .optional(),
      connectOrCreate: z
        .lazy(() => ServiceProviderCreateOrConnectWithoutReviewsInputSchema)
        .optional(),
      upsert: z.lazy(() => ServiceProviderUpsertWithoutReviewsInputSchema).optional(),
      connect: z.lazy(() => ServiceProviderWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => ServiceProviderUpdateToOneWithWhereWithoutReviewsInputSchema),
          z.lazy(() => ServiceProviderUpdateWithoutReviewsInputSchema),
          z.lazy(() => ServiceProviderUncheckedUpdateWithoutReviewsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const UserUpdateOneRequiredWithoutReviewsNestedInputSchema: z.ZodType<Prisma.UserUpdateOneRequiredWithoutReviewsNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => UserCreateWithoutReviewsInputSchema),
          z.lazy(() => UserUncheckedCreateWithoutReviewsInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => UserCreateOrConnectWithoutReviewsInputSchema).optional(),
      upsert: z.lazy(() => UserUpsertWithoutReviewsInputSchema).optional(),
      connect: z.lazy(() => UserWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => UserUpdateToOneWithWhereWithoutReviewsInputSchema),
          z.lazy(() => UserUpdateWithoutReviewsInputSchema),
          z.lazy(() => UserUncheckedUpdateWithoutReviewsInputSchema),
        ])
        .optional(),
    })
    .strict();

export const BookingUpdateOneRequiredWithoutReviewNestedInputSchema: z.ZodType<Prisma.BookingUpdateOneRequiredWithoutReviewNestedInput> =
  z
    .object({
      create: z
        .union([
          z.lazy(() => BookingCreateWithoutReviewInputSchema),
          z.lazy(() => BookingUncheckedCreateWithoutReviewInputSchema),
        ])
        .optional(),
      connectOrCreate: z.lazy(() => BookingCreateOrConnectWithoutReviewInputSchema).optional(),
      upsert: z.lazy(() => BookingUpsertWithoutReviewInputSchema).optional(),
      connect: z.lazy(() => BookingWhereUniqueInputSchema).optional(),
      update: z
        .union([
          z.lazy(() => BookingUpdateToOneWithWhereWithoutReviewInputSchema),
          z.lazy(() => BookingUpdateWithoutReviewInputSchema),
          z.lazy(() => BookingUncheckedUpdateWithoutReviewInputSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedStringFilterSchema: z.ZodType<Prisma.NestedStringFilter> = z
  .object({
    equals: z.string().optional(),
    in: z.string().array().optional(),
    notIn: z.string().array().optional(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    not: z.union([z.string(), z.lazy(() => NestedStringFilterSchema)]).optional(),
  })
  .strict();

export const NestedStringNullableFilterSchema: z.ZodType<Prisma.NestedStringNullableFilter> = z
  .object({
    equals: z.string().optional().nullable(),
    in: z.string().array().optional().nullable(),
    notIn: z.string().array().optional().nullable(),
    lt: z.string().optional(),
    lte: z.string().optional(),
    gt: z.string().optional(),
    gte: z.string().optional(),
    contains: z.string().optional(),
    startsWith: z.string().optional(),
    endsWith: z.string().optional(),
    not: z
      .union([z.string(), z.lazy(() => NestedStringNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const NestedDateTimeNullableFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableFilter> = z
  .object({
    equals: z.coerce.date().optional().nullable(),
    in: z.coerce.date().array().optional().nullable(),
    notIn: z.coerce.date().array().optional().nullable(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z
      .union([z.coerce.date(), z.lazy(() => NestedDateTimeNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const NestedEnumUserRoleFilterSchema: z.ZodType<Prisma.NestedEnumUserRoleFilter> = z
  .object({
    equals: z.lazy(() => UserRoleSchema).optional(),
    in: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => UserRoleSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => UserRoleSchema), z.lazy(() => NestedEnumUserRoleFilterSchema)])
      .optional(),
  })
  .strict();

export const NestedDateTimeFilterSchema: z.ZodType<Prisma.NestedDateTimeFilter> = z
  .object({
    equals: z.coerce.date().optional(),
    in: z.coerce.date().array().optional(),
    notIn: z.coerce.date().array().optional(),
    lt: z.coerce.date().optional(),
    lte: z.coerce.date().optional(),
    gt: z.coerce.date().optional(),
    gte: z.coerce.date().optional(),
    not: z.union([z.coerce.date(), z.lazy(() => NestedDateTimeFilterSchema)]).optional(),
  })
  .strict();

export const NestedStringWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional(),
      in: z.string().array().optional(),
      notIn: z.string().array().optional(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z.union([z.string(), z.lazy(() => NestedStringWithAggregatesFilterSchema)]).optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedStringFilterSchema).optional(),
      _max: z.lazy(() => NestedStringFilterSchema).optional(),
    })
    .strict();

export const NestedIntFilterSchema: z.ZodType<Prisma.NestedIntFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedIntFilterSchema)]).optional(),
  })
  .strict();

export const NestedStringNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedStringNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.string().optional().nullable(),
      in: z.string().array().optional().nullable(),
      notIn: z.string().array().optional().nullable(),
      lt: z.string().optional(),
      lte: z.string().optional(),
      gt: z.string().optional(),
      gte: z.string().optional(),
      contains: z.string().optional(),
      startsWith: z.string().optional(),
      endsWith: z.string().optional(),
      not: z
        .union([z.string(), z.lazy(() => NestedStringNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedStringNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedStringNullableFilterSchema).optional(),
    })
    .strict();

export const NestedIntNullableFilterSchema: z.ZodType<Prisma.NestedIntNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedIntNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const NestedDateTimeNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional().nullable(),
      in: z.coerce.date().array().optional().nullable(),
      notIn: z.coerce.date().array().optional().nullable(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([z.coerce.date(), z.lazy(() => NestedDateTimeNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeNullableFilterSchema).optional(),
    })
    .strict();

export const NestedEnumUserRoleWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumUserRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => UserRoleSchema).optional(),
      in: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => UserRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => NestedEnumUserRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumUserRoleFilterSchema).optional(),
    })
    .strict();

export const NestedDateTimeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDateTimeWithAggregatesFilter> =
  z
    .object({
      equals: z.coerce.date().optional(),
      in: z.coerce.date().array().optional(),
      notIn: z.coerce.date().array().optional(),
      lt: z.coerce.date().optional(),
      lte: z.coerce.date().optional(),
      gt: z.coerce.date().optional(),
      gte: z.coerce.date().optional(),
      not: z
        .union([z.coerce.date(), z.lazy(() => NestedDateTimeWithAggregatesFilterSchema)])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedDateTimeFilterSchema).optional(),
      _max: z.lazy(() => NestedDateTimeFilterSchema).optional(),
    })
    .strict();

export const NestedIntNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedIntNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedIntNullableFilterSchema).optional(),
    })
    .strict();

export const NestedFloatNullableFilterSchema: z.ZodType<Prisma.NestedFloatNullableFilter> = z
  .object({
    equals: z.number().optional().nullable(),
    in: z.number().array().optional().nullable(),
    notIn: z.number().array().optional().nullable(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z
      .union([z.number(), z.lazy(() => NestedFloatNullableFilterSchema)])
      .optional()
      .nullable(),
  })
  .strict();

export const NestedEnumServiceProviderStatusFilterSchema: z.ZodType<Prisma.NestedEnumServiceProviderStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ServiceProviderStatusSchema).optional(),
      in: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => NestedEnumServiceProviderStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumTrialStatusNullableFilterSchema: z.ZodType<Prisma.NestedEnumTrialStatusNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NestedEnumTrialStatusNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedBoolFilterSchema: z.ZodType<Prisma.NestedBoolFilter> = z
  .object({
    equals: z.boolean().optional(),
    not: z.union([z.boolean(), z.lazy(() => NestedBoolFilterSchema)]).optional(),
  })
  .strict();

export const NestedEnumServiceProviderStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumServiceProviderStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ServiceProviderStatusSchema).optional(),
      in: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ServiceProviderStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => NestedEnumServiceProviderStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumServiceProviderStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumServiceProviderStatusFilterSchema).optional(),
    })
    .strict();

export const NestedFloatNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedFloatNullableWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional().nullable(),
      in: z.number().array().optional().nullable(),
      notIn: z.number().array().optional().nullable(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z
        .union([z.number(), z.lazy(() => NestedFloatNullableWithAggregatesFilterSchema)])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedFloatNullableFilterSchema).optional(),
    })
    .strict();

export const NestedIntWithAggregatesFilterSchema: z.ZodType<Prisma.NestedIntWithAggregatesFilter> =
  z
    .object({
      equals: z.number().optional(),
      in: z.number().array().optional(),
      notIn: z.number().array().optional(),
      lt: z.number().optional(),
      lte: z.number().optional(),
      gt: z.number().optional(),
      gte: z.number().optional(),
      not: z.union([z.number(), z.lazy(() => NestedIntWithAggregatesFilterSchema)]).optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedFloatFilterSchema).optional(),
      _sum: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedIntFilterSchema).optional(),
      _max: z.lazy(() => NestedIntFilterSchema).optional(),
    })
    .strict();

export const NestedFloatFilterSchema: z.ZodType<Prisma.NestedFloatFilter> = z
  .object({
    equals: z.number().optional(),
    in: z.number().array().optional(),
    notIn: z.number().array().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    not: z.union([z.number(), z.lazy(() => NestedFloatFilterSchema)]).optional(),
  })
  .strict();

export const NestedEnumTrialStatusNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumTrialStatusNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => TrialStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NestedEnumTrialStatusNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumTrialStatusNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumTrialStatusNullableFilterSchema).optional(),
    })
    .strict();

export const NestedBoolWithAggregatesFilterSchema: z.ZodType<Prisma.NestedBoolWithAggregatesFilter> =
  z
    .object({
      equals: z.boolean().optional(),
      not: z.union([z.boolean(), z.lazy(() => NestedBoolWithAggregatesFilterSchema)]).optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedBoolFilterSchema).optional(),
      _max: z.lazy(() => NestedBoolFilterSchema).optional(),
    })
    .strict();

export const NestedEnumOrganizationStatusFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationStatusFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationStatusSchema).optional(),
      in: z
        .lazy(() => OrganizationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => NestedEnumOrganizationStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumOrganizationBillingModelFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationBillingModelFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationBillingModelSchema).optional(),
      in: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => NestedEnumOrganizationBillingModelFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumOrganizationStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationStatusSchema).optional(),
      in: z
        .lazy(() => OrganizationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => NestedEnumOrganizationStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumOrganizationBillingModelWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationBillingModelWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationBillingModelSchema).optional(),
      in: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationBillingModelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => NestedEnumOrganizationBillingModelWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationBillingModelFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationBillingModelFilterSchema).optional(),
    })
    .strict();

export const NestedEnumOrganizationRoleFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationRoleFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationRoleSchema).optional(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumInvitationStatusFilterSchema: z.ZodType<Prisma.NestedEnumInvitationStatusFilter> =
  z
    .object({
      equals: z.lazy(() => InvitationStatusSchema).optional(),
      in: z
        .lazy(() => InvitationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvitationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => NestedEnumInvitationStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumOrganizationRoleWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationRoleWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => OrganizationRoleSchema).optional(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationRoleFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationRoleFilterSchema).optional(),
    })
    .strict();

export const NestedEnumInvitationStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumInvitationStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => InvitationStatusSchema).optional(),
      in: z
        .lazy(() => InvitationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => InvitationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => NestedEnumInvitationStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumInvitationStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumInvitationStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumMembershipStatusFilterSchema: z.ZodType<Prisma.NestedEnumMembershipStatusFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipStatusSchema).optional(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumMembershipStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumMembershipStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipStatusSchema).optional(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMembershipStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMembershipStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumMembershipChangeTypeFilterSchema: z.ZodType<Prisma.NestedEnumMembershipChangeTypeFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipChangeTypeSchema).optional(),
      in: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => NestedEnumMembershipChangeTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumOrganizationRoleNullableFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationRoleNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumMembershipStatusNullableFilterSchema: z.ZodType<Prisma.NestedEnumMembershipStatusNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumMembershipChangeTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumMembershipChangeTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MembershipChangeTypeSchema).optional(),
      in: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MembershipChangeTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => NestedEnumMembershipChangeTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMembershipChangeTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMembershipChangeTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumOrganizationRoleNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumOrganizationRoleNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => OrganizationRoleSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NestedEnumOrganizationRoleNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumOrganizationRoleNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumOrganizationRoleNullableFilterSchema).optional(),
    })
    .strict();

export const NestedEnumMembershipStatusNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumMembershipStatusNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => MembershipStatusSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NestedEnumMembershipStatusNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMembershipStatusNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMembershipStatusNullableFilterSchema).optional(),
    })
    .strict();

export const NestedJsonFilterSchema: z.ZodType<Prisma.NestedJsonFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional(),
  })
  .strict();

export const NestedEnumConnectionStatusFilterSchema: z.ZodType<Prisma.NestedEnumConnectionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => ConnectionStatusSchema).optional(),
      in: z
        .lazy(() => ConnectionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConnectionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => NestedEnumConnectionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumBillingEntityFilterSchema: z.ZodType<Prisma.NestedEnumBillingEntityFilter> =
  z
    .object({
      equals: z.lazy(() => BillingEntitySchema).optional(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumConnectionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumConnectionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ConnectionStatusSchema).optional(),
      in: z
        .lazy(() => ConnectionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ConnectionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => NestedEnumConnectionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumConnectionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumConnectionStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumBillingEntityWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumBillingEntityWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => BillingEntitySchema).optional(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBillingEntityFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBillingEntityFilterSchema).optional(),
    })
    .strict();

export const NestedEnumSubscriptionStatusFilterSchema: z.ZodType<Prisma.NestedEnumSubscriptionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumSubscriptionTypeFilterSchema: z.ZodType<Prisma.NestedEnumSubscriptionTypeFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionTypeSchema).optional(),
      in: z
        .lazy(() => SubscriptionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => NestedEnumSubscriptionTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumSubscriptionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumSubscriptionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionStatusSchema).optional(),
      in: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => NestedEnumSubscriptionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSubscriptionStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumSubscriptionTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumSubscriptionTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SubscriptionTypeSchema).optional(),
      in: z
        .lazy(() => SubscriptionTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SubscriptionTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => NestedEnumSubscriptionTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSubscriptionTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSubscriptionTypeFilterSchema).optional(),
    })
    .strict();

export const NestedDecimalFilterSchema: z.ZodType<Prisma.NestedDecimalFilter> = z
  .object({
    equals: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    in: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional(),
    notIn: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional(),
    lt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    lte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    not: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        z.lazy(() => NestedDecimalFilterSchema),
      ])
      .optional(),
  })
  .strict();

export const NestedEnumBillingIntervalFilterSchema: z.ZodType<Prisma.NestedEnumBillingIntervalFilter> =
  z
    .object({
      equals: z.lazy(() => BillingIntervalSchema).optional(),
      in: z
        .lazy(() => BillingIntervalSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BillingIntervalSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => NestedEnumBillingIntervalFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedDecimalWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
          message: 'Must be a Decimal',
        })
        .optional(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
          message: 'Must be a Decimal',
        })
        .optional(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
          z.lazy(() => NestedDecimalWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalFilterSchema).optional(),
    })
    .strict();

export const NestedEnumBillingIntervalWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumBillingIntervalWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => BillingIntervalSchema).optional(),
      in: z
        .lazy(() => BillingIntervalSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BillingIntervalSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => NestedEnumBillingIntervalWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBillingIntervalFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBillingIntervalFilterSchema).optional(),
    })
    .strict();

export const NestedJsonNullableFilterSchema: z.ZodType<Prisma.NestedJsonNullableFilter> = z
  .object({
    equals: InputJsonValueSchema.optional(),
    path: z.string().array().optional(),
    string_contains: z.string().optional(),
    string_starts_with: z.string().optional(),
    string_ends_with: z.string().optional(),
    array_contains: InputJsonValueSchema.optional().nullable(),
    array_starts_with: InputJsonValueSchema.optional().nullable(),
    array_ends_with: InputJsonValueSchema.optional().nullable(),
    lt: InputJsonValueSchema.optional(),
    lte: InputJsonValueSchema.optional(),
    gt: InputJsonValueSchema.optional(),
    gte: InputJsonValueSchema.optional(),
    not: InputJsonValueSchema.optional(),
  })
  .strict();

export const NestedEnumSlotStatusFilterSchema: z.ZodType<Prisma.NestedEnumSlotStatusFilter> = z
  .object({
    equals: z.lazy(() => SlotStatusSchema).optional(),
    in: z
      .lazy(() => SlotStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => SlotStatusSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => SlotStatusSchema), z.lazy(() => NestedEnumSlotStatusFilterSchema)])
      .optional(),
  })
  .strict();

export const NestedEnumSlotStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumSlotStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => SlotStatusSchema).optional(),
      in: z
        .lazy(() => SlotStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => SlotStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => NestedEnumSlotStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumSlotStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumSlotStatusFilterSchema).optional(),
    })
    .strict();

export const NestedDecimalNullableFilterSchema: z.ZodType<Prisma.NestedDecimalNullableFilter> = z
  .object({
    equals: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional()
      .nullable(),
    in: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional()
      .nullable(),
    notIn: z
      .union([
        z.number().array(),
        z.string().array(),
        z.instanceof(Decimal).array(),
        z.instanceof(Prisma.Decimal).array(),
        DecimalJsLikeSchema.array(),
      ])
      .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
        message: 'Must be a Decimal',
      })
      .optional()
      .nullable(),
    lt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    lte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gt: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    gte: z
      .union([
        z.number(),
        z.string(),
        z.instanceof(Decimal),
        z.instanceof(Prisma.Decimal),
        DecimalJsLikeSchema,
      ])
      .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
      .optional(),
    not: z
      .union([
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        z.lazy(() => NestedDecimalNullableFilterSchema),
      ])
      .optional()
      .nullable(),
  })
  .strict();

export const NestedEnumPaymentStatusFilterSchema: z.ZodType<Prisma.NestedEnumPaymentStatusFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedDecimalNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedDecimalNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional()
        .nullable(),
      in: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
          message: 'Must be a Decimal',
        })
        .optional()
        .nullable(),
      notIn: z
        .union([
          z.number().array(),
          z.string().array(),
          z.instanceof(Decimal).array(),
          z.instanceof(Prisma.Decimal).array(),
          DecimalJsLikeSchema.array(),
        ])
        .refine((v) => Array.isArray(v) && (v as any[]).every((v) => isValidDecimalInput(v)), {
          message: 'Must be a Decimal',
        })
        .optional()
        .nullable(),
      lt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      lte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gt: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      gte: z
        .union([
          z.number(),
          z.string(),
          z.instanceof(Decimal),
          z.instanceof(Prisma.Decimal),
          DecimalJsLikeSchema,
        ])
        .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' })
        .optional(),
      not: z
        .union([
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
          z.lazy(() => NestedDecimalNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _avg: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _sum: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedDecimalNullableFilterSchema).optional(),
    })
    .strict();

export const NestedEnumPaymentStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumPaymentStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => PaymentStatusSchema).optional(),
      in: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => PaymentStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => NestedEnumPaymentStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumPaymentStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumRequirementValidationTypeFilterSchema: z.ZodType<Prisma.NestedEnumRequirementValidationTypeFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementValidationTypeSchema).optional(),
      in: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => NestedEnumRequirementValidationTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumRequirementValidationTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumRequirementValidationTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementValidationTypeSchema).optional(),
      in: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementValidationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => NestedEnumRequirementValidationTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumRequirementValidationTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumRequirementValidationTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumRequirementsValidationStatusFilterSchema: z.ZodType<Prisma.NestedEnumRequirementsValidationStatusFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      in: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => NestedEnumRequirementsValidationStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumRequirementsValidationStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumRequirementsValidationStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      in: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => RequirementsValidationStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => NestedEnumRequirementsValidationStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumRequirementsValidationStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumRequirementsValidationStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumAvailabilityStatusFilterSchema: z.ZodType<Prisma.NestedEnumAvailabilityStatusFilter> =
  z
    .object({
      equals: z.lazy(() => AvailabilityStatusSchema).optional(),
      in: z
        .lazy(() => AvailabilityStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AvailabilityStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => NestedEnumAvailabilityStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumBillingEntityNullableFilterSchema: z.ZodType<Prisma.NestedEnumBillingEntityNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumAvailabilityStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumAvailabilityStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => AvailabilityStatusSchema).optional(),
      in: z
        .lazy(() => AvailabilityStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => AvailabilityStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => NestedEnumAvailabilityStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumAvailabilityStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumAvailabilityStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumBillingEntityNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumBillingEntityNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => BillingEntitySchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NestedEnumBillingEntityNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBillingEntityNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBillingEntityNullableFilterSchema).optional(),
    })
    .strict();

export const NestedEnumBookingStatusFilterSchema: z.ZodType<Prisma.NestedEnumBookingStatusFilter> =
  z
    .object({
      equals: z.lazy(() => BookingStatusSchema).optional(),
      in: z
        .lazy(() => BookingStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BookingStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => NestedEnumBookingStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumBookingStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumBookingStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => BookingStatusSchema).optional(),
      in: z
        .lazy(() => BookingStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => BookingStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => NestedEnumBookingStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumBookingStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumBookingStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCommunicationTypeFilterSchema: z.ZodType<Prisma.NestedEnumCommunicationTypeFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationTypeSchema).optional(),
      in: z
        .lazy(() => CommunicationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => NestedEnumCommunicationTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCommunicationChannelFilterSchema: z.ZodType<Prisma.NestedEnumCommunicationChannelFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationChannelSchema).optional(),
      in: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => NestedEnumCommunicationChannelFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCommunicationTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCommunicationTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationTypeSchema).optional(),
      in: z
        .lazy(() => CommunicationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => NestedEnumCommunicationTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCommunicationTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCommunicationTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCommunicationChannelWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCommunicationChannelWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CommunicationChannelSchema).optional(),
      in: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CommunicationChannelSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => NestedEnumCommunicationChannelWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCommunicationChannelFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCommunicationChannelFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCalendarSyncDirectionFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncDirectionFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      in: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => NestedEnumCalendarSyncDirectionFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCalendarSyncDirectionWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncDirectionWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      in: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncDirectionSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => NestedEnumCalendarSyncDirectionWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncDirectionFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncDirectionFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCalendarEventSyncStatusFilterSchema: z.ZodType<Prisma.NestedEnumCalendarEventSyncStatusFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarEventSyncStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCalendarEventSyncStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCalendarEventSyncStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEventSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarEventSyncStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarEventSyncStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarEventSyncStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCalendarSyncOperationTypeFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncOperationTypeFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncOperationTypeSchema).optional(),
      in: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => NestedEnumCalendarSyncOperationTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCalendarSyncSourceFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncSourceFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncSourceSchema).optional(),
      in: z
        .lazy(() => CalendarSyncSourceSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncSourceSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => NestedEnumCalendarSyncSourceFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCalendarSyncStatusFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncStatusFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarSyncStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumCalendarEntityTypeFilterSchema: z.ZodType<Prisma.NestedEnumCalendarEntityTypeFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEntityTypeSchema).optional(),
      in: z
        .lazy(() => CalendarEntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => NestedEnumCalendarEntityTypeFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumConflictResolutionNullableFilterSchema: z.ZodType<Prisma.NestedEnumConflictResolutionNullableFilter> =
  z
    .object({
      equals: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NestedEnumConflictResolutionNullableFilterSchema),
        ])
        .optional()
        .nullable(),
    })
    .strict();

export const NestedEnumCalendarSyncOperationTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncOperationTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncOperationTypeSchema).optional(),
      in: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncOperationTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => NestedEnumCalendarSyncOperationTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncOperationTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncOperationTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCalendarSyncSourceWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncSourceWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncSourceSchema).optional(),
      in: z
        .lazy(() => CalendarSyncSourceSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncSourceSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => NestedEnumCalendarSyncSourceWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncSourceFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncSourceFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCalendarSyncStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCalendarSyncStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarSyncStatusSchema).optional(),
      in: z
        .lazy(() => CalendarSyncStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarSyncStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => NestedEnumCalendarSyncStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarSyncStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarSyncStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumCalendarEntityTypeWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumCalendarEntityTypeWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => CalendarEntityTypeSchema).optional(),
      in: z
        .lazy(() => CalendarEntityTypeSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => CalendarEntityTypeSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => NestedEnumCalendarEntityTypeWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumCalendarEntityTypeFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumCalendarEntityTypeFilterSchema).optional(),
    })
    .strict();

export const NestedEnumConflictResolutionNullableWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumConflictResolutionNullableWithAggregatesFilter> =
  z
    .object({
      equals: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      in: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      notIn: z
        .lazy(() => ConflictResolutionSchema)
        .array()
        .optional()
        .nullable(),
      not: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NestedEnumConflictResolutionNullableWithAggregatesFilterSchema),
        ])
        .optional()
        .nullable(),
      _count: z.lazy(() => NestedIntNullableFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumConflictResolutionNullableFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumConflictResolutionNullableFilterSchema).optional(),
    })
    .strict();

export const NestedEnumMeetSessionStatusFilterSchema: z.ZodType<Prisma.NestedEnumMeetSessionStatusFilter> =
  z
    .object({
      equals: z.lazy(() => MeetSessionStatusSchema).optional(),
      in: z
        .lazy(() => MeetSessionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MeetSessionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => NestedEnumMeetSessionStatusFilterSchema),
        ])
        .optional(),
    })
    .strict();

export const NestedEnumMeetSessionStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumMeetSessionStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => MeetSessionStatusSchema).optional(),
      in: z
        .lazy(() => MeetSessionStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => MeetSessionStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => NestedEnumMeetSessionStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumMeetSessionStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumMeetSessionStatusFilterSchema).optional(),
    })
    .strict();

export const NestedEnumReviewStatusFilterSchema: z.ZodType<Prisma.NestedEnumReviewStatusFilter> = z
  .object({
    equals: z.lazy(() => ReviewStatusSchema).optional(),
    in: z
      .lazy(() => ReviewStatusSchema)
      .array()
      .optional(),
    notIn: z
      .lazy(() => ReviewStatusSchema)
      .array()
      .optional(),
    not: z
      .union([z.lazy(() => ReviewStatusSchema), z.lazy(() => NestedEnumReviewStatusFilterSchema)])
      .optional(),
  })
  .strict();

export const NestedEnumReviewStatusWithAggregatesFilterSchema: z.ZodType<Prisma.NestedEnumReviewStatusWithAggregatesFilter> =
  z
    .object({
      equals: z.lazy(() => ReviewStatusSchema).optional(),
      in: z
        .lazy(() => ReviewStatusSchema)
        .array()
        .optional(),
      notIn: z
        .lazy(() => ReviewStatusSchema)
        .array()
        .optional(),
      not: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => NestedEnumReviewStatusWithAggregatesFilterSchema),
        ])
        .optional(),
      _count: z.lazy(() => NestedIntFilterSchema).optional(),
      _min: z.lazy(() => NestedEnumReviewStatusFilterSchema).optional(),
      _max: z.lazy(() => NestedEnumReviewStatusFilterSchema).optional(),
    })
    .strict();

export const AccountCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      provider: z.string(),
      providerAccountId: z.string(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      token_type: z.string().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      session_state: z.string().optional().nullable(),
    })
    .strict();

export const AccountUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      type: z.string(),
      provider: z.string(),
      providerAccountId: z.string(),
      refresh_token: z.string().optional().nullable(),
      access_token: z.string().optional().nullable(),
      expires_at: z.number().int().optional().nullable(),
      token_type: z.string().optional().nullable(),
      scope: z.string().optional().nullable(),
      id_token: z.string().optional().nullable(),
      session_state: z.string().optional().nullable(),
    })
    .strict();

export const AccountCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.AccountCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AccountCreateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.AccountCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AccountCreateManyUserInputSchema),
        z.lazy(() => AccountCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderCreateWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutUserInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const BookingCreateWithoutClientInputSchema: z.ZodType<Prisma.BookingCreateWithoutClientInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutClientInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutClientInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutClientInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutClientInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema),
      ]),
    })
    .strict();

export const BookingCreateManyClientInputEnvelopeSchema: z.ZodType<Prisma.BookingCreateManyClientInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => BookingCreateManyClientInputSchema),
        z.lazy(() => BookingCreateManyClientInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const BookingCreateWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingCreateWithoutCreatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutCreatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutCreatedByInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const BookingCreateManyCreatedByInputEnvelopeSchema: z.ZodType<Prisma.BookingCreateManyCreatedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => BookingCreateManyCreatedByInputSchema),
        z.lazy(() => BookingCreateManyCreatedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const BookingCreateWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingCreateWithoutConfirmedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutConfirmedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutConfirmedByInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutConfirmedByInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema),
      ]),
    })
    .strict();

export const BookingCreateManyConfirmedByInputEnvelopeSchema: z.ZodType<Prisma.BookingCreateManyConfirmedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => BookingCreateManyConfirmedByInputSchema),
        z.lazy(() => BookingCreateManyConfirmedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CommunicationPreferenceCreateWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.string().optional().nullable(),
      whatsappNumber: z.string().optional().nullable(),
      reminderHours: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.string().optional().nullable(),
      whatsappNumber: z.string().optional().nullable(),
      reminderHours: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CommunicationPreferenceCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema),
        z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const CommunicationPreferenceCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.CommunicationPreferenceCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CommunicationPreferenceCreateManyUserInputSchema),
        z.lazy(() => CommunicationPreferenceCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipCreateWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutMembershipsInputSchema),
      invitation: z
        .lazy(() => OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateWithoutUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateOrConnectWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateOrConnectWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipCreateManyUserInputEnvelopeSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyUserInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationMembershipCreateManyUserInputSchema),
        z.lazy(() => OrganizationMembershipCreateManyUserInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateWithoutChangedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      membership: z.lazy(() => OrganizationMembershipCreateNestedOneWithoutHistoryInputSchema),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      membershipId: z.string(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateOrConnectWithoutChangedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyChangedByInputEnvelopeSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyChangedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationMembershipHistoryCreateManyChangedByInputSchema),
        z.lazy(() => OrganizationMembershipHistoryCreateManyChangedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutCreatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutCreatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyCreatedByInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyCreatedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyCreatedByInputSchema),
        z.lazy(() => AvailabilityCreateManyCreatedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutAcceptedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutAcceptedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutAcceptedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyAcceptedByInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyAcceptedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyAcceptedByInputSchema),
        z.lazy(() => AvailabilityCreateManyAcceptedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationCreateWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutApprovedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutApprovedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationCreateManyApprovedByInputEnvelopeSchema: z.ZodType<Prisma.OrganizationCreateManyApprovedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationCreateManyApprovedByInputSchema),
        z.lazy(() => OrganizationCreateManyApprovedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderCreateWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutApprovedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutApprovedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateManyApprovedByInputEnvelopeSchema: z.ZodType<Prisma.ServiceProviderCreateManyApprovedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ServiceProviderCreateManyApprovedByInputSchema),
        z.lazy(() => ServiceProviderCreateManyApprovedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationInvitationCreateWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateWithoutInvitedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutInvitationsInputSchema),
      membership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutInvitationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateWithoutInvitedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      membershipId: z.string().optional().nullable(),
    })
    .strict();

export const OrganizationInvitationCreateOrConnectWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateOrConnectWithoutInvitedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationCreateManyInvitedByInputEnvelopeSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyInvitedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationInvitationCreateManyInvitedByInputSchema),
        z.lazy(() => OrganizationInvitationCreateManyInvitedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ReviewCreateWithoutClientInputSchema: z.ZodType<Prisma.ReviewCreateWithoutClientInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutReviewsInputSchema),
      booking: z.lazy(() => BookingCreateNestedOneWithoutReviewInputSchema),
    })
    .strict();

export const ReviewUncheckedCreateWithoutClientInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateWithoutClientInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      bookingId: z.string(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ReviewCreateOrConnectWithoutClientInputSchema: z.ZodType<Prisma.ReviewCreateOrConnectWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ReviewCreateWithoutClientInputSchema),
        z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema),
      ]),
    })
    .strict();

export const ReviewCreateManyClientInputEnvelopeSchema: z.ZodType<Prisma.ReviewCreateManyClientInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ReviewCreateManyClientInputSchema),
        z.lazy(() => ReviewCreateManyClientInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementSubmissionCreateWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateWithoutValidatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirementType: z.lazy(() => RequirementTypeCreateNestedOneWithoutSubmissionsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutRequirementSubmissionsInputSchema
      ),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateWithoutValidatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      requirementTypeId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionCreateOrConnectWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateOrConnectWithoutValidatedByInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionCreateManyValidatedByInputEnvelopeSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyValidatedByInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RequirementSubmissionCreateManyValidatedByInputSchema),
        z.lazy(() => RequirementSubmissionCreateManyValidatedByInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AccountUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AccountCreateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AccountUpdateWithoutUserInputSchema),
        z.lazy(() => AccountUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => AccountScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AccountUpdateManyMutationInputSchema),
        z.lazy(() => AccountUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const AccountScalarWhereInputSchema: z.ZodType<Prisma.AccountScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => AccountScalarWhereInputSchema),
        z.lazy(() => AccountScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => AccountScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => AccountScalarWhereInputSchema),
        z.lazy(() => AccountScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    type: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    provider: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    providerAccountId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    refresh_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    access_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    expires_at: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    token_type: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    scope: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    id_token: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    session_state: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
  })
  .strict();

export const ServiceProviderUpsertWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutUserInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutUserInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutUserInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutUserInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutUserInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUpsertWithWhereUniqueWithoutClientInputSchema: z.ZodType<Prisma.BookingUpsertWithWhereUniqueWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => BookingUpdateWithoutClientInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutClientInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutClientInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutClientInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithWhereUniqueWithoutClientInputSchema: z.ZodType<Prisma.BookingUpdateWithWhereUniqueWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutClientInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutClientInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateManyWithWhereWithoutClientInputSchema: z.ZodType<Prisma.BookingUpdateManyWithWhereWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => BookingScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateManyMutationInputSchema),
        z.lazy(() => BookingUncheckedUpdateManyWithoutClientInputSchema),
      ]),
    })
    .strict();

export const BookingScalarWhereInputSchema: z.ZodType<Prisma.BookingScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => BookingScalarWhereInputSchema),
        z.lazy(() => BookingScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => BookingScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => BookingScalarWhereInputSchema),
        z.lazy(() => BookingScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slotId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdByMembershipId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isProviderCreated: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    isGuestBooking: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    isGuestSelfBooking: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    confirmedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    confirmedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    clientId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestName: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestEmail: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestPhone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    guestWhatsapp: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    price: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    isOnline: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    isInPerson: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    status: z
      .union([z.lazy(() => EnumBookingStatusFilterSchema), z.lazy(() => BookingStatusSchema)])
      .optional(),
    notes: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    meetLink: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    calendarEventId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const BookingUpsertWithWhereUniqueWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUpsertWithWhereUniqueWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => BookingUpdateWithoutCreatedByInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutCreatedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutCreatedByInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithWhereUniqueWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUpdateWithWhereUniqueWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutCreatedByInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateManyWithWhereWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUpdateManyWithWhereWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => BookingScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateManyMutationInputSchema),
        z.lazy(() => BookingUncheckedUpdateManyWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const BookingUpsertWithWhereUniqueWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUpsertWithWhereUniqueWithoutConfirmedByInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => BookingUpdateWithoutConfirmedByInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutConfirmedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutConfirmedByInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutConfirmedByInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithWhereUniqueWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUpdateWithWhereUniqueWithoutConfirmedByInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutConfirmedByInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutConfirmedByInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateManyWithWhereWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUpdateManyWithWhereWithoutConfirmedByInput> =
  z
    .object({
      where: z.lazy(() => BookingScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateManyMutationInputSchema),
        z.lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByInputSchema),
      ]),
    })
    .strict();

export const CommunicationPreferenceUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CommunicationPreferenceUpdateWithoutUserInputSchema),
        z.lazy(() => CommunicationPreferenceUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CommunicationPreferenceCreateWithoutUserInputSchema),
        z.lazy(() => CommunicationPreferenceUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const CommunicationPreferenceUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommunicationPreferenceWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CommunicationPreferenceUpdateWithoutUserInputSchema),
        z.lazy(() => CommunicationPreferenceUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const CommunicationPreferenceUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => CommunicationPreferenceScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CommunicationPreferenceUpdateManyMutationInputSchema),
        z.lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const CommunicationPreferenceScalarWhereInputSchema: z.ZodType<Prisma.CommunicationPreferenceScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema),
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CommunicationPreferenceScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema),
          z.lazy(() => CommunicationPreferenceScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      sms: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      whatsapp: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      phoneNumber: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      reminderHours: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const OrganizationMembershipUpsertWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUpsertWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutUserInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutUserInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutUserInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateWithWhereUniqueWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithWhereUniqueWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutUserInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutUserInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateManyWithWhereWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateManyWithWhereWithoutUserInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipScalarWhereInputSchema: z.ZodType<Prisma.OrganizationMembershipScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationMembershipScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      role: z
        .union([
          z.lazy(() => EnumOrganizationRoleFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional(),
      permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      status: z
        .union([
          z.lazy(() => EnumMembershipStatusFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutChangedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationMembershipHistoryUpdateWithoutChangedByInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedUpdateWithoutChangedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipHistoryCreateWithoutChangedByInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutChangedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutChangedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipHistoryUpdateWithoutChangedByInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedUpdateWithoutChangedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateManyWithWhereWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateManyWithWhereWithoutChangedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipHistoryUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryScalarWhereInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
          z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      membershipId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      changeType: z
        .union([
          z.lazy(() => EnumMembershipChangeTypeFilterSchema),
          z.lazy(() => MembershipChangeTypeSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => EnumOrganizationRoleNullableFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => EnumOrganizationRoleNullableFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      newPermissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      oldStatus: z
        .union([
          z.lazy(() => EnumMembershipStatusNullableFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => EnumMembershipStatusNullableFilterSchema),
          z.lazy(() => MembershipStatusSchema),
        ])
        .optional()
        .nullable(),
      changedById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      changeReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutCreatedByInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutCreatedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutCreatedByInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutCreatedByInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutCreatedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityScalarWhereInputSchema: z.ZodType<Prisma.AvailabilityScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => AvailabilityScalarWhereInputSchema),
        z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => AvailabilityScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => AvailabilityScalarWhereInputSchema),
        z.lazy(() => AvailabilityScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    organizationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    locationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    connectionId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    createdById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    createdByMembershipId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isProviderCreated: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    status: z
      .union([
        z.lazy(() => EnumAvailabilityStatusFilterSchema),
        z.lazy(() => AvailabilityStatusSchema),
      ])
      .optional(),
    acceptedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    acceptedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    requiresConfirmation: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    billingEntity: z
      .union([
        z.lazy(() => EnumBillingEntityNullableFilterSchema),
        z.lazy(() => BillingEntitySchema),
      ])
      .optional()
      .nullable(),
    defaultSubscriptionId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutAcceptedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutAcceptedByInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutAcceptedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutAcceptedByInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutAcceptedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutAcceptedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutAcceptedByInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutAcceptedByInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutAcceptedByInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpsertWithWhereUniqueWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUpsertWithWhereUniqueWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutApprovedByInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutApprovedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutApprovedByInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithWhereUniqueWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUpdateWithWhereUniqueWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutApprovedByInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateManyWithWhereWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUpdateManyWithWhereWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationScalarWhereInputSchema: z.ZodType<Prisma.OrganizationScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => OrganizationScalarWhereInputSchema),
        z.lazy(() => OrganizationScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => OrganizationScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => OrganizationScalarWhereInputSchema),
        z.lazy(() => OrganizationScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    website: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    logo: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => EnumOrganizationStatusFilterSchema),
        z.lazy(() => OrganizationStatusSchema),
      ])
      .optional(),
    approvedById: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    approvedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    rejectedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    rejectionReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    billingModel: z
      .union([
        z.lazy(() => EnumOrganizationBillingModelFilterSchema),
        z.lazy(() => OrganizationBillingModelSchema),
      ])
      .optional(),
    trialStarted: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialEnded: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialStatus: z
      .union([z.lazy(() => EnumTrialStatusNullableFilterSchema), z.lazy(() => TrialStatusSchema)])
      .optional()
      .nullable(),
    paymentMethodAdded: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialReminderSent: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialConversionDate: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
  })
  .strict();

export const ServiceProviderUpsertWithWhereUniqueWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithWhereUniqueWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutApprovedByInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutApprovedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutApprovedByInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithWhereUniqueWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithWhereUniqueWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutApprovedByInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateManyWithWhereWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyWithWhereWithoutApprovedByInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateManyMutationInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderScalarWhereInputSchema: z.ZodType<Prisma.ServiceProviderScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceProviderScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceProviderScalarWhereInputSchema),
          z.lazy(() => ServiceProviderScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      userId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      bio: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      image: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      languages: z.lazy(() => EnumLanguagesNullableListFilterSchema).optional(),
      website: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      whatsapp: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumServiceProviderStatusFilterSchema),
          z.lazy(() => ServiceProviderStatusSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      averageRating: z
        .union([z.lazy(() => FloatNullableFilterSchema), z.number()])
        .optional()
        .nullable(),
      totalReviews: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      trialStarted: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      trialStatus: z
        .union([z.lazy(() => EnumTrialStatusNullableFilterSchema), z.lazy(() => TrialStatusSchema)])
        .optional()
        .nullable(),
      paymentMethodAdded: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      trialReminderSent: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      trialConversionDate: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    })
    .strict();

export const OrganizationInvitationUpsertWithWhereUniqueWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUpsertWithWhereUniqueWithoutInvitedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationInvitationUpdateWithoutInvitedByInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutInvitedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationInvitationCreateWithoutInvitedByInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedCreateWithoutInvitedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationUpdateWithWhereUniqueWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateWithWhereUniqueWithoutInvitedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationInvitationUpdateWithoutInvitedByInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutInvitedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationUpdateManyWithWhereWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateManyWithWhereWithoutInvitedByInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationInvitationUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationScalarWhereInputSchema: z.ZodType<Prisma.OrganizationInvitationScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationInvitationScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
          z.lazy(() => OrganizationInvitationScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      email: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      role: z
        .union([
          z.lazy(() => EnumOrganizationRoleFilterSchema),
          z.lazy(() => OrganizationRoleSchema),
        ])
        .optional(),
      permissions: z.lazy(() => EnumOrganizationPermissionNullableListFilterSchema).optional(),
      token: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      expiresAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      invitedById: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumInvitationStatusFilterSchema),
          z.lazy(() => InvitationStatusSchema),
        ])
        .optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
    })
    .strict();

export const ReviewUpsertWithWhereUniqueWithoutClientInputSchema: z.ZodType<Prisma.ReviewUpsertWithWhereUniqueWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ReviewUpdateWithoutClientInputSchema),
        z.lazy(() => ReviewUncheckedUpdateWithoutClientInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ReviewCreateWithoutClientInputSchema),
        z.lazy(() => ReviewUncheckedCreateWithoutClientInputSchema),
      ]),
    })
    .strict();

export const ReviewUpdateWithWhereUniqueWithoutClientInputSchema: z.ZodType<Prisma.ReviewUpdateWithWhereUniqueWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ReviewUpdateWithoutClientInputSchema),
        z.lazy(() => ReviewUncheckedUpdateWithoutClientInputSchema),
      ]),
    })
    .strict();

export const ReviewUpdateManyWithWhereWithoutClientInputSchema: z.ZodType<Prisma.ReviewUpdateManyWithWhereWithoutClientInput> =
  z
    .object({
      where: z.lazy(() => ReviewScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ReviewUpdateManyMutationInputSchema),
        z.lazy(() => ReviewUncheckedUpdateManyWithoutClientInputSchema),
      ]),
    })
    .strict();

export const ReviewScalarWhereInputSchema: z.ZodType<Prisma.ReviewScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ReviewScalarWhereInputSchema),
        z.lazy(() => ReviewScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => ReviewScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ReviewScalarWhereInputSchema),
        z.lazy(() => ReviewScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    clientId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    bookingId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    rating: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    comment: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    response: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    isPublic: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    googleReviewId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([z.lazy(() => EnumReviewStatusFilterSchema), z.lazy(() => ReviewStatusSchema)])
      .optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const RequirementSubmissionUpsertWithWhereUniqueWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUpsertWithWhereUniqueWithoutValidatedByInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RequirementSubmissionUpdateWithoutValidatedByInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateWithoutValidatedByInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RequirementSubmissionCreateWithoutValidatedByInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedCreateWithoutValidatedByInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpdateWithWhereUniqueWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateWithWhereUniqueWithoutValidatedByInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RequirementSubmissionUpdateWithoutValidatedByInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateWithoutValidatedByInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpdateManyWithWhereWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyWithWhereWithoutValidatedByInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RequirementSubmissionUpdateManyMutationInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionScalarWhereInputSchema: z.ZodType<Prisma.RequirementSubmissionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RequirementSubmissionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
          z.lazy(() => RequirementSubmissionScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      requirementTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumRequirementsValidationStatusFilterSchema),
          z.lazy(() => RequirementsValidationStatusSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      documentMetadata: z.lazy(() => JsonNullableFilterSchema).optional(),
      expiresAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      notes: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const UserCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateWithoutAccountsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAccountsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutAccountsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
      ]),
    })
    .strict();

export const UserUpsertWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpsertWithoutAccountsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAccountsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAccountsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAccountsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAccountsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUpdateWithoutAccountsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutAccountsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAccountsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeCreateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeCreateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      submissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutRequirementTypeInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedCreateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      submissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutRequirementTypeInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeCreateOrConnectWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeCreateOrConnectWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementTypeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeCreateManyServiceProviderTypeInputEnvelopeSchema: z.ZodType<Prisma.RequirementTypeCreateManyServiceProviderTypeInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RequirementTypeCreateManyServiceProviderTypeInputSchema),
        z.lazy(() => RequirementTypeCreateManyServiceProviderTypeInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceCreateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceCreateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      providers: z.lazy(() => ServiceProviderCreateNestedManyWithoutServicesInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      providers: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServicesInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceCreateOrConnectWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceCreateOrConnectWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceCreateManyServiceProviderTypeInputEnvelopeSchema: z.ZodType<Prisma.ServiceCreateManyServiceProviderTypeInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ServiceCreateManyServiceProviderTypeInputSchema),
        z.lazy(() => ServiceCreateManyServiceProviderTypeInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderCreateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateManyServiceProviderTypeInputEnvelopeSchema: z.ZodType<Prisma.ServiceProviderCreateManyServiceProviderTypeInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ServiceProviderCreateManyServiceProviderTypeInputSchema),
        z.lazy(() => ServiceProviderCreateManyServiceProviderTypeInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementTypeUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUpsertWithWhereUniqueWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementTypeWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RequirementTypeUpdateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => RequirementTypeUncheckedUpdateWithoutServiceProviderTypeInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RequirementTypeCreateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => RequirementTypeUncheckedCreateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUpdateWithWhereUniqueWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementTypeWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RequirementTypeUpdateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => RequirementTypeUncheckedUpdateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeUpdateManyWithWhereWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUpdateManyWithWhereWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementTypeScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RequirementTypeUpdateManyMutationInputSchema),
        z.lazy(() => RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeScalarWhereInputSchema: z.ZodType<Prisma.RequirementTypeScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => RequirementTypeScalarWhereInputSchema),
          z.lazy(() => RequirementTypeScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => RequirementTypeScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => RequirementTypeScalarWhereInputSchema),
          z.lazy(() => RequirementTypeScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      description: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      isRequired: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      validationType: z
        .union([
          z.lazy(() => EnumRequirementValidationTypeFilterSchema),
          z.lazy(() => RequirementValidationTypeSchema),
        ])
        .optional(),
      validationConfig: z.lazy(() => JsonNullableFilterSchema).optional(),
      displayPriority: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const ServiceUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUpsertWithWhereUniqueWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceUpdateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutServiceProviderTypeInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUpdateWithWhereUniqueWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceUpdateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceUpdateManyWithWhereWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUpdateManyWithWhereWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceUpdateManyMutationInputSchema),
        z.lazy(() => ServiceUncheckedUpdateManyWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceScalarWhereInputSchema: z.ZodType<Prisma.ServiceScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => ServiceScalarWhereInputSchema),
        z.lazy(() => ServiceScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => ServiceScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => ServiceScalarWhereInputSchema),
        z.lazy(() => ServiceScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    description: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    serviceProviderTypeId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    displayPriority: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    defaultDuration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    defaultPrice: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const ServiceProviderUpsertWithWhereUniqueWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithWhereUniqueWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutServiceProviderTypeInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithWhereUniqueWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithWhereUniqueWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutServiceProviderTypeInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateManyWithWhereWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyWithWhereWithoutServiceProviderTypeInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateManyMutationInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutServiceProviderInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderTypeCreateWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateWithoutServiceProvidersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirements: z
        .lazy(() => RequirementTypeCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedCreateWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedCreateWithoutServiceProvidersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirements: z
        .lazy(() => RequirementTypeUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateOrConnectWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateOrConnectWithoutServiceProvidersInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderTypeCreateWithoutServiceProvidersInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServiceProvidersInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserCreateWithoutProvidersApprovedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutProvidersApprovedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutProvidersApprovedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutProvidersApprovedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutProvidersApprovedInputSchema),
      ]),
    })
    .strict();

export const ReviewCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutReviewsInputSchema),
      booking: z.lazy(() => BookingCreateNestedOneWithoutReviewInputSchema),
    })
    .strict();

export const ReviewUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      clientId: z.string(),
      bookingId: z.string(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ReviewCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema),
        z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ReviewCreateManyServiceProviderInputEnvelopeSchema: z.ZodType<Prisma.ReviewCreateManyServiceProviderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ReviewCreateManyServiceProviderInputSchema),
        z.lazy(() => ReviewCreateManyServiceProviderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementSubmissionCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirementType: z.lazy(() => RequirementTypeCreateNestedOneWithoutSubmissionsInputSchema),
      validatedBy: z
        .lazy(() => UserCreateNestedOneWithoutValidatedRequirementsInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      requirementTypeId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      validatedById: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionCreateManyServiceProviderInputEnvelopeSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyServiceProviderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RequirementSubmissionCreateManyServiceProviderInputSchema),
        z.lazy(() => RequirementSubmissionCreateManyServiceProviderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceCreateWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceCreateWithoutProvidersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServicesInputSchema
      ),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedCreateWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateWithoutProvidersInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      serviceProviderTypeId: z.string(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceCreateOrConnectWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceCreateOrConnectWithoutProvidersInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutProvidersInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      service: z.lazy(() => ServiceCreateNestedOneWithoutAvailabilityConfigsInputSchema),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceConfigInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceConfigInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyServiceProviderInputEnvelopeSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyServiceProviderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateManyServiceProviderInputSchema),
        z.lazy(() => ServiceAvailabilityConfigCreateManyServiceProviderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyServiceProviderInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyServiceProviderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyServiceProviderInputSchema),
        z.lazy(() => AvailabilityCreateManyServiceProviderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarIntegrationCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calendarEvents: z
        .lazy(() => CalendarEventCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
      syncOperations: z
        .lazy(() => CalendarSyncOperationCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
      syncOperations: z
        .lazy(
          () => CalendarSyncOperationUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalendarIntegrationCreateWithoutServiceProviderInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutProviderConnectionsInputSchema),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutProviderConnectionInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutProviderConnectionInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema),
        z.lazy(
          () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
        ),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyServiceProviderInputEnvelopeSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyServiceProviderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateManyServiceProviderInputSchema),
        z.lazy(() => OrganizationProviderConnectionCreateManyServiceProviderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SubscriptionCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateManyServiceProviderInputEnvelopeSchema: z.ZodType<Prisma.SubscriptionCreateManyServiceProviderInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriptionCreateManyServiceProviderInputSchema),
        z.lazy(() => SubscriptionCreateManyServiceProviderInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UserUpsertWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserUpsertWithoutServiceProviderInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutServiceProviderInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUpsertWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpsertWithoutServiceProvidersInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderTypeUpdateWithoutServiceProvidersInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutServiceProvidersInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderTypeCreateWithoutServiceProvidersInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServiceProvidersInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateToOneWithWhereWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateToOneWithWhereWithoutServiceProvidersInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderTypeUpdateWithoutServiceProvidersInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutServiceProvidersInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderTypeUpdateWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateWithoutServiceProvidersInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirements: z
        .lazy(() => RequirementTypeUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedUpdateWithoutServiceProvidersInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedUpdateWithoutServiceProvidersInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirements: z
        .lazy(() => RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserUpsertWithoutProvidersApprovedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutProvidersApprovedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutProvidersApprovedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutProvidersApprovedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutProvidersApprovedInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutProvidersApprovedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutProvidersApprovedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutProvidersApprovedInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserUpdateWithoutProvidersApprovedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutProvidersApprovedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutProvidersApprovedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const ReviewUpsertWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUpsertWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ReviewUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => ReviewUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ReviewCreateWithoutServiceProviderInputSchema),
        z.lazy(() => ReviewUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ReviewUpdateWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUpdateWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ReviewUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => ReviewUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ReviewUpdateManyWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUpdateManyWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ReviewScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ReviewUpdateManyMutationInputSchema),
        z.lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpsertWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUpsertWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RequirementSubmissionUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RequirementSubmissionCreateWithoutServiceProviderInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpdateWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RequirementSubmissionUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpdateManyWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RequirementSubmissionUpdateManyMutationInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ServiceUpsertWithWhereUniqueWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUpsertWithWhereUniqueWithoutProvidersInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceUpdateWithoutProvidersInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutProvidersInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutProvidersInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutProvidersInputSchema),
      ]),
    })
    .strict();

export const ServiceUpdateWithWhereUniqueWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUpdateWithWhereUniqueWithoutProvidersInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceUpdateWithoutProvidersInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutProvidersInputSchema),
      ]),
    })
    .strict();

export const ServiceUpdateManyWithWhereWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUpdateManyWithWhereWithoutProvidersInput> =
  z
    .object({
      where: z.lazy(() => ServiceScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceUpdateManyMutationInputSchema),
        z.lazy(() => ServiceUncheckedUpdateManyWithoutProvidersInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceProviderInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateManyMutationInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigScalarWhereInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
          z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      duration: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      price: z
        .union([
          z.lazy(() => DecimalFilterSchema),
          z
            .union([
              z.number(),
              z.string(),
              z.instanceof(Decimal),
              z.instanceof(Prisma.Decimal),
              DecimalJsLikeSchema,
            ])
            .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
        ])
        .optional(),
      isOnlineAvailable: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      isInPerson: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      location: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutServiceProviderInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const CalendarIntegrationUpsertWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationUpsertWithoutServiceProviderInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CalendarIntegrationUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalendarIntegrationCreateWithoutServiceProviderInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
      where: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
    })
    .strict();

export const CalendarIntegrationUpdateToOneWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateToOneWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CalendarIntegrationUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const CalendarIntegrationUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      syncOperations: z
        .lazy(() => CalendarSyncOperationUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      syncOperations: z
        .lazy(
          () => CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpsertWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpsertWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateWithoutServiceProviderInputSchema),
        z.lazy(
          () => OrganizationProviderConnectionUncheckedUpdateWithoutServiceProviderInputSchema
        ),
      ]),
      create: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateWithoutServiceProviderInputSchema),
        z.lazy(
          () => OrganizationProviderConnectionUncheckedCreateWithoutServiceProviderInputSchema
        ),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpdateWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateWithoutServiceProviderInputSchema),
        z.lazy(
          () => OrganizationProviderConnectionUncheckedUpdateWithoutServiceProviderInputSchema
        ),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpdateManyWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateManyWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateManyMutationInputSchema),
        z.lazy(
          () => OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderInputSchema
        ),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionScalarWhereInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => OrganizationProviderConnectionScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
          z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z
        .union([
          z.lazy(() => EnumConnectionStatusFilterSchema),
          z.lazy(() => ConnectionStatusSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([z.lazy(() => EnumBillingEntityFilterSchema), z.lazy(() => BillingEntitySchema)])
        .optional(),
      requestedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      acceptedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict();

export const SubscriptionUpsertWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutServiceProviderInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithWhereUniqueWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithWhereUniqueWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutServiceProviderInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateManyWithWhereWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithWhereWithoutServiceProviderInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateManyMutationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderInputSchema),
      ]),
    })
    .strict();

export const SubscriptionScalarWhereInputSchema: z.ZodType<Prisma.SubscriptionScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => SubscriptionScalarWhereInputSchema),
        z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => SubscriptionScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => SubscriptionScalarWhereInputSchema),
        z.lazy(() => SubscriptionScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    organizationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    locationId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    serviceProviderId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    status: z
      .union([
        z.lazy(() => EnumSubscriptionStatusFilterSchema),
        z.lazy(() => SubscriptionStatusSchema),
      ])
      .optional(),
    type: z
      .union([z.lazy(() => EnumSubscriptionTypeFilterSchema), z.lazy(() => SubscriptionTypeSchema)])
      .optional(),
    planId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    isActive: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    trialStart: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    trialEnd: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    startDate: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    endDate: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    cancelledAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    cancelReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    stripeCustomerId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    stripeSubscriptionId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    currentMonthSlots: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    billingCycleStart: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    billingCycleEnd: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const UserCreateWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserCreateWithoutOrganizationsApprovedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutOrganizationsApprovedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutOrganizationsApprovedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutOrganizationsApprovedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOrganizationsApprovedInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateManyOrganizationInputEnvelopeSchema: z.ZodType<Prisma.SubscriptionCreateManyOrganizationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriptionCreateManyOrganizationInputSchema),
        z.lazy(() => SubscriptionCreateManyOrganizationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationInvitationCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      invitedBy: z.lazy(() => UserCreateNestedOneWithoutSentInvitationsInputSchema),
      membership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutInvitationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      invitedById: z.string(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      membershipId: z.string().optional().nullable(),
    })
    .strict();

export const OrganizationInvitationCreateOrConnectWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateOrConnectWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationCreateManyOrganizationInputEnvelopeSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyOrganizationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationInvitationCreateManyOrganizationInputSchema),
        z.lazy(() => OrganizationInvitationCreateManyOrganizationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutOrganizationMembershipsInputSchema),
      invitation: z
        .lazy(() => OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateOrConnectWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateOrConnectWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipCreateManyOrganizationInputEnvelopeSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyOrganizationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationMembershipCreateManyOrganizationInputSchema),
        z.lazy(() => OrganizationMembershipCreateManyOrganizationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutProviderConnectionsInputSchema
      ),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutProviderConnectionInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutProviderConnectionInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateOrConnectWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyOrganizationInputEnvelopeSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyOrganizationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateManyOrganizationInputSchema),
        z.lazy(() => OrganizationProviderConnectionCreateManyOrganizationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const LocationCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutLocationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutLocationInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUncheckedCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutLocationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutLocationInputSchema)
        .optional(),
    })
    .strict();

export const LocationCreateOrConnectWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationCreateOrConnectWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LocationCreateWithoutOrganizationInputSchema),
        z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const LocationCreateManyOrganizationInputEnvelopeSchema: z.ZodType<Prisma.LocationCreateManyOrganizationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => LocationCreateManyOrganizationInputSchema),
        z.lazy(() => LocationCreateManyOrganizationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyOrganizationInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyOrganizationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyOrganizationInputSchema),
        z.lazy(() => AvailabilityCreateManyOrganizationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UserUpsertWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserUpsertWithoutOrganizationsApprovedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutOrganizationsApprovedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOrganizationsApprovedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutOrganizationsApprovedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOrganizationsApprovedInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutOrganizationsApprovedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutOrganizationsApprovedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOrganizationsApprovedInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserUpdateWithoutOrganizationsApprovedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutOrganizationsApprovedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutOrganizationsApprovedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUpsertWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutOrganizationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutOrganizationInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutOrganizationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateManyWithWhereWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithWhereWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateManyMutationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUpsertWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationInvitationUpdateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationInvitationCreateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationInvitationUpdateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateManyWithWhereWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationInvitationUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpsertWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateManyWithWhereWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpsertWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpsertWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpdateWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateWithoutOrganizationInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpdateManyWithWhereWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateManyWithWhereWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateManyMutationInputSchema),
        z.lazy(
          () => OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationInputSchema
        ),
      ]),
    })
    .strict();

export const LocationUpsertWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUpsertWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => LocationUpdateWithoutOrganizationInputSchema),
        z.lazy(() => LocationUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => LocationCreateWithoutOrganizationInputSchema),
        z.lazy(() => LocationUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const LocationUpdateWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUpdateWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => LocationUpdateWithoutOrganizationInputSchema),
        z.lazy(() => LocationUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const LocationUpdateManyWithWhereWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUpdateManyWithWhereWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => LocationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => LocationUpdateManyMutationInputSchema),
        z.lazy(() => LocationUncheckedUpdateManyWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const LocationScalarWhereInputSchema: z.ZodType<Prisma.LocationScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => LocationScalarWhereInputSchema),
        z.lazy(() => LocationScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => LocationScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => LocationScalarWhereInputSchema),
        z.lazy(() => LocationScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    organizationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    name: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    googlePlaceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    formattedAddress: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    coordinates: z.lazy(() => JsonFilterSchema).optional(),
    addressComponents: z.lazy(() => JsonFilterSchema).optional(),
    city: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    country: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    phone: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    email: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutOrganizationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutOrganizationInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutOrganizationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutOrganizationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationInputSchema),
      ]),
    })
    .strict();

export const OrganizationCreateWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutInvitationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      approvedBy: z
        .lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutInvitationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutInvitationsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutInvitationsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutInvitationsInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserCreateWithoutSentInvitationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutSentInvitationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutSentInvitationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutSentInvitationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSentInvitationsInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipCreateWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateWithoutInvitationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutMembershipsInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutOrganizationMembershipsInputSchema),
      bookingsCreated: z
        .lazy(() => BookingCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateWithoutInvitationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateOrConnectWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateOrConnectWithoutInvitationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutInvitationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutInvitationInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpsertWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationUpsertWithoutInvitationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutInvitationsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutInvitationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutInvitationsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutInvitationsInputSchema),
      ]),
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationUpdateToOneWithWhereWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationUpdateToOneWithWhereWithoutInvitationsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutInvitationsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutInvitationsInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutInvitationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedBy: z
        .lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutInvitationsInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutInvitationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserUpsertWithoutSentInvitationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutSentInvitationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSentInvitationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutSentInvitationsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutSentInvitationsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutSentInvitationsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutSentInvitationsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutSentInvitationsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserUpdateWithoutSentInvitationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutSentInvitationsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutSentInvitationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpsertWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpsertWithoutInvitationInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutInvitationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutInvitationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutInvitationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutInvitationInputSchema),
      ]),
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipUpdateToOneWithWhereWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateToOneWithWhereWithoutInvitationInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutInvitationInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutInvitationInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithoutInvitationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateWithoutInvitationInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateWithoutInvitationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationCreateWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutMembershipsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      approvedBy: z
        .lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutMembershipsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutMembershipsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutMembershipsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutMembershipsInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserCreateWithoutOrganizationMembershipsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutOrganizationMembershipsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutOrganizationMembershipsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutOrganizationMembershipsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOrganizationMembershipsInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationCreateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateWithoutMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutInvitationsInputSchema),
      invitedBy: z.lazy(() => UserCreateNestedOneWithoutSentInvitationsInputSchema),
    })
    .strict();

export const OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedCreateWithoutMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      invitedById: z.string(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const OrganizationInvitationCreateOrConnectWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateOrConnectWithoutMembershipInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationInvitationCreateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema),
      ]),
    })
    .strict();

export const BookingCreateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingCreateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const BookingCreateManyCreatedByMembershipInputEnvelopeSchema: z.ZodType<Prisma.BookingCreateManyCreatedByMembershipInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => BookingCreateManyCreatedByMembershipInputSchema),
        z.lazy(() => BookingCreateManyCreatedByMembershipInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyCreatedByMembershipInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyCreatedByMembershipInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyCreatedByMembershipInputSchema),
        z.lazy(() => AvailabilityCreateManyCreatedByMembershipInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateWithoutMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      changedBy: z.lazy(() => UserCreateNestedOneWithoutMembershipHistoryChangesInputSchema),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changedById: z.string(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateOrConnectWithoutMembershipInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyMembershipInputEnvelopeSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyMembershipInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => OrganizationMembershipHistoryCreateManyMembershipInputSchema),
        z.lazy(() => OrganizationMembershipHistoryCreateManyMembershipInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationUpsertWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationUpsertWithoutMembershipsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutMembershipsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutMembershipsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutMembershipsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutMembershipsInputSchema),
      ]),
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationUpdateToOneWithWhereWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationUpdateToOneWithWhereWithoutMembershipsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutMembershipsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutMembershipsInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutMembershipsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedBy: z
        .lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutMembershipsInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutMembershipsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserUpsertWithoutOrganizationMembershipsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutOrganizationMembershipsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOrganizationMembershipsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutOrganizationMembershipsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutOrganizationMembershipsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutOrganizationMembershipsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutOrganizationMembershipsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutOrganizationMembershipsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserUpdateWithoutOrganizationMembershipsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutOrganizationMembershipsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutOrganizationMembershipsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUpsertWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationUpsertWithoutMembershipInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationInvitationUpdateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutMembershipInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationInvitationCreateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedCreateWithoutMembershipInputSchema),
      ]),
      where: z.lazy(() => OrganizationInvitationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationInvitationUpdateToOneWithWhereWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateToOneWithWhereWithoutMembershipInput> =
  z
    .object({
      where: z.lazy(() => OrganizationInvitationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationInvitationUpdateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationInvitationUncheckedUpdateWithoutMembershipInputSchema),
      ]),
    })
    .strict();

export const OrganizationInvitationUpdateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateWithoutMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutInvitationsNestedInputSchema)
        .optional(),
      invitedBy: z
        .lazy(() => UserUpdateOneRequiredWithoutSentInvitationsNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateWithoutMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const BookingUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUpsertWithWhereUniqueWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => BookingUpdateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutCreatedByMembershipInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUpdateWithWhereUniqueWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateManyWithWhereWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUpdateManyWithWhereWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => BookingScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => BookingUpdateManyMutationInputSchema),
        z.lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutCreatedByMembershipInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutCreatedByMembershipInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutCreatedByMembershipInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpsertWithWhereUniqueWithoutMembershipInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => OrganizationMembershipHistoryUpdateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedUpdateWithoutMembershipInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipHistoryCreateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedCreateWithoutMembershipInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateWithWhereUniqueWithoutMembershipInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipHistoryUpdateWithoutMembershipInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedUpdateWithoutMembershipInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateManyWithWhereWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateManyWithWhereWithoutMembershipInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipHistoryScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => OrganizationMembershipHistoryUpdateManyMutationInputSchema),
        z.lazy(() => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipCreateWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateWithoutHistoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutMembershipsInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutOrganizationMembershipsInputSchema),
      invitation: z
        .lazy(() => OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateWithoutHistoryInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateOrConnectWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateOrConnectWithoutHistoryInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutHistoryInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutHistoryInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserCreateWithoutMembershipHistoryChangesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutMembershipHistoryChangesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutMembershipHistoryChangesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutMembershipHistoryChangesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutMembershipHistoryChangesInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpsertWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipUpsertWithoutHistoryInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutHistoryInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutHistoryInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutHistoryInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutHistoryInputSchema),
      ]),
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipUpdateToOneWithWhereWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateToOneWithWhereWithoutHistoryInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutHistoryInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutHistoryInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithoutHistoryInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema)
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateWithoutHistoryInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateWithoutHistoryInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserUpsertWithoutMembershipHistoryChangesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutMembershipHistoryChangesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutMembershipHistoryChangesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutMembershipHistoryChangesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutMembershipHistoryChangesInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutMembershipHistoryChangesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutMembershipHistoryChangesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutMembershipHistoryChangesInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserUpdateWithoutMembershipHistoryChangesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutMembershipHistoryChangesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutMembershipHistoryChangesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutLocationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      approvedBy: z
        .lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutLocationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutLocationsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutLocationsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutLocationsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutLocationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutLocationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutLocationInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateManyLocationInputEnvelopeSchema: z.ZodType<Prisma.SubscriptionCreateManyLocationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriptionCreateManyLocationInputSchema),
        z.lazy(() => SubscriptionCreateManyLocationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutLocationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutLocationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutLocationInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyLocationInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyLocationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyLocationInputSchema),
        z.lazy(() => AvailabilityCreateManyLocationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationUpsertWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationUpsertWithoutLocationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutLocationsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutLocationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutLocationsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutLocationsInputSchema),
      ]),
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationUpdateToOneWithWhereWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationUpdateToOneWithWhereWithoutLocationsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutLocationsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutLocationsInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutLocationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedBy: z
        .lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutLocationsInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutLocationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUpsertWithWhereUniqueWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithWhereUniqueWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutLocationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutLocationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutLocationInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithWhereUniqueWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithWhereUniqueWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutLocationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateManyWithWhereWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithWhereWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateManyMutationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateManyWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutLocationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutLocationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutLocationInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutLocationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutLocationInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutLocationInputSchema),
      ]),
    })
    .strict();

export const OrganizationCreateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      approvedBy: z
        .lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutProviderConnectionsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutProviderConnectionsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutProviderConnectionsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutProviderConnectionsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutProviderConnectionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutProviderConnectionsInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutProviderConnectionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutProviderConnectionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutProviderConnectionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyProviderConnectionInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyProviderConnectionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyProviderConnectionInputSchema),
        z.lazy(() => AvailabilityCreateManyProviderConnectionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationUpsertWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationUpsertWithoutProviderConnectionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutProviderConnectionsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutProviderConnectionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutProviderConnectionsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutProviderConnectionsInputSchema),
      ]),
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationUpdateToOneWithWhereWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationUpdateToOneWithWhereWithoutProviderConnectionsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutProviderConnectionsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutProviderConnectionsInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedBy: z
        .lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUpsertWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutProviderConnectionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutProviderConnectionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutProviderConnectionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutProviderConnectionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutProviderConnectionsInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutProviderConnectionsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutProviderConnectionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutProviderConnectionsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutProviderConnectionsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutProviderConnectionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutProviderConnectionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutProviderConnectionInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutProviderConnectionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutProviderConnectionInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutProviderConnectionInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutProviderConnectionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutProviderConnectionInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutProviderConnectionInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutProviderConnectionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutProviderConnectionInputSchema),
      ]),
    })
    .strict();

export const OrganizationCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      approvedBy: z
        .lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const LocationCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutLocationsInputSchema),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutLocationInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationUncheckedCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutLocationInputSchema)
        .optional(),
    })
    .strict();

export const LocationCreateOrConnectWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationCreateOrConnectWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LocationCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => LocationUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionPlanCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      basePrice: z.number().positive(),
      currency: z.string().optional(),
      interval: z.lazy(() => BillingIntervalSchema),
      includedSlots: z.number().int().optional(),
      tierPricing: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z.number().int().optional().nullable(),
      maxLocations: z.number().int().optional().nullable(),
      isActive: z.boolean().optional(),
      stripePriceId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SubscriptionPlanUncheckedCreateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanUncheckedCreateWithoutSubscriptionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      basePrice: z.number().positive(),
      currency: z.string().optional(),
      interval: z.lazy(() => BillingIntervalSchema),
      includedSlots: z.number().int().optional(),
      tierPricing: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z.number().int().optional().nullable(),
      maxLocations: z.number().int().optional().nullable(),
      isActive: z.boolean().optional(),
      stripePriceId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SubscriptionPlanCreateOrConnectWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanCreateOrConnectWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionPlanWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionPlanCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => SubscriptionPlanUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const PaymentCreateWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentCreateWithoutSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      amount: z.number().positive(),
      baseAmount: z.number().positive().optional().nullable(),
      usageAmount: z.number().positive().optional().nullable(),
      currency: z.string(),
      status: z.lazy(() => PaymentStatusSchema),
      stripePaymentId: z.string().optional().nullable(),
      stripeInvoiceId: z.string().optional().nullable(),
      paidAt: z.coerce.date().optional().nullable(),
      failureReason: z.string().optional().nullable(),
      billingPeriodStart: z.coerce.date().optional().nullable(),
      billingPeriodEnd: z.coerce.date().optional().nullable(),
      slotsCovered: z.number().int().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const PaymentUncheckedCreateWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUncheckedCreateWithoutSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      amount: z.number().positive(),
      baseAmount: z.number().positive().optional().nullable(),
      usageAmount: z.number().positive().optional().nullable(),
      currency: z.string(),
      status: z.lazy(() => PaymentStatusSchema),
      stripePaymentId: z.string().optional().nullable(),
      stripeInvoiceId: z.string().optional().nullable(),
      paidAt: z.coerce.date().optional().nullable(),
      failureReason: z.string().optional().nullable(),
      billingPeriodStart: z.coerce.date().optional().nullable(),
      billingPeriodEnd: z.coerce.date().optional().nullable(),
      slotsCovered: z.number().int().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const PaymentCreateOrConnectWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentCreateOrConnectWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => PaymentWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema),
        z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const PaymentCreateManySubscriptionInputEnvelopeSchema: z.ZodType<Prisma.PaymentCreateManySubscriptionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => PaymentCreateManySubscriptionInputSchema),
        z.lazy(() => PaymentCreateManySubscriptionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UsageRecordCreateWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordCreateWithoutSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string(),
      slotDate: z.coerce.date(),
      slotStatus: z.lazy(() => SlotStatusSchema),
      billingCycle: z.string(),
      serviceProviderId: z.string(),
      serviceId: z.string(),
      tierUsed: z.number().int(),
      priceCharged: z.number().positive(),
      processed: z.boolean().optional(),
      processedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const UsageRecordUncheckedCreateWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUncheckedCreateWithoutSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string(),
      slotDate: z.coerce.date(),
      slotStatus: z.lazy(() => SlotStatusSchema),
      billingCycle: z.string(),
      serviceProviderId: z.string(),
      serviceId: z.string(),
      tierUsed: z.number().int(),
      priceCharged: z.number().positive(),
      processed: z.boolean().optional(),
      processedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const UsageRecordCreateOrConnectWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordCreateOrConnectWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => UsageRecordWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema),
        z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const UsageRecordCreateManySubscriptionInputEnvelopeSchema: z.ZodType<Prisma.UsageRecordCreateManySubscriptionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => UsageRecordCreateManySubscriptionInputSchema),
        z.lazy(() => UsageRecordCreateManySubscriptionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availability: z.lazy(() => AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema),
      service: z.lazy(() => ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema),
      serviceConfig: z.lazy(
        () => ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema
      ),
      booking: z.lazy(() => BookingCreateNestedOneWithoutSlotInputSchema).optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      booking: z.lazy(() => BookingUncheckedCreateNestedOneWithoutSlotInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateOrConnectWithoutBilledToSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputEnvelopeSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityCreateWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutDefaultSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutDefaultSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutDefaultSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateManyDefaultSubscriptionInputEnvelopeSchema: z.ZodType<Prisma.AvailabilityCreateManyDefaultSubscriptionInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => AvailabilityCreateManyDefaultSubscriptionInputSchema),
        z.lazy(() => AvailabilityCreateManyDefaultSubscriptionInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationUpsertWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationUpsertWithoutSubscriptionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationUpdateToOneWithWhereWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationUpdateToOneWithWhereWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedBy: z
        .lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const LocationUpsertWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationUpsertWithoutSubscriptionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => LocationUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => LocationUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => LocationCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => LocationUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
      where: z.lazy(() => LocationWhereInputSchema).optional(),
    })
    .strict();

export const LocationUpdateToOneWithWhereWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationUpdateToOneWithWhereWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => LocationUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => LocationUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const LocationUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutLocationsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUpsertWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutSubscriptionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const SubscriptionPlanUpsertWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanUpsertWithoutSubscriptionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SubscriptionPlanUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionPlanCreateWithoutSubscriptionsInputSchema),
        z.lazy(() => SubscriptionPlanUncheckedCreateWithoutSubscriptionsInputSchema),
      ]),
      where: z.lazy(() => SubscriptionPlanWhereInputSchema).optional(),
    })
    .strict();

export const SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanUpdateToOneWithWhereWithoutSubscriptionsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionPlanWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SubscriptionPlanUpdateWithoutSubscriptionsInputSchema),
        z.lazy(() => SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionPlanUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      interval: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => EnumBillingIntervalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      includedSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      tierPricing: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      maxLocations: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      stripePriceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInputSchema: z.ZodType<Prisma.SubscriptionPlanUncheckedUpdateWithoutSubscriptionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      basePrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      interval: z
        .union([
          z.lazy(() => BillingIntervalSchema),
          z.lazy(() => EnumBillingIntervalFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      includedSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      tierPricing: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      features: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      maxProviders: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      maxLocations: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      stripePriceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const PaymentUpsertWithWhereUniqueWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUpsertWithWhereUniqueWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => PaymentWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => PaymentUpdateWithoutSubscriptionInputSchema),
        z.lazy(() => PaymentUncheckedUpdateWithoutSubscriptionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => PaymentCreateWithoutSubscriptionInputSchema),
        z.lazy(() => PaymentUncheckedCreateWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const PaymentUpdateWithWhereUniqueWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUpdateWithWhereUniqueWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => PaymentWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => PaymentUpdateWithoutSubscriptionInputSchema),
        z.lazy(() => PaymentUncheckedUpdateWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const PaymentUpdateManyWithWhereWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUpdateManyWithWhereWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => PaymentScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => PaymentUpdateManyMutationInputSchema),
        z.lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const PaymentScalarWhereInputSchema: z.ZodType<Prisma.PaymentScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => PaymentScalarWhereInputSchema),
        z.lazy(() => PaymentScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => PaymentScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => PaymentScalarWhereInputSchema),
        z.lazy(() => PaymentScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    subscriptionId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    amount: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    baseAmount: z
      .union([
        z.lazy(() => DecimalNullableFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional()
      .nullable(),
    usageAmount: z
      .union([
        z.lazy(() => DecimalNullableFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional()
      .nullable(),
    currency: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    status: z
      .union([z.lazy(() => EnumPaymentStatusFilterSchema), z.lazy(() => PaymentStatusSchema)])
      .optional(),
    stripePaymentId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    stripeInvoiceId: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    paidAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    failureReason: z
      .union([z.lazy(() => StringNullableFilterSchema), z.string()])
      .optional()
      .nullable(),
    billingPeriodStart: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    billingPeriodEnd: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    slotsCovered: z
      .union([z.lazy(() => IntNullableFilterSchema), z.number()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUpsertWithWhereUniqueWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => UsageRecordWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => UsageRecordUpdateWithoutSubscriptionInputSchema),
        z.lazy(() => UsageRecordUncheckedUpdateWithoutSubscriptionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UsageRecordCreateWithoutSubscriptionInputSchema),
        z.lazy(() => UsageRecordUncheckedCreateWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUpdateWithWhereUniqueWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => UsageRecordWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => UsageRecordUpdateWithoutSubscriptionInputSchema),
        z.lazy(() => UsageRecordUncheckedUpdateWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const UsageRecordUpdateManyWithWhereWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUpdateManyWithWhereWithoutSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => UsageRecordScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => UsageRecordUpdateManyMutationInputSchema),
        z.lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionInputSchema),
      ]),
    })
    .strict();

export const UsageRecordScalarWhereInputSchema: z.ZodType<Prisma.UsageRecordScalarWhereInput> = z
  .object({
    AND: z
      .union([
        z.lazy(() => UsageRecordScalarWhereInputSchema),
        z.lazy(() => UsageRecordScalarWhereInputSchema).array(),
      ])
      .optional(),
    OR: z
      .lazy(() => UsageRecordScalarWhereInputSchema)
      .array()
      .optional(),
    NOT: z
      .union([
        z.lazy(() => UsageRecordScalarWhereInputSchema),
        z.lazy(() => UsageRecordScalarWhereInputSchema).array(),
      ])
      .optional(),
    id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    subscriptionId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slotId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    slotDate: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    slotStatus: z
      .union([z.lazy(() => EnumSlotStatusFilterSchema), z.lazy(() => SlotStatusSchema)])
      .optional(),
    billingCycle: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceProviderId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
    tierUsed: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
    priceCharged: z
      .union([
        z.lazy(() => DecimalFilterSchema),
        z
          .union([
            z.number(),
            z.string(),
            z.instanceof(Decimal),
            z.instanceof(Prisma.Decimal),
            DecimalJsLikeSchema,
          ])
          .refine((v) => isValidDecimalInput(v), { message: 'Must be a Decimal' }),
      ])
      .optional(),
    processed: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
    processedAt: z
      .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
      .optional()
      .nullable(),
    createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
  })
  .strict();

export const CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBilledToSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBilledToSubscriptionInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateWithoutBilledToSubscriptionInputSchema
        ),
      ]),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBilledToSubscriptionInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateWithoutBilledToSubscriptionInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBilledToSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBilledToSubscriptionInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateWithoutBilledToSubscriptionInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBilledToSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateManyMutationInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotScalarWhereInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
          z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      availabilityId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      serviceConfigId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      status: z
        .union([z.lazy(() => EnumSlotStatusFilterSchema), z.lazy(() => SlotStatusSchema)])
        .optional(),
      lastCalculated: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      billedToSubscriptionId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutDefaultSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutDefaultSubscriptionInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutDefaultSubscriptionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutDefaultSubscriptionInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutDefaultSubscriptionInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutDefaultSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutDefaultSubscriptionInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutDefaultSubscriptionInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutDefaultSubscriptionInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutPlanInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutPlanInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutPlanInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutPlanInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateManyPlanInputEnvelopeSchema: z.ZodType<Prisma.SubscriptionCreateManyPlanInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => SubscriptionCreateManyPlanInputSchema),
        z.lazy(() => SubscriptionCreateManyPlanInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SubscriptionUpsertWithWhereUniqueWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithWhereUniqueWithoutPlanInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutPlanInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutPlanInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutPlanInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutPlanInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithWhereUniqueWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithWhereUniqueWithoutPlanInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutPlanInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutPlanInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateManyWithWhereWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUpdateManyWithWhereWithoutPlanInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => SubscriptionUpdateManyMutationInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateManyWithoutPlanInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutUsageRecordsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutUsageRecordsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutUsageRecordsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutUsageRecordsInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutUsageRecordsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpsertWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithoutUsageRecordsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutUsageRecordsInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutUsageRecordsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutUsageRecordsInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutUsageRecordsInputSchema),
      ]),
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionUpdateToOneWithWhereWithoutUsageRecordsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutUsageRecordsInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutUsageRecordsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutUsageRecordsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutUsageRecordsInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutUsageRecordsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutPaymentsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutPaymentsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutPaymentsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutPaymentsInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutPaymentsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpsertWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithoutPaymentsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutPaymentsInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutPaymentsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutPaymentsInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutPaymentsInputSchema),
      ]),
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateToOneWithWhereWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionUpdateToOneWithWhereWithoutPaymentsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutPaymentsInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutPaymentsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutPaymentsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutPaymentsInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutPaymentsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateWithoutRequirementsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      services: z
        .lazy(() => ServiceCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedCreateWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedCreateWithoutRequirementsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateOrConnectWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateOrConnectWithoutRequirementsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderTypeCreateWithoutRequirementsInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutRequirementsInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionCreateWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateWithoutRequirementTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutRequirementSubmissionsInputSchema
      ),
      validatedBy: z
        .lazy(() => UserCreateNestedOneWithoutValidatedRequirementsInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedCreateWithoutRequirementTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      validatedById: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionCreateOrConnectWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateOrConnectWithoutRequirementTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionCreateManyRequirementTypeInputEnvelopeSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyRequirementTypeInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => RequirementSubmissionCreateManyRequirementTypeInputSchema),
        z.lazy(() => RequirementSubmissionCreateManyRequirementTypeInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderTypeUpsertWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpsertWithoutRequirementsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderTypeUpdateWithoutRequirementsInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutRequirementsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderTypeCreateWithoutRequirementsInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutRequirementsInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateToOneWithWhereWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateToOneWithWhereWithoutRequirementsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderTypeUpdateWithoutRequirementsInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutRequirementsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderTypeUpdateWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateWithoutRequirementsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      services: z
        .lazy(() => ServiceUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedUpdateWithoutRequirementsInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedUpdateWithoutRequirementsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUpsertWithWhereUniqueWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUpsertWithWhereUniqueWithoutRequirementTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => RequirementSubmissionUpdateWithoutRequirementTypeInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateWithoutRequirementTypeInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RequirementSubmissionCreateWithoutRequirementTypeInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedCreateWithoutRequirementTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpdateWithWhereUniqueWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateWithWhereUniqueWithoutRequirementTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => RequirementSubmissionUpdateWithoutRequirementTypeInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateWithoutRequirementTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementSubmissionUpdateManyWithWhereWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyWithWhereWithoutRequirementTypeInput> =
  z
    .object({
      where: z.lazy(() => RequirementSubmissionScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => RequirementSubmissionUpdateManyMutationInputSchema),
        z.lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeCreateWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeCreateWithoutSubmissionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutRequirementsInputSchema
      ),
    })
    .strict();

export const RequirementTypeUncheckedCreateWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedCreateWithoutSubmissionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      serviceProviderTypeId: z.string(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementTypeCreateOrConnectWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeCreateOrConnectWithoutSubmissionsInput> =
  z
    .object({
      where: z.lazy(() => RequirementTypeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => RequirementTypeCreateWithoutSubmissionsInputSchema),
        z.lazy(() => RequirementTypeUncheckedCreateWithoutSubmissionsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutRequirementSubmissionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutRequirementSubmissionsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutRequirementSubmissionsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutRequirementSubmissionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutRequirementSubmissionsInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserCreateWithoutValidatedRequirementsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutValidatedRequirementsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutValidatedRequirementsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutValidatedRequirementsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutValidatedRequirementsInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeUpsertWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeUpsertWithoutSubmissionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => RequirementTypeUpdateWithoutSubmissionsInputSchema),
        z.lazy(() => RequirementTypeUncheckedUpdateWithoutSubmissionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => RequirementTypeCreateWithoutSubmissionsInputSchema),
        z.lazy(() => RequirementTypeUncheckedCreateWithoutSubmissionsInputSchema),
      ]),
      where: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
    })
    .strict();

export const RequirementTypeUpdateToOneWithWhereWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeUpdateToOneWithWhereWithoutSubmissionsInput> =
  z
    .object({
      where: z.lazy(() => RequirementTypeWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => RequirementTypeUpdateWithoutSubmissionsInputSchema),
        z.lazy(() => RequirementTypeUncheckedUpdateWithoutSubmissionsInputSchema),
      ]),
    })
    .strict();

export const RequirementTypeUpdateWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeUpdateWithoutSubmissionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutRequirementsNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedUpdateWithoutSubmissionsInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedUpdateWithoutSubmissionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceProviderUpsertWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutRequirementSubmissionsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutRequirementSubmissionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutRequirementSubmissionsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutRequirementSubmissionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutRequirementSubmissionsInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutRequirementSubmissionsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutRequirementSubmissionsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutRequirementSubmissionsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutRequirementSubmissionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutRequirementSubmissionsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutRequirementSubmissionsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserUpsertWithoutValidatedRequirementsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutValidatedRequirementsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutValidatedRequirementsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutValidatedRequirementsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutValidatedRequirementsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutValidatedRequirementsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutValidatedRequirementsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutValidatedRequirementsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserUpdateWithoutValidatedRequirementsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutValidatedRequirementsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutValidatedRequirementsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeCreateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateWithoutServicesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirements: z
        .lazy(() => RequirementTypeCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedCreateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedCreateWithoutServicesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      requirements: z
        .lazy(() => RequirementTypeUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServiceProviderTypeInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeCreateOrConnectWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeCreateOrConnectWithoutServicesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderTypeWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderTypeCreateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServicesInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutServicesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutServicesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutServicesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateWithoutServiceInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutAvailabilityConfigsInputSchema
      ),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceConfigInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateWithoutServiceInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceConfigInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateOrConnectWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateOrConnectWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyServiceInputEnvelopeSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyServiceInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateManyServiceInputSchema),
        z.lazy(() => ServiceAvailabilityConfigCreateManyServiceInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateWithoutServiceInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availability: z.lazy(() => AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema),
      serviceConfig: z.lazy(
        () => ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema
      ),
      booking: z.lazy(() => BookingCreateNestedOneWithoutSlotInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      booking: z.lazy(() => BookingUncheckedCreateNestedOneWithoutSlotInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateOrConnectWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyServiceInputEnvelopeSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyServiceInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateManyServiceInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotCreateManyServiceInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderTypeUpsertWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpsertWithoutServicesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderTypeUpdateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutServicesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderTypeCreateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedCreateWithoutServicesInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderTypeUpdateToOneWithWhereWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateToOneWithWhereWithoutServicesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderTypeWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderTypeUpdateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderTypeUncheckedUpdateWithoutServicesInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderTypeUpdateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateWithoutServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirements: z
        .lazy(() => RequirementTypeUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderTypeUncheckedUpdateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderTypeUncheckedUpdateWithoutServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirements: z
        .lazy(() => RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
      serviceProviders: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUpsertWithWhereUniqueWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithWhereUniqueWithoutServicesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutServicesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutServicesInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithWhereUniqueWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithWhereUniqueWithoutServicesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutServicesInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutServicesInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateManyWithWhereWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUpdateManyWithWhereWithoutServicesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateManyMutationInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateManyWithoutServicesInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutServiceInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutServiceInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutServiceInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutServiceInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyWithWhereWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateManyMutationInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutServiceInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutServiceInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateManyMutationInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceInputSchema),
      ]),
    })
    .strict();

export const ServiceCreateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceCreateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServicesInputSchema
      ),
      providers: z.lazy(() => ServiceProviderCreateNestedManyWithoutServicesInputSchema).optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedCreateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      serviceProviderTypeId: z.string(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      providers: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServicesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceCreateOrConnectWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceCreateOrConnectWithoutAvailabilityConfigsInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutAvailabilityConfigsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutAvailabilityConfigsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilityConfigsInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutAvailableServicesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutAvailabilityInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutAvailableServicesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutAvailabilityInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutAvailableServicesInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateWithoutServiceConfigInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availability: z.lazy(() => AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema),
      service: z.lazy(() => ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema),
      booking: z.lazy(() => BookingCreateNestedOneWithoutSlotInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      booking: z.lazy(() => BookingUncheckedCreateNestedOneWithoutSlotInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateOrConnectWithoutServiceConfigInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyServiceConfigInputEnvelopeSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyServiceConfigInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateManyServiceConfigInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotCreateManyServiceConfigInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceUpsertWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceUpsertWithoutAvailabilityConfigsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceUpdateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutAvailabilityConfigsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutAvailabilityConfigsInputSchema),
      ]),
      where: z.lazy(() => ServiceWhereInputSchema).optional(),
    })
    .strict();

export const ServiceUpdateToOneWithWhereWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceUpdateToOneWithWhereWithoutAvailabilityConfigsInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceUpdateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutAvailabilityConfigsInputSchema),
      ]),
    })
    .strict();

export const ServiceUpdateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceUpdateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServicesNestedInputSchema)
        .optional(),
      providers: z.lazy(() => ServiceProviderUpdateManyWithoutServicesNestedInputSchema).optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      providers: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUpsertWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutAvailabilityConfigsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutAvailabilityConfigsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilityConfigsInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutAvailabilityConfigsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutAvailabilityConfigsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutAvailabilityConfigsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutAvailabilityConfigsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutAvailabilityConfigsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUpsertWithWhereUniqueWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithWhereUniqueWithoutAvailableServicesInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutAvailableServicesInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutAvailableServicesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutAvailableServicesInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutAvailableServicesInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithWhereUniqueWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithWhereUniqueWithoutAvailableServicesInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutAvailableServicesInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutAvailableServicesInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateManyWithWhereWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUpdateManyWithWhereWithoutAvailableServicesInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => AvailabilityUpdateManyMutationInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateManyWithoutAvailableServicesInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutServiceConfigInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutServiceConfigInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceConfigInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutServiceConfigInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutServiceConfigInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutServiceConfigInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutServiceConfigInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceConfigInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithWhereWithoutServiceConfigInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateManyMutationInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const OrganizationCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      approvedBy: z
        .lazy(() => UserCreateNestedOneWithoutOrganizationsApprovedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      locations: z.lazy(() => LocationCreateNestedManyWithoutOrganizationInputSchema).optional(),
    })
    .strict();

export const OrganizationUncheckedCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationUncheckedCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutOrganizationInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedCreateNestedManyWithoutOrganizationInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationCreateOrConnectWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationCreateOrConnectWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const LocationCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutLocationsInputSchema),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutLocationInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationUncheckedCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutLocationInputSchema)
        .optional(),
    })
    .strict();

export const LocationCreateOrConnectWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationCreateOrConnectWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => LocationCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => LocationUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutProviderConnectionsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutProviderConnectionsInputSchema
      ),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const OrganizationProviderConnectionCreateOrConnectWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateOrConnectWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserCreateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesCreatedInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipCreateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutMembershipsInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutOrganizationMembershipsInputSchema),
      invitation: z
        .lazy(() => OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateOrConnectWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateOrConnectWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutAvailabilitiesCreatedInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserCreateWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutAvailabilitiesAcceptedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesAcceptedInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBilledToSubscriptionInputSchema
        )
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutDefaultForAvailabilitiesInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutDefaultForAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      service: z.lazy(() => ServiceCreateNestedOneWithoutAvailabilityConfigsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutAvailabilityConfigsInputSchema
      ),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedManyWithoutServiceConfigInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      serviceProviderId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutServiceConfigInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateOrConnectWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateWithoutAvailabilityInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      service: z.lazy(() => ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema),
      serviceConfig: z.lazy(
        () => ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema
      ),
      booking: z.lazy(() => BookingCreateNestedOneWithoutSlotInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      booking: z.lazy(() => BookingUncheckedCreateNestedOneWithoutSlotInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateOrConnectWithoutAvailabilityInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyAvailabilityInputEnvelopeSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyAvailabilityInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateManyAvailabilityInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotCreateManyAvailabilityInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderUpsertWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutAvailabilitiesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUpsertWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationUpsertWithoutAvailabilitiesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationUpdateToOneWithWhereWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationUpdateToOneWithWhereWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => OrganizationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const OrganizationUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedBy: z
        .lazy(() => UserUpdateOneWithoutOrganizationsApprovedNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const LocationUpsertWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationUpsertWithoutAvailabilitiesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => LocationUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => LocationUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => LocationCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => LocationUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
      where: z.lazy(() => LocationWhereInputSchema).optional(),
    })
    .strict();

export const LocationUpdateToOneWithWhereWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationUpdateToOneWithWhereWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => LocationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => LocationUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => LocationUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const LocationUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutLocationsNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpsertWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpsertWithoutAvailabilitiesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationProviderConnectionCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
      where: z.lazy(() => OrganizationProviderConnectionWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateToOneWithWhereWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateToOneWithWhereWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => OrganizationProviderConnectionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationProviderConnectionUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => OrganizationProviderConnectionUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const UserUpsertWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserUpsertWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesCreatedInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserUpdateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpsertWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpsertWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutAvailabilitiesCreatedInputSchema),
      ]),
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipUpdateToOneWithWhereWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateToOneWithWhereWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutAvailabilitiesCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema)
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateWithoutAvailabilitiesCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateWithoutAvailabilitiesCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const UserUpsertWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserUpsertWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutAvailabilitiesAcceptedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAvailabilitiesAcceptedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutAvailabilitiesAcceptedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutAvailabilitiesAcceptedInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutAvailabilitiesAcceptedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutAvailabilitiesAcceptedInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserUpdateWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutAvailabilitiesAcceptedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutAvailabilitiesAcceptedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUpsertWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutDefaultForAvailabilitiesInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutDefaultForAvailabilitiesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutDefaultForAvailabilitiesInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutDefaultForAvailabilitiesInputSchema),
      ]),
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateToOneWithWhereWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionUpdateToOneWithWhereWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutDefaultForAvailabilitiesInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutDefaultForAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutDefaultForAvailabilitiesInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutDefaultForAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpsertWithWhereUniqueWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithWhereUniqueWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutAvailabilitiesInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyWithWhereWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyWithWhereWithoutAvailabilitiesInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateManyMutationInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutAvailabilityInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutAvailabilityInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutAvailabilityInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutAvailabilityInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutAvailabilityInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutAvailabilityInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutAvailabilityInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutAvailabilityInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithWhereWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithWhereWithoutAvailabilityInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateManyMutationInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityInputSchema),
      ]),
    })
    .strict();

export const AvailabilityCreateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityCreateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutAvailabilitiesInputSchema),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutAvailabilitiesInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionCreateNestedOneWithoutAvailabilitiesInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutAvailabilitiesCreatedInputSchema),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutAvailabilitiesCreatedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserCreateNestedOneWithoutAvailabilitiesAcceptedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutDefaultForAvailabilitiesInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutAvailabilitiesInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedCreateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityUncheckedCreateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutAvailabilitiesInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityCreateOrConnectWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityCreateOrConnectWithoutCalculatedSlotsInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutCalculatedSlotsInputSchema),
      ]),
    })
    .strict();

export const ServiceCreateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceCreateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServicesInputSchema
      ),
      providers: z.lazy(() => ServiceProviderCreateNestedManyWithoutServicesInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedCreateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceUncheckedCreateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      serviceProviderTypeId: z.string(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      providers: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutServicesInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceInputSchema)
        .optional(),
    })
    .strict();

export const ServiceCreateOrConnectWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceCreateOrConnectWithoutCalculatedSlotsInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutCalculatedSlotsInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      service: z.lazy(() => ServiceCreateNestedOneWithoutAvailabilityConfigsInputSchema),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutAvailabilityConfigsInputSchema
      ),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedCreateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedCreateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      serviceProviderId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAvailableServicesInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateOrConnectWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateOrConnectWithoutCalculatedSlotsInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutCalculatedSlotsInputSchema),
      ]),
    })
    .strict();

export const BookingCreateWithoutSlotInputSchema: z.ZodType<Prisma.BookingCreateWithoutSlotInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutSlotInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutSlotInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutSlotInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutSlotInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutSlotInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutSlotInputSchema),
      ]),
    })
    .strict();

export const SubscriptionCreateWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionCreateWithoutBilledSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z
        .lazy(() => OrganizationCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      location: z.lazy(() => LocationCreateNestedOneWithoutSubscriptionsInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutSubscriptionsInputSchema)
        .optional(),
      plan: z.lazy(() => SubscriptionPlanCreateNestedOneWithoutSubscriptionsInputSchema),
      payments: z.lazy(() => PaymentCreateNestedManyWithoutSubscriptionInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedCreateWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionUncheckedCreateWithoutBilledSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      payments: z
        .lazy(() => PaymentUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedCreateNestedManyWithoutSubscriptionInputSchema)
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutDefaultSubscriptionInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionCreateOrConnectWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionCreateOrConnectWithoutBilledSlotsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutBilledSlotsInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutBilledSlotsInputSchema),
      ]),
    })
    .strict();

export const CalendarEventCreateWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventCreateWithoutBlockedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      externalEventId: z.string(),
      externalCalendarId: z.string(),
      etag: z.string().optional().nullable(),
      title: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isAllDay: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional(),
      eventType: z.string().optional().nullable(),
      blocksAvailability: z.boolean().optional(),
      syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      lastModifiedInExternal: z.coerce.date().optional().nullable(),
      hasConflict: z.boolean().optional(),
      conflictDetails: z.string().optional().nullable(),
      conflictResolvedAt: z.coerce.date().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calendarIntegration: z.lazy(
        () => CalendarIntegrationCreateNestedOneWithoutCalendarEventsInputSchema
      ),
    })
    .strict();

export const CalendarEventUncheckedCreateWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventUncheckedCreateWithoutBlockedSlotsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      calendarIntegrationId: z.string(),
      externalEventId: z.string(),
      externalCalendarId: z.string(),
      etag: z.string().optional().nullable(),
      title: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isAllDay: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional(),
      eventType: z.string().optional().nullable(),
      blocksAvailability: z.boolean().optional(),
      syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      lastModifiedInExternal: z.coerce.date().optional().nullable(),
      hasConflict: z.boolean().optional(),
      conflictDetails: z.string().optional().nullable(),
      conflictResolvedAt: z.coerce.date().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarEventCreateOrConnectWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventCreateOrConnectWithoutBlockedSlotsInput> =
  z
    .object({
      where: z.lazy(() => CalendarEventWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalendarEventCreateWithoutBlockedSlotsInputSchema),
        z.lazy(() => CalendarEventUncheckedCreateWithoutBlockedSlotsInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpsertWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityUpsertWithoutCalculatedSlotsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => AvailabilityUpdateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutCalculatedSlotsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => AvailabilityCreateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => AvailabilityUncheckedCreateWithoutCalculatedSlotsInputSchema),
      ]),
      where: z.lazy(() => AvailabilityWhereInputSchema).optional(),
    })
    .strict();

export const AvailabilityUpdateToOneWithWhereWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityUpdateToOneWithWhereWithoutCalculatedSlotsInput> =
  z
    .object({
      where: z.lazy(() => AvailabilityWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => AvailabilityUpdateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => AvailabilityUncheckedUpdateWithoutCalculatedSlotsInputSchema),
      ]),
    })
    .strict();

export const AvailabilityUpdateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceUpsertWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceUpsertWithoutCalculatedSlotsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceUpdateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutCalculatedSlotsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceCreateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceUncheckedCreateWithoutCalculatedSlotsInputSchema),
      ]),
      where: z.lazy(() => ServiceWhereInputSchema).optional(),
    })
    .strict();

export const ServiceUpdateToOneWithWhereWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceUpdateToOneWithWhereWithoutCalculatedSlotsInput> =
  z
    .object({
      where: z.lazy(() => ServiceWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceUpdateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceUncheckedUpdateWithoutCalculatedSlotsInputSchema),
      ]),
    })
    .strict();

export const ServiceUpdateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceUpdateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServicesNestedInputSchema)
        .optional(),
      providers: z.lazy(() => ServiceProviderUpdateManyWithoutServicesNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      providers: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServicesNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpsertWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpsertWithoutCalculatedSlotsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutCalculatedSlotsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceAvailabilityConfigCreateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedCreateWithoutCalculatedSlotsInputSchema),
      ]),
      where: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateToOneWithWhereWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateToOneWithWhereWithoutCalculatedSlotsInput> =
  z
    .object({
      where: z.lazy(() => ServiceAvailabilityConfigWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceAvailabilityConfigUpdateWithoutCalculatedSlotsInputSchema),
        z.lazy(() => ServiceAvailabilityConfigUncheckedUpdateWithoutCalculatedSlotsInputSchema),
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateWithoutCalculatedSlotsInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateWithoutCalculatedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUpsertWithoutSlotInputSchema: z.ZodType<Prisma.BookingUpsertWithoutSlotInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BookingUpdateWithoutSlotInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutSlotInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutSlotInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutSlotInputSchema),
      ]),
      where: z.lazy(() => BookingWhereInputSchema).optional(),
    })
    .strict();

export const BookingUpdateToOneWithWhereWithoutSlotInputSchema: z.ZodType<Prisma.BookingUpdateToOneWithWhereWithoutSlotInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutSlotInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutSlotInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithoutSlotInputSchema: z.ZodType<Prisma.BookingUpdateWithoutSlotInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutSlotInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutSlotInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUpsertWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionUpsertWithoutBilledSlotsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => SubscriptionUpdateWithoutBilledSlotsInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutBilledSlotsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => SubscriptionCreateWithoutBilledSlotsInputSchema),
        z.lazy(() => SubscriptionUncheckedCreateWithoutBilledSlotsInputSchema),
      ]),
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
    })
    .strict();

export const SubscriptionUpdateToOneWithWhereWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionUpdateToOneWithWhereWithoutBilledSlotsInput> =
  z
    .object({
      where: z.lazy(() => SubscriptionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => SubscriptionUpdateWithoutBilledSlotsInputSchema),
        z.lazy(() => SubscriptionUncheckedUpdateWithoutBilledSlotsInputSchema),
      ]),
    })
    .strict();

export const SubscriptionUpdateWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutBilledSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutBilledSlotsInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutBilledSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarEventUpsertWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventUpsertWithoutBlockedSlotsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CalendarEventUpdateWithoutBlockedSlotsInputSchema),
        z.lazy(() => CalendarEventUncheckedUpdateWithoutBlockedSlotsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalendarEventCreateWithoutBlockedSlotsInputSchema),
        z.lazy(() => CalendarEventUncheckedCreateWithoutBlockedSlotsInputSchema),
      ]),
      where: z.lazy(() => CalendarEventWhereInputSchema).optional(),
    })
    .strict();

export const CalendarEventUpdateToOneWithWhereWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventUpdateToOneWithWhereWithoutBlockedSlotsInput> =
  z
    .object({
      where: z.lazy(() => CalendarEventWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CalendarEventUpdateWithoutBlockedSlotsInputSchema),
        z.lazy(() => CalendarEventUncheckedUpdateWithoutBlockedSlotsInputSchema),
      ]),
    })
    .strict();

export const CalendarEventUpdateWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventUpdateWithoutBlockedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneRequiredWithoutCalendarEventsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedUpdateWithoutBlockedSlotsInputSchema: z.ZodType<Prisma.CalendarEventUncheckedUpdateWithoutBlockedSlotsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarIntegrationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availability: z.lazy(() => AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema),
      service: z.lazy(() => ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema),
      serviceConfig: z.lazy(
        () => ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema
      ),
      billedToSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventCreateNestedOneWithoutBlockedSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateOrConnectWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateOrConnectWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBookingInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserCreateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutBookingsCreatedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutBookingsCreatedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutBookingsCreatedInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipCreateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      organization: z.lazy(() => OrganizationCreateNestedOneWithoutMembershipsInputSchema),
      user: z.lazy(() => UserCreateNestedOneWithoutOrganizationMembershipsInputSchema),
      invitation: z
        .lazy(() => OrganizationInvitationCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutMembershipInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedCreateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedCreateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedOneWithoutMembershipInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByMembershipInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutMembershipInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipCreateOrConnectWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateOrConnectWithoutBookingsCreatedInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutBookingsCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutBookingsCreatedInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserCreateWithoutBookingsConfirmedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutBookingsConfirmedInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutBookingsConfirmedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutBookingsConfirmedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutBookingsConfirmedInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserCreateWithoutBookingsAsClientInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutBookingsAsClientInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutBookingsAsClientInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutBookingsAsClientInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutBookingsAsClientInputSchema),
      ]),
    })
    .strict();

export const CommunicationLogCreateWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      bookingReference: z.string().optional().nullable(),
      serviceProviderName: z.string().optional().nullable(),
      clientName: z.string().optional().nullable(),
      serviceName: z.string().optional().nullable(),
      appointmentTime: z.coerce.date().optional().nullable(),
      type: z.lazy(() => CommunicationTypeSchema),
      channel: z.lazy(() => CommunicationChannelSchema),
      content: z.string(),
      status: z.string(),
      sentAt: z.coerce.date().optional(),
      deliveredAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const CommunicationLogUncheckedCreateWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      bookingReference: z.string().optional().nullable(),
      serviceProviderName: z.string().optional().nullable(),
      clientName: z.string().optional().nullable(),
      serviceName: z.string().optional().nullable(),
      appointmentTime: z.coerce.date().optional().nullable(),
      type: z.lazy(() => CommunicationTypeSchema),
      channel: z.lazy(() => CommunicationChannelSchema),
      content: z.string(),
      status: z.string(),
      sentAt: z.coerce.date().optional(),
      deliveredAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const CommunicationLogCreateOrConnectWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogCreateOrConnectWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => CommunicationLogWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema),
        z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const CommunicationLogCreateManyBookingInputEnvelopeSchema: z.ZodType<Prisma.CommunicationLogCreateManyBookingInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CommunicationLogCreateManyBookingInputSchema),
        z.lazy(() => CommunicationLogCreateManyBookingInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ReviewCreateWithoutBookingInputSchema: z.ZodType<Prisma.ReviewCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(() => ServiceProviderCreateNestedOneWithoutReviewsInputSchema),
      client: z.lazy(() => UserCreateNestedOneWithoutReviewsInputSchema),
    })
    .strict();

export const ReviewUncheckedCreateWithoutBookingInputSchema: z.ZodType<Prisma.ReviewUncheckedCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      clientId: z.string(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ReviewCreateOrConnectWithoutBookingInputSchema: z.ZodType<Prisma.ReviewCreateOrConnectWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ReviewCreateWithoutBookingInputSchema),
        z.lazy(() => ReviewUncheckedCreateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const MeetSessionCreateWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      meetLink: z.string(),
      eventId: z.string(),
      joinCode: z.string().optional().nullable(),
      status: z.lazy(() => MeetSessionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const MeetSessionUncheckedCreateWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionUncheckedCreateWithoutBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      meetLink: z.string(),
      eventId: z.string(),
      joinCode: z.string().optional().nullable(),
      status: z.lazy(() => MeetSessionStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const MeetSessionCreateOrConnectWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionCreateOrConnectWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => MeetSessionWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => MeetSessionCreateWithoutBookingInputSchema),
        z.lazy(() => MeetSessionUncheckedCreateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpsertWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertWithoutBookingInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBookingInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutBookingInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBookingInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedCreateWithoutBookingInputSchema),
      ]),
      where: z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateToOneWithWhereWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateToOneWithWhereWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBookingInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotUncheckedUpdateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availability: z
        .lazy(() => AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      serviceConfig: z
        .lazy(
          () => ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema
        )
        .optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateWithoutBookingInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UserUpsertWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserUpsertWithoutBookingsCreatedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutBookingsCreatedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutBookingsCreatedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutBookingsCreatedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutBookingsCreatedInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutBookingsCreatedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutBookingsCreatedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutBookingsCreatedInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserUpdateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpsertWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpsertWithoutBookingsCreatedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutBookingsCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutBookingsCreatedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => OrganizationMembershipCreateWithoutBookingsCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedCreateWithoutBookingsCreatedInputSchema),
      ]),
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
    })
    .strict();

export const OrganizationMembershipUpdateToOneWithWhereWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateToOneWithWhereWithoutBookingsCreatedInput> =
  z
    .object({
      where: z.lazy(() => OrganizationMembershipWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => OrganizationMembershipUpdateWithoutBookingsCreatedInputSchema),
        z.lazy(() => OrganizationMembershipUncheckedUpdateWithoutBookingsCreatedInputSchema),
      ]),
    })
    .strict();

export const OrganizationMembershipUpdateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema)
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema)
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateWithoutBookingsCreatedInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateWithoutBookingsCreatedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const UserUpsertWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserUpsertWithoutBookingsConfirmedInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutBookingsConfirmedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutBookingsConfirmedInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutBookingsConfirmedInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutBookingsConfirmedInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutBookingsConfirmedInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutBookingsConfirmedInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutBookingsConfirmedInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserUpdateWithoutBookingsConfirmedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutBookingsConfirmedInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutBookingsConfirmedInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserUpsertWithoutBookingsAsClientInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutBookingsAsClientInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutBookingsAsClientInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutBookingsAsClientInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutBookingsAsClientInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutBookingsAsClientInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutBookingsAsClientInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutBookingsAsClientInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserUpdateWithoutBookingsAsClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutBookingsAsClientInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutBookingsAsClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const CommunicationLogUpsertWithWhereUniqueWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUpsertWithWhereUniqueWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => CommunicationLogWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CommunicationLogUpdateWithoutBookingInputSchema),
        z.lazy(() => CommunicationLogUncheckedUpdateWithoutBookingInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CommunicationLogCreateWithoutBookingInputSchema),
        z.lazy(() => CommunicationLogUncheckedCreateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const CommunicationLogUpdateWithWhereUniqueWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUpdateWithWhereUniqueWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => CommunicationLogWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CommunicationLogUpdateWithoutBookingInputSchema),
        z.lazy(() => CommunicationLogUncheckedUpdateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const CommunicationLogUpdateManyWithWhereWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUpdateManyWithWhereWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => CommunicationLogScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CommunicationLogUpdateManyMutationInputSchema),
        z.lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const CommunicationLogScalarWhereInputSchema: z.ZodType<Prisma.CommunicationLogScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CommunicationLogScalarWhereInputSchema),
          z.lazy(() => CommunicationLogScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CommunicationLogScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CommunicationLogScalarWhereInputSchema),
          z.lazy(() => CommunicationLogScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      bookingId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      bookingReference: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      clientName: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => EnumCommunicationTypeFilterSchema),
          z.lazy(() => CommunicationTypeSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => EnumCommunicationChannelFilterSchema),
          z.lazy(() => CommunicationChannelSchema),
        ])
        .optional(),
      content: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      status: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      sentAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      deliveredAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
    })
    .strict();

export const ReviewUpsertWithoutBookingInputSchema: z.ZodType<Prisma.ReviewUpsertWithoutBookingInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ReviewUpdateWithoutBookingInputSchema),
        z.lazy(() => ReviewUncheckedUpdateWithoutBookingInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ReviewCreateWithoutBookingInputSchema),
        z.lazy(() => ReviewUncheckedCreateWithoutBookingInputSchema),
      ]),
      where: z.lazy(() => ReviewWhereInputSchema).optional(),
    })
    .strict();

export const ReviewUpdateToOneWithWhereWithoutBookingInputSchema: z.ZodType<Prisma.ReviewUpdateToOneWithWhereWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => ReviewWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ReviewUpdateWithoutBookingInputSchema),
        z.lazy(() => ReviewUncheckedUpdateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const ReviewUpdateWithoutBookingInputSchema: z.ZodType<Prisma.ReviewUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutReviewsNestedInputSchema)
        .optional(),
      client: z.lazy(() => UserUpdateOneRequiredWithoutReviewsNestedInputSchema).optional(),
    })
    .strict();

export const ReviewUncheckedUpdateWithoutBookingInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      clientId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const MeetSessionUpsertWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionUpsertWithoutBookingInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => MeetSessionUpdateWithoutBookingInputSchema),
        z.lazy(() => MeetSessionUncheckedUpdateWithoutBookingInputSchema),
      ]),
      create: z.union([
        z.lazy(() => MeetSessionCreateWithoutBookingInputSchema),
        z.lazy(() => MeetSessionUncheckedCreateWithoutBookingInputSchema),
      ]),
      where: z.lazy(() => MeetSessionWhereInputSchema).optional(),
    })
    .strict();

export const MeetSessionUpdateToOneWithWhereWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionUpdateToOneWithWhereWithoutBookingInput> =
  z
    .object({
      where: z.lazy(() => MeetSessionWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => MeetSessionUpdateWithoutBookingInputSchema),
        z.lazy(() => MeetSessionUncheckedUpdateWithoutBookingInputSchema),
      ]),
    })
    .strict();

export const MeetSessionUpdateWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      meetLink: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      eventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      joinCode: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => EnumMeetSessionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const MeetSessionUncheckedUpdateWithoutBookingInputSchema: z.ZodType<Prisma.MeetSessionUncheckedUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      meetLink: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      eventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      joinCode: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => MeetSessionStatusSchema),
          z.lazy(() => EnumMeetSessionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UserCreateWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserCreateWithoutCommunicationPreferencesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutCommunicationPreferencesInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedCreateNestedManyWithoutClientInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutCommunicationPreferencesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutCommunicationPreferencesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCommunicationPreferencesInputSchema),
      ]),
    })
    .strict();

export const UserUpsertWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserUpsertWithoutCommunicationPreferencesInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutCommunicationPreferencesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCommunicationPreferencesInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutCommunicationPreferencesInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutCommunicationPreferencesInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutCommunicationPreferencesInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutCommunicationPreferencesInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutCommunicationPreferencesInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserUpdateWithoutCommunicationPreferencesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutCommunicationPreferencesInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutCommunicationPreferencesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUncheckedUpdateManyWithoutClientNestedInputSchema).optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingCreateWithoutCommunicationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutCommunicationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutCommunicationsInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutCommunicationsInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutCommunicationsInputSchema),
      ]),
    })
    .strict();

export const BookingUpsertWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingUpsertWithoutCommunicationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BookingUpdateWithoutCommunicationsInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutCommunicationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutCommunicationsInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutCommunicationsInputSchema),
      ]),
      where: z.lazy(() => BookingWhereInputSchema).optional(),
    })
    .strict();

export const BookingUpdateToOneWithWhereWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingUpdateToOneWithWhereWithoutCommunicationsInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutCommunicationsInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutCommunicationsInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingUpdateWithoutCommunicationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutCommunicationsInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutCommunicationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      reviews: z.lazy(() => ReviewCreateNestedManyWithoutServiceProviderInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      reviews: z
        .lazy(() => ReviewUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarEventCreateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventCreateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      externalEventId: z.string(),
      externalCalendarId: z.string(),
      etag: z.string().optional().nullable(),
      title: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isAllDay: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional(),
      eventType: z.string().optional().nullable(),
      blocksAvailability: z.boolean().optional(),
      syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      lastModifiedInExternal: z.coerce.date().optional().nullable(),
      hasConflict: z.boolean().optional(),
      conflictDetails: z.string().optional().nullable(),
      conflictResolvedAt: z.coerce.date().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotCreateNestedManyWithoutBlockedByCalendarEventInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUncheckedCreateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      externalEventId: z.string(),
      externalCalendarId: z.string(),
      etag: z.string().optional().nullable(),
      title: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isAllDay: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional(),
      eventType: z.string().optional().nullable(),
      blocksAvailability: z.boolean().optional(),
      syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      lastModifiedInExternal: z.coerce.date().optional().nullable(),
      hasConflict: z.boolean().optional(),
      conflictDetails: z.string().optional().nullable(),
      conflictResolvedAt: z.coerce.date().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      blockedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedCreateNestedManyWithoutBlockedByCalendarEventInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarEventCreateOrConnectWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventCreateOrConnectWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarEventWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarEventCreateManyCalendarIntegrationInputEnvelopeSchema: z.ZodType<Prisma.CalendarEventCreateManyCalendarIntegrationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalendarEventCreateManyCalendarIntegrationInputSchema),
        z.lazy(() => CalendarEventCreateManyCalendarIntegrationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationCreateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      operationType: z.lazy(() => CalendarSyncOperationTypeSchema),
      sourceSystem: z.lazy(() => CalendarSyncSourceSchema),
      status: z.lazy(() => CalendarSyncStatusSchema).optional(),
      entityType: z.lazy(() => CalendarEntityTypeSchema),
      entityId: z.string().optional().nullable(),
      externalEventId: z.string().optional().nullable(),
      startedAt: z.coerce.date().optional(),
      completedAt: z.coerce.date().optional().nullable(),
      retryCount: z.number().int().optional(),
      maxRetries: z.number().int().optional(),
      errorMessage: z.string().optional().nullable(),
      conflictResolution: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      syncWindowStart: z.coerce.date().optional().nullable(),
      syncWindowEnd: z.coerce.date().optional().nullable(),
      eventsProcessed: z.number().int().optional(),
      eventsSucceeded: z.number().int().optional(),
      eventsFailed: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      operationType: z.lazy(() => CalendarSyncOperationTypeSchema),
      sourceSystem: z.lazy(() => CalendarSyncSourceSchema),
      status: z.lazy(() => CalendarSyncStatusSchema).optional(),
      entityType: z.lazy(() => CalendarEntityTypeSchema),
      entityId: z.string().optional().nullable(),
      externalEventId: z.string().optional().nullable(),
      startedAt: z.coerce.date().optional(),
      completedAt: z.coerce.date().optional().nullable(),
      retryCount: z.number().int().optional(),
      maxRetries: z.number().int().optional(),
      errorMessage: z.string().optional().nullable(),
      conflictResolution: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      syncWindowStart: z.coerce.date().optional().nullable(),
      syncWindowEnd: z.coerce.date().optional().nullable(),
      eventsProcessed: z.number().int().optional(),
      eventsSucceeded: z.number().int().optional(),
      eventsFailed: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationCreateOrConnectWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarSyncOperationCreateManyCalendarIntegrationInputEnvelopeSchema: z.ZodType<Prisma.CalendarSyncOperationCreateManyCalendarIntegrationInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalendarSyncOperationCreateManyCalendarIntegrationInputSchema),
        z.lazy(() => CalendarSyncOperationCreateManyCalendarIntegrationInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderUpsertWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutCalendarIntegrationInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutCalendarIntegrationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutCalendarIntegrationInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarEventUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUpsertWithWhereUniqueWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarEventWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalendarEventUpdateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarEventUncheckedUpdateWithoutCalendarIntegrationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalendarEventCreateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarEventUncheckedCreateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarEventUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUpdateWithWhereUniqueWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarEventWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalendarEventUpdateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarEventUncheckedUpdateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarEventUpdateManyWithWhereWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUpdateManyWithWhereWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarEventScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalendarEventUpdateManyMutationInputSchema),
        z.lazy(() => CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarEventScalarWhereInputSchema: z.ZodType<Prisma.CalendarEventScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarEventScalarWhereInputSchema),
          z.lazy(() => CalendarEventScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarEventScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarEventScalarWhereInputSchema),
          z.lazy(() => CalendarEventScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      calendarIntegrationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      externalEventId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      externalCalendarId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      etag: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      title: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      startTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      endTime: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      isAllDay: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      lastSyncedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      eventType: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      blocksAvailability: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      syncStatus: z
        .union([
          z.lazy(() => EnumCalendarEventSyncStatusFilterSchema),
          z.lazy(() => CalendarEventSyncStatusSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      hasConflict: z.union([z.lazy(() => BoolFilterSchema), z.boolean()]).optional(),
      conflictDetails: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      version: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const CalendarSyncOperationUpsertWithWhereUniqueWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpsertWithWhereUniqueWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalendarSyncOperationUpdateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarSyncOperationUncheckedUpdateWithoutCalendarIntegrationInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalendarSyncOperationCreateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarSyncOperationUncheckedCreateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarSyncOperationUpdateWithWhereUniqueWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateWithWhereUniqueWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarSyncOperationWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalendarSyncOperationUpdateWithoutCalendarIntegrationInputSchema),
        z.lazy(() => CalendarSyncOperationUncheckedUpdateWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarSyncOperationUpdateManyWithWhereWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateManyWithWhereWithoutCalendarIntegrationInput> =
  z
    .object({
      where: z.lazy(() => CalendarSyncOperationScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalendarSyncOperationUpdateManyMutationInputSchema),
        z.lazy(() => CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationInputSchema),
      ]),
    })
    .strict();

export const CalendarSyncOperationScalarWhereInputSchema: z.ZodType<Prisma.CalendarSyncOperationScalarWhereInput> =
  z
    .object({
      AND: z
        .union([
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema),
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema).array(),
        ])
        .optional(),
      OR: z
        .lazy(() => CalendarSyncOperationScalarWhereInputSchema)
        .array()
        .optional(),
      NOT: z
        .union([
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema),
          z.lazy(() => CalendarSyncOperationScalarWhereInputSchema).array(),
        ])
        .optional(),
      id: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      calendarIntegrationId: z.union([z.lazy(() => StringFilterSchema), z.string()]).optional(),
      operationType: z
        .union([
          z.lazy(() => EnumCalendarSyncOperationTypeFilterSchema),
          z.lazy(() => CalendarSyncOperationTypeSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => EnumCalendarSyncSourceFilterSchema),
          z.lazy(() => CalendarSyncSourceSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => EnumCalendarSyncStatusFilterSchema),
          z.lazy(() => CalendarSyncStatusSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => EnumCalendarEntityTypeFilterSchema),
          z.lazy(() => CalendarEntityTypeSchema),
        ])
        .optional(),
      entityId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      startedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      completedAt: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      retryCount: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      maxRetries: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      errorMessage: z
        .union([z.lazy(() => StringNullableFilterSchema), z.string()])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => EnumConflictResolutionNullableFilterSchema),
          z.lazy(() => ConflictResolutionSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.lazy(() => DateTimeNullableFilterSchema), z.coerce.date()])
        .optional()
        .nullable(),
      eventsProcessed: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      eventsSucceeded: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      eventsFailed: z.union([z.lazy(() => IntFilterSchema), z.number()]).optional(),
      createdAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
      updatedAt: z.union([z.lazy(() => DateTimeFilterSchema), z.coerce.date()]).optional(),
    })
    .strict();

export const CalendarIntegrationCreateWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateWithoutCalendarEventsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutCalendarIntegrationInputSchema
      ),
      syncOperations: z
        .lazy(() => CalendarSyncOperationCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedCreateWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedCreateWithoutCalendarEventsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      syncOperations: z
        .lazy(
          () => CalendarSyncOperationUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateOrConnectWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateOrConnectWithoutCalendarEventsInput> =
  z
    .object({
      where: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalendarIntegrationCreateWithoutCalendarEventsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedCreateWithoutCalendarEventsInputSchema),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      availability: z.lazy(() => AvailabilityCreateNestedOneWithoutCalculatedSlotsInputSchema),
      service: z.lazy(() => ServiceCreateNestedOneWithoutCalculatedSlotsInputSchema),
      serviceConfig: z.lazy(
        () => ServiceAvailabilityConfigCreateNestedOneWithoutCalculatedSlotsInputSchema
      ),
      booking: z.lazy(() => BookingCreateNestedOneWithoutSlotInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionCreateNestedOneWithoutBilledSlotsInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      booking: z.lazy(() => BookingUncheckedCreateNestedOneWithoutSlotInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateOrConnectWithoutBlockedByCalendarEventInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputEnvelopeSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputEnvelope> =
  z
    .object({
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputSchema),
        z.lazy(() => CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputSchema).array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarIntegrationUpsertWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationUpsertWithoutCalendarEventsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CalendarIntegrationUpdateWithoutCalendarEventsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutCalendarEventsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalendarIntegrationCreateWithoutCalendarEventsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedCreateWithoutCalendarEventsInputSchema),
      ]),
      where: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
    })
    .strict();

export const CalendarIntegrationUpdateToOneWithWhereWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateToOneWithWhereWithoutCalendarEventsInput> =
  z
    .object({
      where: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CalendarIntegrationUpdateWithoutCalendarEventsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutCalendarEventsInputSchema),
      ]),
    })
    .strict();

export const CalendarIntegrationUpdateWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateWithoutCalendarEventsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      syncOperations: z
        .lazy(() => CalendarSyncOperationUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedUpdateWithoutCalendarEventsInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedUpdateWithoutCalendarEventsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      syncOperations: z
        .lazy(
          () => CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertWithWhereUniqueWithoutBlockedByCalendarEventInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      update: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBlockedByCalendarEventInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateWithoutBlockedByCalendarEventInputSchema
        ),
      ]),
      create: z.union([
        z.lazy(() => CalculatedAvailabilitySlotCreateWithoutBlockedByCalendarEventInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedCreateWithoutBlockedByCalendarEventInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithWhereUniqueWithoutBlockedByCalendarEventInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotWhereUniqueInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateWithoutBlockedByCalendarEventInputSchema),
        z.lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateWithoutBlockedByCalendarEventInputSchema
        ),
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyWithWhereWithoutBlockedByCalendarEventInput> =
  z
    .object({
      where: z.lazy(() => CalculatedAvailabilitySlotScalarWhereInputSchema),
      data: z.union([
        z.lazy(() => CalculatedAvailabilitySlotUpdateManyMutationInputSchema),
        z.lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventInputSchema
        ),
      ]),
    })
    .strict();

export const CalendarIntegrationCreateWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateWithoutSyncOperationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      serviceProvider: z.lazy(
        () => ServiceProviderCreateNestedOneWithoutCalendarIntegrationInputSchema
      ),
      calendarEvents: z
        .lazy(() => CalendarEventCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedCreateWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedCreateWithoutSyncOperationsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      provider: z.string(),
      accessToken: z.string(),
      refreshToken: z.string(),
      expiresAt: z.coerce.date(),
      calendarId: z.string().optional().nullable(),
      syncEnabled: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional().nullable(),
      googleEmail: z.string().optional().nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationCreategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z.string().optional().nullable(),
      webhookResourceId: z.string().optional().nullable(),
      webhookExpiresAt: z.coerce.date().optional().nullable(),
      nextSyncToken: z.string().optional().nullable(),
      syncDirection: z.lazy(() => CalendarSyncDirectionSchema).optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationCreateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z.boolean().optional(),
      backgroundSyncEnabled: z.boolean().optional(),
      syncIntervalMinutes: z.number().int().optional(),
      lastFullSyncAt: z.coerce.date().optional().nullable(),
      syncFailureCount: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUncheckedCreateNestedManyWithoutCalendarIntegrationInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationCreateOrConnectWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationCreateOrConnectWithoutSyncOperationsInput> =
  z
    .object({
      where: z.lazy(() => CalendarIntegrationWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => CalendarIntegrationCreateWithoutSyncOperationsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedCreateWithoutSyncOperationsInputSchema),
      ]),
    })
    .strict();

export const CalendarIntegrationUpsertWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationUpsertWithoutSyncOperationsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => CalendarIntegrationUpdateWithoutSyncOperationsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutSyncOperationsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => CalendarIntegrationCreateWithoutSyncOperationsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedCreateWithoutSyncOperationsInputSchema),
      ]),
      where: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
    })
    .strict();

export const CalendarIntegrationUpdateToOneWithWhereWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateToOneWithWhereWithoutSyncOperationsInput> =
  z
    .object({
      where: z.lazy(() => CalendarIntegrationWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => CalendarIntegrationUpdateWithoutSyncOperationsInputSchema),
        z.lazy(() => CalendarIntegrationUncheckedUpdateWithoutSyncOperationsInputSchema),
      ]),
    })
    .strict();

export const CalendarIntegrationUpdateWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationUpdateWithoutSyncOperationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalendarIntegrationUncheckedUpdateWithoutSyncOperationsInputSchema: z.ZodType<Prisma.CalendarIntegrationUncheckedUpdateWithoutSyncOperationsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      accessToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refreshToken: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      googleEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      grantedScopes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdategrantedScopesInputSchema),
          z.string().array(),
        ])
        .optional(),
      meetSettings: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      webhookChannelId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookResourceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      webhookExpiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      nextSyncToken: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncDirection: z
        .union([
          z.lazy(() => CalendarSyncDirectionSchema),
          z.lazy(() => EnumCalendarSyncDirectionFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      blockingEventTypes: z
        .union([
          z.lazy(() => CalendarIntegrationUpdateblockingEventTypesInputSchema),
          z.string().array(),
        ])
        .optional(),
      autoCreateMeetLinks: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      backgroundSyncEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncIntervalMinutes: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      lastFullSyncAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncFailureCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calendarEvents: z
        .lazy(() => CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingCreateWithoutMeetSessionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutMeetSessionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutMeetSessionInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutMeetSessionInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutMeetSessionInputSchema),
      ]),
    })
    .strict();

export const BookingUpsertWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingUpsertWithoutMeetSessionInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BookingUpdateWithoutMeetSessionInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutMeetSessionInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutMeetSessionInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutMeetSessionInputSchema),
      ]),
      where: z.lazy(() => BookingWhereInputSchema).optional(),
    })
    .strict();

export const BookingUpdateToOneWithWhereWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingUpdateToOneWithWhereWithoutMeetSessionInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutMeetSessionInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutMeetSessionInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingUpdateWithoutMeetSessionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutMeetSessionInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutMeetSessionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const ServiceProviderCreateWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderCreateWithoutReviewsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      user: z.lazy(() => UserCreateNestedOneWithoutServiceProviderInputSchema),
      serviceProviderType: z.lazy(
        () => ServiceProviderTypeCreateNestedOneWithoutServiceProvidersInputSchema
      ),
      approvedBy: z.lazy(() => UserCreateNestedOneWithoutProvidersApprovedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z.lazy(() => ServiceCreateNestedManyWithoutProvidersInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedCreateWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedCreateWithoutReviewsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedCreateNestedManyWithoutProvidersInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedCreateNestedOneWithoutServiceProviderInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedCreateNestedManyWithoutServiceProviderInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedCreateNestedManyWithoutServiceProviderInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderCreateOrConnectWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderCreateOrConnectWithoutReviewsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutReviewsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutReviewsInputSchema),
      ]),
    })
    .strict();

export const UserCreateWithoutReviewsInputSchema: z.ZodType<Prisma.UserCreateWithoutReviewsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingCreateNestedManyWithoutClientInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingCreateNestedManyWithoutCreatedByInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryCreateNestedManyWithoutChangedByInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedCreateWithoutReviewsInputSchema: z.ZodType<Prisma.UserUncheckedCreateWithoutReviewsInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      emailVerified: z.coerce.date().optional().nullable(),
      phone: z.string().optional().nullable(),
      phoneVerified: z.coerce.date().optional().nullable(),
      whatsapp: z.string().optional().nullable(),
      whatsappVerified: z.coerce.date().optional().nullable(),
      password: z.string().optional().nullable(),
      image: z.string().optional().nullable(),
      role: z.lazy(() => UserRoleSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      accounts: z.lazy(() => AccountUncheckedCreateNestedManyWithoutUserInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedCreateNestedOneWithoutUserInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutClientInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedCreateNestedManyWithoutConfirmedByInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedCreateNestedManyWithoutUserInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedCreateNestedManyWithoutChangedByInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutCreatedByInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedCreateNestedManyWithoutAcceptedByInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedCreateNestedManyWithoutApprovedByInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedCreateNestedManyWithoutInvitedByInputSchema)
        .optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedCreateNestedManyWithoutValidatedByInputSchema)
        .optional(),
    })
    .strict();

export const UserCreateOrConnectWithoutReviewsInputSchema: z.ZodType<Prisma.UserCreateOrConnectWithoutReviewsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => UserCreateWithoutReviewsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReviewsInputSchema),
      ]),
    })
    .strict();

export const BookingCreateWithoutReviewInputSchema: z.ZodType<Prisma.BookingCreateWithoutReviewInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotCreateNestedOneWithoutBookingInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserCreateNestedOneWithoutBookingsCreatedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipCreateNestedOneWithoutBookingsCreatedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserCreateNestedOneWithoutBookingsConfirmedInputSchema).optional(),
      client: z.lazy(() => UserCreateNestedOneWithoutBookingsAsClientInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      meetSession: z.lazy(() => MeetSessionCreateNestedOneWithoutBookingInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedCreateWithoutReviewInputSchema: z.ZodType<Prisma.BookingUncheckedCreateWithoutReviewInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedCreateNestedManyWithoutBookingInputSchema)
        .optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedCreateNestedOneWithoutBookingInputSchema)
        .optional(),
    })
    .strict();

export const BookingCreateOrConnectWithoutReviewInputSchema: z.ZodType<Prisma.BookingCreateOrConnectWithoutReviewInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereUniqueInputSchema),
      create: z.union([
        z.lazy(() => BookingCreateWithoutReviewInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutReviewInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpsertWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderUpsertWithoutReviewsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutReviewsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutReviewsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => ServiceProviderCreateWithoutReviewsInputSchema),
        z.lazy(() => ServiceProviderUncheckedCreateWithoutReviewsInputSchema),
      ]),
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
    })
    .strict();

export const ServiceProviderUpdateToOneWithWhereWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateToOneWithWhereWithoutReviewsInput> =
  z
    .object({
      where: z.lazy(() => ServiceProviderWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => ServiceProviderUpdateWithoutReviewsInputSchema),
        z.lazy(() => ServiceProviderUncheckedUpdateWithoutReviewsInputSchema),
      ]),
    })
    .strict();

export const ServiceProviderUpdateWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutReviewsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutReviewsInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutReviewsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUpsertWithoutReviewsInputSchema: z.ZodType<Prisma.UserUpsertWithoutReviewsInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => UserUpdateWithoutReviewsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReviewsInputSchema),
      ]),
      create: z.union([
        z.lazy(() => UserCreateWithoutReviewsInputSchema),
        z.lazy(() => UserUncheckedCreateWithoutReviewsInputSchema),
      ]),
      where: z.lazy(() => UserWhereInputSchema).optional(),
    })
    .strict();

export const UserUpdateToOneWithWhereWithoutReviewsInputSchema: z.ZodType<Prisma.UserUpdateToOneWithWhereWithoutReviewsInput> =
  z
    .object({
      where: z.lazy(() => UserWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => UserUpdateWithoutReviewsInputSchema),
        z.lazy(() => UserUncheckedUpdateWithoutReviewsInputSchema),
      ]),
    })
    .strict();

export const UserUpdateWithoutReviewsInputSchema: z.ZodType<Prisma.UserUpdateWithoutReviewsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z.lazy(() => BookingUpdateManyWithoutClientNestedInputSchema).optional(),
      bookingsCreated: z.lazy(() => BookingUpdateManyWithoutCreatedByNestedInputSchema).optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutChangedByNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const UserUncheckedUpdateWithoutReviewsInputSchema: z.ZodType<Prisma.UserUncheckedUpdateWithoutReviewsInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      emailVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phoneVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappVerified: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      password: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      role: z
        .union([
          z.lazy(() => UserRoleSchema),
          z.lazy(() => EnumUserRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      accounts: z.lazy(() => AccountUncheckedUpdateManyWithoutUserNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUncheckedUpdateOneWithoutUserNestedInputSchema)
        .optional(),
      bookingsAsClient: z
        .lazy(() => BookingUncheckedUpdateManyWithoutClientNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      bookingsConfirmed: z
        .lazy(() => BookingUncheckedUpdateManyWithoutConfirmedByNestedInputSchema)
        .optional(),
      communicationPreferences: z
        .lazy(() => CommunicationPreferenceUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      organizationMemberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutUserNestedInputSchema)
        .optional(),
      membershipHistoryChanges: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByNestedInputSchema
        )
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByNestedInputSchema)
        .optional(),
      availabilitiesAccepted: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAcceptedByNestedInputSchema)
        .optional(),
      organizationsApproved: z
        .lazy(() => OrganizationUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      providersApproved: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutApprovedByNestedInputSchema)
        .optional(),
      sentInvitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutInvitedByNestedInputSchema)
        .optional(),
      validatedRequirements: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutValidatedByNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUpsertWithoutReviewInputSchema: z.ZodType<Prisma.BookingUpsertWithoutReviewInput> =
  z
    .object({
      update: z.union([
        z.lazy(() => BookingUpdateWithoutReviewInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutReviewInputSchema),
      ]),
      create: z.union([
        z.lazy(() => BookingCreateWithoutReviewInputSchema),
        z.lazy(() => BookingUncheckedCreateWithoutReviewInputSchema),
      ]),
      where: z.lazy(() => BookingWhereInputSchema).optional(),
    })
    .strict();

export const BookingUpdateToOneWithWhereWithoutReviewInputSchema: z.ZodType<Prisma.BookingUpdateToOneWithWhereWithoutReviewInput> =
  z
    .object({
      where: z.lazy(() => BookingWhereInputSchema).optional(),
      data: z.union([
        z.lazy(() => BookingUpdateWithoutReviewInputSchema),
        z.lazy(() => BookingUncheckedUpdateWithoutReviewInputSchema),
      ]),
    })
    .strict();

export const BookingUpdateWithoutReviewInputSchema: z.ZodType<Prisma.BookingUpdateWithoutReviewInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutReviewInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutReviewInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const AccountCreateManyUserInputSchema: z.ZodType<Prisma.AccountCreateManyUserInput> = z
  .object({
    id: z.string().cuid().optional(),
    type: z.string(),
    provider: z.string(),
    providerAccountId: z.string(),
    refresh_token: z.string().optional().nullable(),
    access_token: z.string().optional().nullable(),
    expires_at: z.number().int().optional().nullable(),
    token_type: z.string().optional().nullable(),
    scope: z.string().optional().nullable(),
    id_token: z.string().optional().nullable(),
    session_state: z.string().optional().nullable(),
  })
  .strict();

export const BookingCreateManyClientInputSchema: z.ZodType<Prisma.BookingCreateManyClientInput> = z
  .object({
    id: z.string().cuid().optional(),
    slotId: z.string().optional().nullable(),
    createdById: z.string().optional().nullable(),
    createdByMembershipId: z.string().optional().nullable(),
    isProviderCreated: z.boolean().optional(),
    isGuestBooking: z.boolean().optional(),
    isGuestSelfBooking: z.boolean().optional(),
    confirmedById: z.string().optional().nullable(),
    confirmedAt: z.coerce.date().optional().nullable(),
    guestName: z.string().optional().nullable(),
    guestEmail: z.string().optional().nullable(),
    guestPhone: z.string().optional().nullable(),
    guestWhatsapp: z.string().optional().nullable(),
    price: z.number().positive(),
    isOnline: z.boolean(),
    isInPerson: z.boolean().optional(),
    status: z.lazy(() => BookingStatusSchema).optional(),
    notes: z.string().optional().nullable(),
    meetLink: z.string().optional().nullable(),
    calendarEventId: z.string().optional().nullable(),
    version: z.number().int().optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const BookingCreateManyCreatedByInputSchema: z.ZodType<Prisma.BookingCreateManyCreatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const BookingCreateManyConfirmedByInputSchema: z.ZodType<Prisma.BookingCreateManyConfirmedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CommunicationPreferenceCreateManyUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.boolean().optional(),
      sms: z.boolean().optional(),
      whatsapp: z.boolean().optional(),
      phoneNumber: z.string().optional().nullable(),
      whatsappNumber: z.string().optional().nullable(),
      reminderHours: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipCreateManyUserInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyUserInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyChangedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      membershipId: z.string(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyCreatedByInputSchema: z.ZodType<Prisma.AvailabilityCreateManyCreatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityCreateManyAcceptedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationCreateManyApprovedByInputSchema: z.ZodType<Prisma.OrganizationCreateManyApprovedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      phone: z.string().optional().nullable(),
      website: z.string().optional().nullable(),
      logo: z.string().optional().nullable(),
      status: z.lazy(() => OrganizationStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      billingModel: z.lazy(() => OrganizationBillingModelSchema).optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
    })
    .strict();

export const ServiceProviderCreateManyApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderCreateManyApprovedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      serviceProviderTypeId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
    })
    .strict();

export const OrganizationInvitationCreateManyInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyInvitedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      membershipId: z.string().optional().nullable(),
    })
    .strict();

export const ReviewCreateManyClientInputSchema: z.ZodType<Prisma.ReviewCreateManyClientInput> = z
  .object({
    id: z.string().cuid().optional(),
    serviceProviderId: z.string(),
    bookingId: z.string(),
    rating: z.number().int(),
    comment: z.string().optional().nullable(),
    response: z.string().optional().nullable(),
    isPublic: z.boolean().optional(),
    googleReviewId: z.string().optional().nullable(),
    status: z.lazy(() => ReviewStatusSchema).optional(),
    createdAt: z.coerce.date().optional(),
    updatedAt: z.coerce.date().optional(),
  })
  .strict();

export const RequirementSubmissionCreateManyValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyValidatedByInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      requirementTypeId: z.string(),
      serviceProviderId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AccountUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      providerAccountId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refresh_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      access_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      token_type: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      scope: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      id_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      session_state: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const AccountUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      providerAccountId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refresh_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      access_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      token_type: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      scope: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      id_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      session_state: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const AccountUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.AccountUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      type: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      provider: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      providerAccountId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      refresh_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      access_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      expires_at: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      token_type: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      scope: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      id_token: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      session_state: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const BookingUpdateWithoutClientInputSchema: z.ZodType<Prisma.BookingUpdateWithoutClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutClientInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutClientInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const BookingUpdateWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUpdateWithoutCreatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutCreatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutCreatedByInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutCreatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const BookingUpdateWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUpdateWithoutConfirmedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutBookingsCreatedNestedInputSchema)
        .optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutConfirmedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutConfirmedByInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutConfirmedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUpdateWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.CommunicationPreferenceUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      sms: z.union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      phoneNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      whatsappNumber: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      reminderHours: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipUpdateWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutMembershipsNestedInputSchema)
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateManyWithoutUserInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateManyWithoutUserInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateWithoutChangedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      membership: z
        .lazy(() => OrganizationMembershipUpdateOneRequiredWithoutHistoryNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateWithoutChangedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      membershipId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateManyWithoutChangedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      membershipId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutCreatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutCreatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutCreatedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutCreatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutAcceptedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutAcceptedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutAcceptedByInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutAcceptedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationUpdateWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUpdateWithoutApprovedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      locations: z.lazy(() => LocationUpdateManyWithoutOrganizationNestedInputSchema).optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateWithoutApprovedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      invitations: z
        .lazy(() => OrganizationInvitationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      memberships: z
        .lazy(() => OrganizationMembershipUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationNestedInputSchema
        )
        .optional(),
      locations: z
        .lazy(() => LocationUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutOrganizationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationUncheckedUpdateManyWithoutApprovedByInputSchema: z.ZodType<Prisma.OrganizationUncheckedUpdateManyWithoutApprovedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      logo: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => OrganizationStatusSchema),
          z.lazy(() => EnumOrganizationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingModel: z
        .union([
          z.lazy(() => OrganizationBillingModelSchema),
          z.lazy(() => EnumOrganizationBillingModelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const ServiceProviderUpdateWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutApprovedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutApprovedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyWithoutApprovedByInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyWithoutApprovedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUpdateWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateWithoutInvitedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutInvitationsNestedInputSchema)
        .optional(),
      membership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutInvitationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateWithoutInvitedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateManyWithoutInvitedByInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateManyWithoutInvitedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const ReviewUpdateWithoutClientInputSchema: z.ZodType<Prisma.ReviewUpdateWithoutClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutReviewsNestedInputSchema)
        .optional(),
      booking: z.lazy(() => BookingUpdateOneRequiredWithoutReviewNestedInputSchema).optional(),
    })
    .strict();

export const ReviewUncheckedUpdateWithoutClientInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateWithoutClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ReviewUncheckedUpdateManyWithoutClientInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateManyWithoutClientInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUpdateWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateWithoutValidatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementType: z
        .lazy(() => RequirementTypeUpdateOneRequiredWithoutSubmissionsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutRequirementSubmissionsNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateWithoutValidatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyWithoutValidatedByInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyWithoutValidatedByInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementTypeCreateManyServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeCreateManyServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      isRequired: z.boolean().optional(),
      validationType: z.lazy(() => RequirementValidationTypeSchema),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceCreateManyServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceCreateManyServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      description: z.string().optional().nullable(),
      displayPriority: z.number().int().optional(),
      defaultDuration: z.number().int(),
      defaultPrice: z.number().positive(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceProviderCreateManyServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderCreateManyServiceProviderTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      userId: z.string(),
      bio: z.string().optional().nullable(),
      image: z.string(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderCreatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z.string().optional().nullable(),
      email: z.string().optional(),
      whatsapp: z.string().optional(),
      status: z.lazy(() => ServiceProviderStatusSchema).optional(),
      approvedById: z.string().optional().nullable(),
      approvedAt: z.coerce.date().optional().nullable(),
      rejectedAt: z.coerce.date().optional().nullable(),
      rejectionReason: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      averageRating: z.number().optional().nullable(),
      totalReviews: z.number().int().optional(),
      trialStarted: z.coerce.date().optional().nullable(),
      trialEnded: z.coerce.date().optional().nullable(),
      trialStatus: z
        .lazy(() => TrialStatusSchema)
        .optional()
        .nullable(),
      paymentMethodAdded: z.boolean().optional(),
      trialReminderSent: z.boolean().optional(),
      trialConversionDate: z.coerce.date().optional().nullable(),
      selfPaidBookingsEnabled: z.boolean().optional(),
    })
    .strict();

export const RequirementTypeUpdateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUpdateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      submissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutRequirementTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedUpdateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedUpdateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      submissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.RequirementTypeUncheckedUpdateManyWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isRequired: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      validationType: z
        .union([
          z.lazy(() => RequirementValidationTypeSchema),
          z.lazy(() => EnumRequirementValidationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      validationConfig: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceUpdateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUpdateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      providers: z.lazy(() => ServiceProviderUpdateManyWithoutServicesNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      providers: z
        .lazy(() => ServiceProviderUncheckedUpdateManyWithoutServicesNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateManyWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceProviderUpdateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z.lazy(() => ServiceUpdateManyWithoutProvidersNestedInputSchema).optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      services: z
        .lazy(() => ServiceUncheckedUpdateManyWithoutProvidersNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyWithoutServiceProviderTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ReviewCreateManyServiceProviderInputSchema: z.ZodType<Prisma.ReviewCreateManyServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      clientId: z.string(),
      bookingId: z.string(),
      rating: z.number().int(),
      comment: z.string().optional().nullable(),
      response: z.string().optional().nullable(),
      isPublic: z.boolean().optional(),
      googleReviewId: z.string().optional().nullable(),
      status: z.lazy(() => ReviewStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionCreateManyServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      requirementTypeId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      validatedById: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityCreateManyServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const SubscriptionCreateManyServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionCreateManyServiceProviderInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ReviewUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      client: z.lazy(() => UserUpdateOneRequiredWithoutReviewsNestedInputSchema).optional(),
      booking: z.lazy(() => BookingUpdateOneRequiredWithoutReviewNestedInputSchema).optional(),
    })
    .strict();

export const ReviewUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      clientId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ReviewUncheckedUpdateManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.ReviewUncheckedUpdateManyWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      clientId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      rating: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      comment: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      response: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isPublic: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      googleReviewId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => ReviewStatusSchema),
          z.lazy(() => EnumReviewStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementType: z
        .lazy(() => RequirementTypeUpdateOneRequiredWithoutSubmissionsNestedInputSchema)
        .optional(),
      validatedBy: z
        .lazy(() => UserUpdateOneWithoutValidatedRequirementsNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      requirementTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceUpdateWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUpdateWithoutProvidersInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServicesNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateWithoutProvidersInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceUncheckedUpdateManyWithoutProvidersInputSchema: z.ZodType<Prisma.ServiceUncheckedUpdateManyWithoutProvidersInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      description: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      displayPriority: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultDuration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      defaultPrice: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceConfigNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      organization: z
        .lazy(() => OrganizationUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutProviderConnectionNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutProviderConnectionNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const SubscriptionUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutServiceProviderInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutServiceProviderInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionCreateManyOrganizationInputSchema: z.ZodType<Prisma.SubscriptionCreateManyOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationInvitationCreateManyOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      email: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.string(),
      expiresAt: z.coerce.date(),
      invitedById: z.string(),
      status: z.lazy(() => InvitationStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
      membershipId: z.string().optional().nullable(),
    })
    .strict();

export const OrganizationMembershipCreateManyOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      userId: z.string(),
      role: z.lazy(() => OrganizationRoleSchema),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipCreatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z.lazy(() => MembershipStatusSchema).optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      status: z.lazy(() => ConnectionStatusSchema).optional(),
      defaultBilledBy: z.lazy(() => BillingEntitySchema).optional(),
      requestedAt: z.coerce.date().optional(),
      acceptedAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const LocationCreateManyOrganizationInputSchema: z.ZodType<Prisma.LocationCreateManyOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      name: z.string(),
      googlePlaceId: z.string(),
      formattedAddress: z.string(),
      coordinates: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      addressComponents: z.union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema]),
      city: z.string(),
      country: z.string().optional(),
      phone: z.string().optional().nullable(),
      email: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyOrganizationInputSchema: z.ZodType<Prisma.AvailabilityCreateManyOrganizationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SubscriptionUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutOrganizationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationInvitationUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      invitedBy: z
        .lazy(() => UserUpdateOneRequiredWithoutSentInvitationsNestedInputSchema)
        .optional(),
      membership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutInvitationNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationInvitationUncheckedUpdateManyWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationInvitationUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      token: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => InvitationStatusSchema),
          z.lazy(() => EnumInvitationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      membershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const OrganizationMembershipUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z
        .lazy(() => UserUpdateOneRequiredWithoutOrganizationMembershipsNestedInputSchema)
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(() => OrganizationMembershipHistoryUpdateManyWithoutMembershipNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      invitation: z
        .lazy(() => OrganizationInvitationUncheckedUpdateOneWithoutMembershipNestedInputSchema)
        .optional(),
      bookingsCreated: z
        .lazy(() => BookingUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      availabilitiesCreated: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipNestedInputSchema)
        .optional(),
      history: z
        .lazy(
          () => OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationMembershipUncheckedUpdateManyWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      role: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => EnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      permissions: z
        .union([
          z.lazy(() => OrganizationMembershipUpdatepermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => EnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutProviderConnectionsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutProviderConnectionNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutProviderConnectionNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationInputSchema: z.ZodType<Prisma.OrganizationProviderConnectionUncheckedUpdateManyWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ConnectionStatusSchema),
          z.lazy(() => EnumConnectionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      defaultBilledBy: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => EnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      requestedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const LocationUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutLocationNestedInputSchema)
        .optional(),
    })
    .strict();

export const LocationUncheckedUpdateManyWithoutOrganizationInputSchema: z.ZodType<Prisma.LocationUncheckedUpdateManyWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      googlePlaceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      formattedAddress: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      coordinates: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      addressComponents: z
        .union([z.lazy(() => JsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      city: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      country: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      phone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutOrganizationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutOrganizationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const BookingCreateManyCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingCreateManyCreatedByMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string().optional().nullable(),
      createdById: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      isGuestBooking: z.boolean().optional(),
      isGuestSelfBooking: z.boolean().optional(),
      confirmedById: z.string().optional().nullable(),
      confirmedAt: z.coerce.date().optional().nullable(),
      clientId: z.string().optional().nullable(),
      guestName: z.string().optional().nullable(),
      guestEmail: z.string().optional().nullable(),
      guestPhone: z.string().optional().nullable(),
      guestWhatsapp: z.string().optional().nullable(),
      price: z.number().positive(),
      isOnline: z.boolean(),
      isInPerson: z.boolean().optional(),
      status: z.lazy(() => BookingStatusSchema).optional(),
      notes: z.string().optional().nullable(),
      meetLink: z.string().optional().nullable(),
      calendarEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityCreateManyCreatedByMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyMembershipInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      changeType: z.lazy(() => MembershipChangeTypeSchema),
      oldRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      newRole: z
        .lazy(() => OrganizationRoleSchema)
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryCreatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      newStatus: z
        .lazy(() => MembershipStatusSchema)
        .optional()
        .nullable(),
      changedById: z.string(),
      changeReason: z.string().optional().nullable(),
      ipAddress: z.string().optional().nullable(),
      userAgent: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const BookingUpdateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUpdateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slot: z
        .lazy(() => CalculatedAvailabilitySlotUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
      createdBy: z.lazy(() => UserUpdateOneWithoutBookingsCreatedNestedInputSchema).optional(),
      confirmedBy: z.lazy(() => UserUpdateOneWithoutBookingsConfirmedNestedInputSchema).optional(),
      client: z.lazy(() => UserUpdateOneWithoutBookingsAsClientNestedInputSchema).optional(),
      communications: z
        .lazy(() => CommunicationLogUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z.lazy(() => MeetSessionUpdateOneWithoutBookingNestedInputSchema).optional(),
    })
    .strict();

export const BookingUncheckedUpdateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      communications: z
        .lazy(() => CommunicationLogUncheckedUpdateManyWithoutBookingNestedInputSchema)
        .optional(),
      review: z.lazy(() => ReviewUncheckedUpdateOneWithoutBookingNestedInputSchema).optional(),
      meetSession: z
        .lazy(() => MeetSessionUncheckedUpdateOneWithoutBookingNestedInputSchema)
        .optional(),
    })
    .strict();

export const BookingUncheckedUpdateManyWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.BookingUncheckedUpdateManyWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isGuestSelfBooking: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      confirmedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      confirmedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestEmail: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestPhone: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      guestWhatsapp: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnline: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => BookingStatusSchema),
          z.lazy(() => EnumBookingStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      meetLink: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      calendarEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutCreatedByMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUpdateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateWithoutMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      changedBy: z
        .lazy(() => UserUpdateOneRequiredWithoutMembershipHistoryChangesNestedInputSchema)
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateWithoutMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipInputSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUncheckedUpdateManyWithoutMembershipInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeType: z
        .union([
          z.lazy(() => MembershipChangeTypeSchema),
          z.lazy(() => EnumMembershipChangeTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      oldRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newRole: z
        .union([
          z.lazy(() => OrganizationRoleSchema),
          z.lazy(() => NullableEnumOrganizationRoleFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      oldPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdateoldPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      newPermissions: z
        .union([
          z.lazy(() => OrganizationMembershipHistoryUpdatenewPermissionsInputSchema),
          z.lazy(() => OrganizationPermissionSchema).array(),
        ])
        .optional(),
      oldStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      newStatus: z
        .union([
          z.lazy(() => MembershipStatusSchema),
          z.lazy(() => NullableEnumMembershipStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      changedById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      changeReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      ipAddress: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      userAgent: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionCreateManyLocationInputSchema: z.ZodType<Prisma.SubscriptionCreateManyLocationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      planId: z.string(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyLocationInputSchema: z.ZodType<Prisma.AvailabilityCreateManyLocationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SubscriptionUpdateWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutLocationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      plan: z
        .lazy(() => SubscriptionPlanUpdateOneRequiredWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutLocationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutLocationInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutLocationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      planId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutLocationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutLocationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutLocationInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutLocationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityCreateManyProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityCreateManyProviderConnectionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      defaultSubscriptionId: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutProviderConnectionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutProviderConnectionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutProviderConnectionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutProviderConnectionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const PaymentCreateManySubscriptionInputSchema: z.ZodType<Prisma.PaymentCreateManySubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      amount: z.number().positive(),
      baseAmount: z.number().positive().optional().nullable(),
      usageAmount: z.number().positive().optional().nullable(),
      currency: z.string(),
      status: z.lazy(() => PaymentStatusSchema),
      stripePaymentId: z.string().optional().nullable(),
      stripeInvoiceId: z.string().optional().nullable(),
      paidAt: z.coerce.date().optional().nullable(),
      failureReason: z.string().optional().nullable(),
      billingPeriodStart: z.coerce.date().optional().nullable(),
      billingPeriodEnd: z.coerce.date().optional().nullable(),
      slotsCovered: z.number().int().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const UsageRecordCreateManySubscriptionInputSchema: z.ZodType<Prisma.UsageRecordCreateManySubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      slotId: z.string(),
      slotDate: z.coerce.date(),
      slotStatus: z.lazy(() => SlotStatusSchema),
      billingCycle: z.string(),
      serviceProviderId: z.string(),
      serviceId: z.string(),
      tierUsed: z.number().int(),
      priceCharged: z.number().positive(),
      processed: z.boolean().optional(),
      processedAt: z.coerce.date().optional().nullable(),
      createdAt: z.coerce.date().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyBilledToSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityCreateManyDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityCreateManyDefaultSubscriptionInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      connectionId: z.string().optional().nullable(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      createdById: z.string(),
      createdByMembershipId: z.string().optional().nullable(),
      isProviderCreated: z.boolean().optional(),
      status: z.lazy(() => AvailabilityStatusSchema).optional(),
      acceptedById: z.string().optional().nullable(),
      acceptedAt: z.coerce.date().optional().nullable(),
      requiresConfirmation: z.boolean().optional(),
      billingEntity: z
        .lazy(() => BillingEntitySchema)
        .optional()
        .nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const PaymentUpdateWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUpdateWithoutSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      amount: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      baseAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      usageAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stripePaymentId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeInvoiceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      paidAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      failureReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      slotsCovered: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const PaymentUncheckedUpdateWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateWithoutSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      amount: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      baseAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      usageAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stripePaymentId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeInvoiceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      paidAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      failureReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      slotsCovered: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const PaymentUncheckedUpdateManyWithoutSubscriptionInputSchema: z.ZodType<Prisma.PaymentUncheckedUpdateManyWithoutSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      amount: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      baseAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      usageAmount: z
        .union([
          z.number().positive(),
          z.lazy(() => NullableDecimalFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      currency: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => PaymentStatusSchema),
          z.lazy(() => EnumPaymentStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      stripePaymentId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeInvoiceId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      paidAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      failureReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      billingPeriodEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      slotsCovered: z
        .union([z.number().int(), z.lazy(() => NullableIntFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UsageRecordUpdateWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUpdateWithoutSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      tierUsed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      priceCharged: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      processed: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      processedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UsageRecordUncheckedUpdateWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUncheckedUpdateWithoutSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      tierUsed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      priceCharged: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      processed: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      processedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const UsageRecordUncheckedUpdateManyWithoutSubscriptionInputSchema: z.ZodType<Prisma.UsageRecordUncheckedUpdateManyWithoutSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      slotDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      slotStatus: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      billingCycle: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      tierUsed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      priceCharged: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      processed: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      processedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithoutBilledToSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availability: z
        .lazy(() => AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      serviceConfig: z
        .lazy(
          () => ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema
        )
        .optional(),
      booking: z.lazy(() => BookingUpdateOneWithoutSlotNestedInputSchema).optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateWithoutBilledToSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingUncheckedUpdateOneWithoutSlotNestedInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutDefaultSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      availableServices: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutDefaultSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availableServices: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesNestedInputSchema
        )
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const SubscriptionCreateManyPlanInputSchema: z.ZodType<Prisma.SubscriptionCreateManyPlanInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      organizationId: z.string().optional().nullable(),
      locationId: z.string().optional().nullable(),
      serviceProviderId: z.string().optional().nullable(),
      status: z.lazy(() => SubscriptionStatusSchema),
      type: z.lazy(() => SubscriptionTypeSchema).optional(),
      isActive: z.boolean().optional(),
      trialStart: z.coerce.date().optional().nullable(),
      trialEnd: z.coerce.date().optional().nullable(),
      startDate: z.coerce.date(),
      endDate: z.coerce.date().optional().nullable(),
      cancelledAt: z.coerce.date().optional().nullable(),
      cancelReason: z.string().optional().nullable(),
      stripeCustomerId: z.string().optional().nullable(),
      stripeSubscriptionId: z.string().optional().nullable(),
      currentMonthSlots: z.number().int().optional(),
      billingCycleStart: z.coerce.date(),
      billingCycleEnd: z.coerce.date(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const SubscriptionUpdateWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUpdateWithoutPlanInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutSubscriptionsNestedInputSchema).optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneWithoutSubscriptionsNestedInputSchema)
        .optional(),
      payments: z.lazy(() => PaymentUpdateManyWithoutSubscriptionNestedInputSchema).optional(),
      usageRecords: z
        .lazy(() => UsageRecordUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateWithoutPlanInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      payments: z
        .lazy(() => PaymentUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      usageRecords: z
        .lazy(() => UsageRecordUncheckedUpdateManyWithoutSubscriptionNestedInputSchema)
        .optional(),
      billedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBilledToSubscriptionNestedInputSchema
        )
        .optional(),
      defaultForAvailabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutDefaultSubscriptionNestedInputSchema)
        .optional(),
    })
    .strict();

export const SubscriptionUncheckedUpdateManyWithoutPlanInputSchema: z.ZodType<Prisma.SubscriptionUncheckedUpdateManyWithoutPlanInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      status: z
        .union([
          z.lazy(() => SubscriptionStatusSchema),
          z.lazy(() => EnumSubscriptionStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      type: z
        .union([
          z.lazy(() => SubscriptionTypeSchema),
          z.lazy(() => EnumSubscriptionTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      isActive: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startDate: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelledAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      cancelReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeCustomerId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      stripeSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      currentMonthSlots: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleStart: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billingCycleEnd: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionCreateManyRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyRequirementTypeInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      status: z.lazy(() => RequirementsValidationStatusSchema).optional(),
      documentUrl: z.string().optional().nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z.coerce.date().optional().nullable(),
      notes: z.string().optional().nullable(),
      validatedAt: z.coerce.date().optional().nullable(),
      validatedById: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const RequirementSubmissionUpdateWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUpdateWithoutRequirementTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutRequirementSubmissionsNestedInputSchema)
        .optional(),
      validatedBy: z
        .lazy(() => UserUpdateOneWithoutValidatedRequirementsNestedInputSchema)
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateWithoutRequirementTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeInputSchema: z.ZodType<Prisma.RequirementSubmissionUncheckedUpdateManyWithoutRequirementTypeInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => RequirementsValidationStatusSchema),
          z.lazy(() => EnumRequirementsValidationStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      documentUrl: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      documentMetadata: z
        .union([z.lazy(() => NullableJsonNullValueInputSchema), InputJsonValueSchema])
        .optional(),
      expiresAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      notes: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      validatedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyServiceInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceProviderId: z.string(),
      duration: z.number().int(),
      price: z.number().positive(),
      isOnlineAvailable: z.boolean().optional(),
      isInPerson: z.boolean().optional(),
      location: z.string().optional().nullable(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyServiceInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceProviderUpdateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUpdateWithoutServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      user: z.lazy(() => UserUpdateOneRequiredWithoutServiceProviderNestedInputSchema).optional(),
      serviceProviderType: z
        .lazy(() => ServiceProviderTypeUpdateOneRequiredWithoutServiceProvidersNestedInputSchema)
        .optional(),
      approvedBy: z.lazy(() => UserUpdateOneWithoutProvidersApprovedNestedInputSchema).optional(),
      reviews: z.lazy(() => ReviewUpdateManyWithoutServiceProviderNestedInputSchema).optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(() => ServiceAvailabilityConfigUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(() => OrganizationProviderConnectionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateWithoutServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      reviews: z
        .lazy(() => ReviewUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      requirementSubmissions: z
        .lazy(() => RequirementSubmissionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      availabilityConfigs: z
        .lazy(
          () => ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
      calendarIntegration: z
        .lazy(() => CalendarIntegrationUncheckedUpdateOneWithoutServiceProviderNestedInputSchema)
        .optional(),
      providerConnections: z
        .lazy(
          () =>
            OrganizationProviderConnectionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema
        )
        .optional(),
      subscriptions: z
        .lazy(() => SubscriptionUncheckedUpdateManyWithoutServiceProviderNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceProviderUncheckedUpdateManyWithoutServicesInputSchema: z.ZodType<Prisma.ServiceProviderUncheckedUpdateManyWithoutServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      name: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      userId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderTypeId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bio: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      image: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      languages: z
        .union([
          z.lazy(() => ServiceProviderUpdatelanguagesInputSchema),
          z.lazy(() => LanguagesSchema).array(),
        ])
        .optional(),
      website: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      email: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      whatsapp: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => ServiceProviderStatusSchema),
          z.lazy(() => EnumServiceProviderStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      approvedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      approvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      rejectionReason: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      averageRating: z
        .union([z.number(), z.lazy(() => NullableFloatFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      totalReviews: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      trialStarted: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialEnded: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      trialStatus: z
        .union([
          z.lazy(() => TrialStatusSchema),
          z.lazy(() => NullableEnumTrialStatusFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      paymentMethodAdded: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialReminderSent: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      trialConversionDate: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      selfPaidBookingsEnabled: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithoutServiceInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceConfigNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateWithoutServiceInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilities: z
        .lazy(() => AvailabilityUncheckedUpdateManyWithoutAvailableServicesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyWithoutServiceInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithoutServiceInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availability: z
        .lazy(() => AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      serviceConfig: z
        .lazy(
          () => ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema
        )
        .optional(),
      booking: z.lazy(() => BookingUpdateOneWithoutSlotNestedInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingUncheckedUpdateOneWithoutSlotNestedInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyServiceConfigInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const AvailabilityUpdateWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUpdateWithoutAvailableServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      organization: z
        .lazy(() => OrganizationUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      location: z.lazy(() => LocationUpdateOneWithoutAvailabilitiesNestedInputSchema).optional(),
      providerConnection: z
        .lazy(() => OrganizationProviderConnectionUpdateOneWithoutAvailabilitiesNestedInputSchema)
        .optional(),
      createdBy: z
        .lazy(() => UserUpdateOneRequiredWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      createdByMembership: z
        .lazy(() => OrganizationMembershipUpdateOneWithoutAvailabilitiesCreatedNestedInputSchema)
        .optional(),
      acceptedBy: z
        .lazy(() => UserUpdateOneWithoutAvailabilitiesAcceptedNestedInputSchema)
        .optional(),
      defaultSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutDefaultForAvailabilitiesNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutAvailabilityNestedInputSchema)
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateWithoutAvailableServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const AvailabilityUncheckedUpdateManyWithoutAvailableServicesInputSchema: z.ZodType<Prisma.AvailabilityUncheckedUpdateManyWithoutAvailableServicesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      organizationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      locationId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      connectionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      createdById: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      createdByMembershipId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      isProviderCreated: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => AvailabilityStatusSchema),
          z.lazy(() => EnumAvailabilityStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      acceptedById: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      acceptedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      requiresConfirmation: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      billingEntity: z
        .union([
          z.lazy(() => BillingEntitySchema),
          z.lazy(() => NullableEnumBillingEntityFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      defaultSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithoutServiceConfigInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availability: z
        .lazy(() => AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      booking: z.lazy(() => BookingUpdateOneWithoutSlotNestedInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateWithoutServiceConfigInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingUncheckedUpdateOneWithoutSlotNestedInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyAvailabilityInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      blockedByEventId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      serviceProvider: z
        .lazy(() => ServiceProviderUpdateOneRequiredWithoutAvailabilityConfigsNestedInputSchema)
        .optional(),
      calculatedSlots: z
        .lazy(() => CalculatedAvailabilitySlotUpdateManyWithoutServiceConfigNestedInputSchema)
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      calculatedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUncheckedUpdateManyWithoutServiceConfigNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesInputSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUncheckedUpdateManyWithoutAvailabilitiesInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceProviderId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      duration: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      price: z
        .union([z.number().positive(), z.lazy(() => DecimalFieldUpdateOperationsInputSchema)])
        .optional(),
      isOnlineAvailable: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      isInPerson: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      location: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithoutAvailabilityInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      serviceConfig: z
        .lazy(
          () => ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema
        )
        .optional(),
      booking: z.lazy(() => BookingUpdateOneWithoutSlotNestedInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema)
        .optional(),
      blockedByCalendarEvent: z
        .lazy(() => CalendarEventUpdateOneWithoutBlockedSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateWithoutAvailabilityInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingUncheckedUpdateOneWithoutSlotNestedInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutAvailabilityInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blockedByEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CommunicationLogCreateManyBookingInputSchema: z.ZodType<Prisma.CommunicationLogCreateManyBookingInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      bookingReference: z.string().optional().nullable(),
      serviceProviderName: z.string().optional().nullable(),
      clientName: z.string().optional().nullable(),
      serviceName: z.string().optional().nullable(),
      appointmentTime: z.coerce.date().optional().nullable(),
      type: z.lazy(() => CommunicationTypeSchema),
      channel: z.lazy(() => CommunicationChannelSchema),
      content: z.string(),
      status: z.string(),
      sentAt: z.coerce.date().optional(),
      deliveredAt: z.coerce.date().optional().nullable(),
    })
    .strict();

export const CommunicationLogUpdateWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingReference: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      content: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      sentAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      deliveredAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const CommunicationLogUncheckedUpdateWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedUpdateWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingReference: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      content: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      sentAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      deliveredAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const CommunicationLogUncheckedUpdateManyWithoutBookingInputSchema: z.ZodType<Prisma.CommunicationLogUncheckedUpdateManyWithoutBookingInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      bookingReference: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceProviderName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      clientName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      serviceName: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      appointmentTime: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      type: z
        .union([
          z.lazy(() => CommunicationTypeSchema),
          z.lazy(() => EnumCommunicationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      channel: z
        .union([
          z.lazy(() => CommunicationChannelSchema),
          z.lazy(() => EnumCommunicationChannelFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      content: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      sentAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      deliveredAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
    })
    .strict();

export const CalendarEventCreateManyCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventCreateManyCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      externalEventId: z.string(),
      externalCalendarId: z.string(),
      etag: z.string().optional().nullable(),
      title: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      isAllDay: z.boolean().optional(),
      lastSyncedAt: z.coerce.date().optional(),
      eventType: z.string().optional().nullable(),
      blocksAvailability: z.boolean().optional(),
      syncStatus: z.lazy(() => CalendarEventSyncStatusSchema).optional(),
      lastModifiedInExternal: z.coerce.date().optional().nullable(),
      hasConflict: z.boolean().optional(),
      conflictDetails: z.string().optional().nullable(),
      conflictResolvedAt: z.coerce.date().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarSyncOperationCreateManyCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationCreateManyCalendarIntegrationInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      operationType: z.lazy(() => CalendarSyncOperationTypeSchema),
      sourceSystem: z.lazy(() => CalendarSyncSourceSchema),
      status: z.lazy(() => CalendarSyncStatusSchema).optional(),
      entityType: z.lazy(() => CalendarEntityTypeSchema),
      entityId: z.string().optional().nullable(),
      externalEventId: z.string().optional().nullable(),
      startedAt: z.coerce.date().optional(),
      completedAt: z.coerce.date().optional().nullable(),
      retryCount: z.number().int().optional(),
      maxRetries: z.number().int().optional(),
      errorMessage: z.string().optional().nullable(),
      conflictResolution: z
        .lazy(() => ConflictResolutionSchema)
        .optional()
        .nullable(),
      syncWindowStart: z.coerce.date().optional().nullable(),
      syncWindowEnd: z.coerce.date().optional().nullable(),
      eventsProcessed: z.number().int().optional(),
      eventsSucceeded: z.number().int().optional(),
      eventsFailed: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalendarEventUpdateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUpdateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      blockedSlots: z
        .lazy(
          () => CalculatedAvailabilitySlotUpdateManyWithoutBlockedByCalendarEventNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedUpdateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUncheckedUpdateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      blockedSlots: z
        .lazy(
          () =>
            CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventNestedInputSchema
        )
        .optional(),
    })
    .strict();

export const CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarEventUncheckedUpdateManyWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalEventId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      externalCalendarId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      etag: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      title: z.union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)]).optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      isAllDay: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      lastSyncedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      eventType: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      blocksAvailability: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      syncStatus: z
        .union([
          z.lazy(() => CalendarEventSyncStatusSchema),
          z.lazy(() => EnumCalendarEventSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastModifiedInExternal: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      hasConflict: z
        .union([z.boolean(), z.lazy(() => BoolFieldUpdateOperationsInputSchema)])
        .optional(),
      conflictDetails: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolvedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUpdateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedUpdateWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedUpdateWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationInputSchema: z.ZodType<Prisma.CalendarSyncOperationUncheckedUpdateManyWithoutCalendarIntegrationInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      operationType: z
        .union([
          z.lazy(() => CalendarSyncOperationTypeSchema),
          z.lazy(() => EnumCalendarSyncOperationTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      sourceSystem: z
        .union([
          z.lazy(() => CalendarSyncSourceSchema),
          z.lazy(() => EnumCalendarSyncSourceFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      status: z
        .union([
          z.lazy(() => CalendarSyncStatusSchema),
          z.lazy(() => EnumCalendarSyncStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityType: z
        .union([
          z.lazy(() => CalendarEntityTypeSchema),
          z.lazy(() => EnumCalendarEntityTypeFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      entityId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      externalEventId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      startedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      completedAt: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      retryCount: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      maxRetries: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      errorMessage: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      conflictResolution: z
        .union([
          z.lazy(() => ConflictResolutionSchema),
          z.lazy(() => NullableEnumConflictResolutionFieldUpdateOperationsInputSchema),
        ])
        .optional()
        .nullable(),
      syncWindowStart: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      syncWindowEnd: z
        .union([z.coerce.date(), z.lazy(() => NullableDateTimeFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      eventsProcessed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsSucceeded: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      eventsFailed: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyBlockedByCalendarEventInput> =
  z
    .object({
      id: z.string().cuid().optional(),
      availabilityId: z.string(),
      serviceId: z.string(),
      serviceConfigId: z.string(),
      startTime: z.coerce.date(),
      endTime: z.coerce.date(),
      status: z.lazy(() => SlotStatusSchema).optional(),
      lastCalculated: z.coerce.date(),
      billedToSubscriptionId: z.string().optional().nullable(),
      version: z.number().int().optional(),
      createdAt: z.coerce.date().optional(),
      updatedAt: z.coerce.date().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateWithoutBlockedByCalendarEventInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      availability: z
        .lazy(() => AvailabilityUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      service: z
        .lazy(() => ServiceUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema)
        .optional(),
      serviceConfig: z
        .lazy(
          () => ServiceAvailabilityConfigUpdateOneRequiredWithoutCalculatedSlotsNestedInputSchema
        )
        .optional(),
      booking: z.lazy(() => BookingUpdateOneWithoutSlotNestedInputSchema).optional(),
      billedToSubscription: z
        .lazy(() => SubscriptionUpdateOneWithoutBilledSlotsNestedInputSchema)
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateWithoutBlockedByCalendarEventInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      booking: z.lazy(() => BookingUncheckedUpdateOneWithoutSlotNestedInputSchema).optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventInputSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUncheckedUpdateManyWithoutBlockedByCalendarEventInput> =
  z
    .object({
      id: z
        .union([z.string().cuid(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      availabilityId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      serviceConfigId: z
        .union([z.string(), z.lazy(() => StringFieldUpdateOperationsInputSchema)])
        .optional(),
      startTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      endTime: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      status: z
        .union([
          z.lazy(() => SlotStatusSchema),
          z.lazy(() => EnumSlotStatusFieldUpdateOperationsInputSchema),
        ])
        .optional(),
      lastCalculated: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      billedToSubscriptionId: z
        .union([z.string(), z.lazy(() => NullableStringFieldUpdateOperationsInputSchema)])
        .optional()
        .nullable(),
      version: z
        .union([z.number().int(), z.lazy(() => IntFieldUpdateOperationsInputSchema)])
        .optional(),
      createdAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
      updatedAt: z
        .union([z.coerce.date(), z.lazy(() => DateTimeFieldUpdateOperationsInputSchema)])
        .optional(),
    })
    .strict();

/////////////////////////////////////////
// ARGS
/////////////////////////////////////////

export const UserFindFirstArgsSchema: z.ZodType<Prisma.UserFindFirstArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([UserOrderByWithRelationInputSchema.array(), UserOrderByWithRelationInputSchema])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z.union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()]).optional(),
  })
  .strict();

export const UserFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UserFindFirstOrThrowArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([UserOrderByWithRelationInputSchema.array(), UserOrderByWithRelationInputSchema])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z.union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()]).optional(),
  })
  .strict();

export const UserFindManyArgsSchema: z.ZodType<Prisma.UserFindManyArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([UserOrderByWithRelationInputSchema.array(), UserOrderByWithRelationInputSchema])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z.union([UserScalarFieldEnumSchema, UserScalarFieldEnumSchema.array()]).optional(),
  })
  .strict();

export const UserAggregateArgsSchema: z.ZodType<Prisma.UserAggregateArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([UserOrderByWithRelationInputSchema.array(), UserOrderByWithRelationInputSchema])
      .optional(),
    cursor: UserWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const UserGroupByArgsSchema: z.ZodType<Prisma.UserGroupByArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
    orderBy: z
      .union([UserOrderByWithAggregationInputSchema.array(), UserOrderByWithAggregationInputSchema])
      .optional(),
    by: UserScalarFieldEnumSchema.array(),
    having: UserScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const UserFindUniqueArgsSchema: z.ZodType<Prisma.UserFindUniqueArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const UserFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UserFindUniqueOrThrowArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const AccountFindFirstArgsSchema: z.ZodType<Prisma.AccountFindFirstArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([AccountOrderByWithRelationInputSchema.array(), AccountOrderByWithRelationInputSchema])
      .optional(),
    cursor: AccountWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([AccountScalarFieldEnumSchema, AccountScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const AccountFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AccountFindFirstOrThrowArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([AccountOrderByWithRelationInputSchema.array(), AccountOrderByWithRelationInputSchema])
      .optional(),
    cursor: AccountWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([AccountScalarFieldEnumSchema, AccountScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const AccountFindManyArgsSchema: z.ZodType<Prisma.AccountFindManyArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([AccountOrderByWithRelationInputSchema.array(), AccountOrderByWithRelationInputSchema])
      .optional(),
    cursor: AccountWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([AccountScalarFieldEnumSchema, AccountScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const AccountAggregateArgsSchema: z.ZodType<Prisma.AccountAggregateArgs> = z
  .object({
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([AccountOrderByWithRelationInputSchema.array(), AccountOrderByWithRelationInputSchema])
      .optional(),
    cursor: AccountWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const AccountGroupByArgsSchema: z.ZodType<Prisma.AccountGroupByArgs> = z
  .object({
    where: AccountWhereInputSchema.optional(),
    orderBy: z
      .union([
        AccountOrderByWithAggregationInputSchema.array(),
        AccountOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: AccountScalarFieldEnumSchema.array(),
    having: AccountScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const AccountFindUniqueArgsSchema: z.ZodType<Prisma.AccountFindUniqueArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
  })
  .strict();

export const AccountFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AccountFindUniqueOrThrowArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
  })
  .strict();

export const ServiceProviderTypeFindFirstArgsSchema: z.ZodType<Prisma.ServiceProviderTypeFindFirstArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceProviderTypeOrderByWithRelationInputSchema.array(),
          ServiceProviderTypeOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceProviderTypeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ServiceProviderTypeScalarFieldEnumSchema,
          ServiceProviderTypeScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ServiceProviderTypeFindFirstOrThrowArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceProviderTypeOrderByWithRelationInputSchema.array(),
          ServiceProviderTypeOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceProviderTypeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ServiceProviderTypeScalarFieldEnumSchema,
          ServiceProviderTypeScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeFindManyArgsSchema: z.ZodType<Prisma.ServiceProviderTypeFindManyArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceProviderTypeOrderByWithRelationInputSchema.array(),
          ServiceProviderTypeOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceProviderTypeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ServiceProviderTypeScalarFieldEnumSchema,
          ServiceProviderTypeScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceProviderTypeAggregateArgsSchema: z.ZodType<Prisma.ServiceProviderTypeAggregateArgs> =
  z
    .object({
      where: ServiceProviderTypeWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceProviderTypeOrderByWithRelationInputSchema.array(),
          ServiceProviderTypeOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceProviderTypeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const ServiceProviderTypeGroupByArgsSchema: z.ZodType<Prisma.ServiceProviderTypeGroupByArgs> =
  z
    .object({
      where: ServiceProviderTypeWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceProviderTypeOrderByWithAggregationInputSchema.array(),
          ServiceProviderTypeOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: ServiceProviderTypeScalarFieldEnumSchema.array(),
      having: ServiceProviderTypeScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const ServiceProviderTypeFindUniqueArgsSchema: z.ZodType<Prisma.ServiceProviderTypeFindUniqueArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereUniqueInputSchema,
    })
    .strict();

export const ServiceProviderTypeFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ServiceProviderTypeFindUniqueOrThrowArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereUniqueInputSchema,
    })
    .strict();

export const ServiceProviderFindFirstArgsSchema: z.ZodType<Prisma.ServiceProviderFindFirstArgs> = z
  .object({
    select: ServiceProviderSelectSchema.optional(),
    include: ServiceProviderIncludeSchema.optional(),
    where: ServiceProviderWhereInputSchema.optional(),
    orderBy: z
      .union([
        ServiceProviderOrderByWithRelationInputSchema.array(),
        ServiceProviderOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: ServiceProviderWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ServiceProviderScalarFieldEnumSchema, ServiceProviderScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ServiceProviderFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ServiceProviderFindFirstOrThrowArgs> =
  z
    .object({
      select: ServiceProviderSelectSchema.optional(),
      include: ServiceProviderIncludeSchema.optional(),
      where: ServiceProviderWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceProviderOrderByWithRelationInputSchema.array(),
          ServiceProviderOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceProviderWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([ServiceProviderScalarFieldEnumSchema, ServiceProviderScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const ServiceProviderFindManyArgsSchema: z.ZodType<Prisma.ServiceProviderFindManyArgs> = z
  .object({
    select: ServiceProviderSelectSchema.optional(),
    include: ServiceProviderIncludeSchema.optional(),
    where: ServiceProviderWhereInputSchema.optional(),
    orderBy: z
      .union([
        ServiceProviderOrderByWithRelationInputSchema.array(),
        ServiceProviderOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: ServiceProviderWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ServiceProviderScalarFieldEnumSchema, ServiceProviderScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ServiceProviderAggregateArgsSchema: z.ZodType<Prisma.ServiceProviderAggregateArgs> = z
  .object({
    where: ServiceProviderWhereInputSchema.optional(),
    orderBy: z
      .union([
        ServiceProviderOrderByWithRelationInputSchema.array(),
        ServiceProviderOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: ServiceProviderWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ServiceProviderGroupByArgsSchema: z.ZodType<Prisma.ServiceProviderGroupByArgs> = z
  .object({
    where: ServiceProviderWhereInputSchema.optional(),
    orderBy: z
      .union([
        ServiceProviderOrderByWithAggregationInputSchema.array(),
        ServiceProviderOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: ServiceProviderScalarFieldEnumSchema.array(),
    having: ServiceProviderScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ServiceProviderFindUniqueArgsSchema: z.ZodType<Prisma.ServiceProviderFindUniqueArgs> =
  z
    .object({
      select: ServiceProviderSelectSchema.optional(),
      include: ServiceProviderIncludeSchema.optional(),
      where: ServiceProviderWhereUniqueInputSchema,
    })
    .strict();

export const ServiceProviderFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ServiceProviderFindUniqueOrThrowArgs> =
  z
    .object({
      select: ServiceProviderSelectSchema.optional(),
      include: ServiceProviderIncludeSchema.optional(),
      where: ServiceProviderWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationFindFirstArgsSchema: z.ZodType<Prisma.OrganizationFindFirstArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    where: OrganizationWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrganizationOrderByWithRelationInputSchema.array(),
        OrganizationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: OrganizationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([OrganizationScalarFieldEnumSchema, OrganizationScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const OrganizationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrganizationFindFirstOrThrowArgs> =
  z
    .object({
      select: OrganizationSelectSchema.optional(),
      include: OrganizationIncludeSchema.optional(),
      where: OrganizationWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationOrderByWithRelationInputSchema.array(),
          OrganizationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([OrganizationScalarFieldEnumSchema, OrganizationScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const OrganizationFindManyArgsSchema: z.ZodType<Prisma.OrganizationFindManyArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    where: OrganizationWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrganizationOrderByWithRelationInputSchema.array(),
        OrganizationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: OrganizationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([OrganizationScalarFieldEnumSchema, OrganizationScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const OrganizationAggregateArgsSchema: z.ZodType<Prisma.OrganizationAggregateArgs> = z
  .object({
    where: OrganizationWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrganizationOrderByWithRelationInputSchema.array(),
        OrganizationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: OrganizationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const OrganizationGroupByArgsSchema: z.ZodType<Prisma.OrganizationGroupByArgs> = z
  .object({
    where: OrganizationWhereInputSchema.optional(),
    orderBy: z
      .union([
        OrganizationOrderByWithAggregationInputSchema.array(),
        OrganizationOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: OrganizationScalarFieldEnumSchema.array(),
    having: OrganizationScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const OrganizationFindUniqueArgsSchema: z.ZodType<Prisma.OrganizationFindUniqueArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    where: OrganizationWhereUniqueInputSchema,
  })
  .strict();

export const OrganizationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrganizationFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrganizationSelectSchema.optional(),
      include: OrganizationIncludeSchema.optional(),
      where: OrganizationWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationInvitationFindFirstArgsSchema: z.ZodType<Prisma.OrganizationInvitationFindFirstArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationInvitationOrderByWithRelationInputSchema.array(),
          OrganizationInvitationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationInvitationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationInvitationScalarFieldEnumSchema,
          OrganizationInvitationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrganizationInvitationFindFirstOrThrowArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationInvitationOrderByWithRelationInputSchema.array(),
          OrganizationInvitationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationInvitationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationInvitationScalarFieldEnumSchema,
          OrganizationInvitationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationFindManyArgsSchema: z.ZodType<Prisma.OrganizationInvitationFindManyArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationInvitationOrderByWithRelationInputSchema.array(),
          OrganizationInvitationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationInvitationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationInvitationScalarFieldEnumSchema,
          OrganizationInvitationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationInvitationAggregateArgsSchema: z.ZodType<Prisma.OrganizationInvitationAggregateArgs> =
  z
    .object({
      where: OrganizationInvitationWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationInvitationOrderByWithRelationInputSchema.array(),
          OrganizationInvitationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationInvitationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationInvitationGroupByArgsSchema: z.ZodType<Prisma.OrganizationInvitationGroupByArgs> =
  z
    .object({
      where: OrganizationInvitationWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationInvitationOrderByWithAggregationInputSchema.array(),
          OrganizationInvitationOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrganizationInvitationScalarFieldEnumSchema.array(),
      having: OrganizationInvitationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationInvitationFindUniqueArgsSchema: z.ZodType<Prisma.OrganizationInvitationFindUniqueArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationInvitationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrganizationInvitationFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipFindFirstArgsSchema: z.ZodType<Prisma.OrganizationMembershipFindFirstArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipOrderByWithRelationInputSchema.array(),
          OrganizationMembershipOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationMembershipScalarFieldEnumSchema,
          OrganizationMembershipScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrganizationMembershipFindFirstOrThrowArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipOrderByWithRelationInputSchema.array(),
          OrganizationMembershipOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationMembershipScalarFieldEnumSchema,
          OrganizationMembershipScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipFindManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipFindManyArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipOrderByWithRelationInputSchema.array(),
          OrganizationMembershipOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationMembershipScalarFieldEnumSchema,
          OrganizationMembershipScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipAggregateArgsSchema: z.ZodType<Prisma.OrganizationMembershipAggregateArgs> =
  z
    .object({
      where: OrganizationMembershipWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipOrderByWithRelationInputSchema.array(),
          OrganizationMembershipOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationMembershipGroupByArgsSchema: z.ZodType<Prisma.OrganizationMembershipGroupByArgs> =
  z
    .object({
      where: OrganizationMembershipWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipOrderByWithAggregationInputSchema.array(),
          OrganizationMembershipOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrganizationMembershipScalarFieldEnumSchema.array(),
      having: OrganizationMembershipScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationMembershipFindUniqueArgsSchema: z.ZodType<Prisma.OrganizationMembershipFindUniqueArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrganizationMembershipFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipHistoryFindFirstArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryFindFirstArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipHistoryOrderByWithRelationInputSchema.array(),
          OrganizationMembershipHistoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipHistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationMembershipHistoryScalarFieldEnumSchema,
          OrganizationMembershipHistoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryFindFirstOrThrowArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipHistoryOrderByWithRelationInputSchema.array(),
          OrganizationMembershipHistoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipHistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationMembershipHistoryScalarFieldEnumSchema,
          OrganizationMembershipHistoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryFindManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryFindManyArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipHistoryOrderByWithRelationInputSchema.array(),
          OrganizationMembershipHistoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipHistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationMembershipHistoryScalarFieldEnumSchema,
          OrganizationMembershipHistoryScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationMembershipHistoryAggregateArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryAggregateArgs> =
  z
    .object({
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipHistoryOrderByWithRelationInputSchema.array(),
          OrganizationMembershipHistoryOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationMembershipHistoryWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryGroupByArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryGroupByArgs> =
  z
    .object({
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationMembershipHistoryOrderByWithAggregationInputSchema.array(),
          OrganizationMembershipHistoryOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrganizationMembershipHistoryScalarFieldEnumSchema.array(),
      having: OrganizationMembershipHistoryScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryFindUniqueArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryFindUniqueArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipHistoryFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereUniqueInputSchema,
    })
    .strict();

export const LocationFindFirstArgsSchema: z.ZodType<Prisma.LocationFindFirstArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    where: LocationWhereInputSchema.optional(),
    orderBy: z
      .union([
        LocationOrderByWithRelationInputSchema.array(),
        LocationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: LocationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LocationScalarFieldEnumSchema, LocationScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const LocationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.LocationFindFirstOrThrowArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    where: LocationWhereInputSchema.optional(),
    orderBy: z
      .union([
        LocationOrderByWithRelationInputSchema.array(),
        LocationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: LocationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LocationScalarFieldEnumSchema, LocationScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const LocationFindManyArgsSchema: z.ZodType<Prisma.LocationFindManyArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    where: LocationWhereInputSchema.optional(),
    orderBy: z
      .union([
        LocationOrderByWithRelationInputSchema.array(),
        LocationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: LocationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([LocationScalarFieldEnumSchema, LocationScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const LocationAggregateArgsSchema: z.ZodType<Prisma.LocationAggregateArgs> = z
  .object({
    where: LocationWhereInputSchema.optional(),
    orderBy: z
      .union([
        LocationOrderByWithRelationInputSchema.array(),
        LocationOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: LocationWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const LocationGroupByArgsSchema: z.ZodType<Prisma.LocationGroupByArgs> = z
  .object({
    where: LocationWhereInputSchema.optional(),
    orderBy: z
      .union([
        LocationOrderByWithAggregationInputSchema.array(),
        LocationOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: LocationScalarFieldEnumSchema.array(),
    having: LocationScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const LocationFindUniqueArgsSchema: z.ZodType<Prisma.LocationFindUniqueArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    where: LocationWhereUniqueInputSchema,
  })
  .strict();

export const LocationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.LocationFindUniqueOrThrowArgs> =
  z
    .object({
      select: LocationSelectSchema.optional(),
      include: LocationIncludeSchema.optional(),
      where: LocationWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationProviderConnectionFindFirstArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionFindFirstArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationProviderConnectionOrderByWithRelationInputSchema.array(),
          OrganizationProviderConnectionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationProviderConnectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationProviderConnectionScalarFieldEnumSchema,
          OrganizationProviderConnectionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionFindFirstOrThrowArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationProviderConnectionOrderByWithRelationInputSchema.array(),
          OrganizationProviderConnectionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationProviderConnectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationProviderConnectionScalarFieldEnumSchema,
          OrganizationProviderConnectionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionFindManyArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionFindManyArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationProviderConnectionOrderByWithRelationInputSchema.array(),
          OrganizationProviderConnectionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationProviderConnectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          OrganizationProviderConnectionScalarFieldEnumSchema,
          OrganizationProviderConnectionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const OrganizationProviderConnectionAggregateArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionAggregateArgs> =
  z
    .object({
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationProviderConnectionOrderByWithRelationInputSchema.array(),
          OrganizationProviderConnectionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: OrganizationProviderConnectionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationProviderConnectionGroupByArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionGroupByArgs> =
  z
    .object({
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
      orderBy: z
        .union([
          OrganizationProviderConnectionOrderByWithAggregationInputSchema.array(),
          OrganizationProviderConnectionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: OrganizationProviderConnectionScalarFieldEnumSchema.array(),
      having: OrganizationProviderConnectionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const OrganizationProviderConnectionFindUniqueArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionFindUniqueArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationProviderConnectionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionFindUniqueOrThrowArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereUniqueInputSchema,
    })
    .strict();

export const SubscriptionFindFirstArgsSchema: z.ZodType<Prisma.SubscriptionFindFirstArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    where: SubscriptionWhereInputSchema.optional(),
    orderBy: z
      .union([
        SubscriptionOrderByWithRelationInputSchema.array(),
        SubscriptionOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: SubscriptionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([SubscriptionScalarFieldEnumSchema, SubscriptionScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const SubscriptionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SubscriptionFindFirstOrThrowArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionOrderByWithRelationInputSchema.array(),
          SubscriptionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SubscriptionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([SubscriptionScalarFieldEnumSchema, SubscriptionScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const SubscriptionFindManyArgsSchema: z.ZodType<Prisma.SubscriptionFindManyArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    where: SubscriptionWhereInputSchema.optional(),
    orderBy: z
      .union([
        SubscriptionOrderByWithRelationInputSchema.array(),
        SubscriptionOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: SubscriptionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([SubscriptionScalarFieldEnumSchema, SubscriptionScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const SubscriptionAggregateArgsSchema: z.ZodType<Prisma.SubscriptionAggregateArgs> = z
  .object({
    where: SubscriptionWhereInputSchema.optional(),
    orderBy: z
      .union([
        SubscriptionOrderByWithRelationInputSchema.array(),
        SubscriptionOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: SubscriptionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const SubscriptionGroupByArgsSchema: z.ZodType<Prisma.SubscriptionGroupByArgs> = z
  .object({
    where: SubscriptionWhereInputSchema.optional(),
    orderBy: z
      .union([
        SubscriptionOrderByWithAggregationInputSchema.array(),
        SubscriptionOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: SubscriptionScalarFieldEnumSchema.array(),
    having: SubscriptionScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const SubscriptionFindUniqueArgsSchema: z.ZodType<Prisma.SubscriptionFindUniqueArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    where: SubscriptionWhereUniqueInputSchema,
  })
  .strict();

export const SubscriptionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SubscriptionFindUniqueOrThrowArgs> =
  z
    .object({
      select: SubscriptionSelectSchema.optional(),
      include: SubscriptionIncludeSchema.optional(),
      where: SubscriptionWhereUniqueInputSchema,
    })
    .strict();

export const SubscriptionPlanFindFirstArgsSchema: z.ZodType<Prisma.SubscriptionPlanFindFirstArgs> =
  z
    .object({
      select: SubscriptionPlanSelectSchema.optional(),
      include: SubscriptionPlanIncludeSchema.optional(),
      where: SubscriptionPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionPlanOrderByWithRelationInputSchema.array(),
          SubscriptionPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SubscriptionPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriptionPlanScalarFieldEnumSchema,
          SubscriptionPlanScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionPlanFindFirstOrThrowArgsSchema: z.ZodType<Prisma.SubscriptionPlanFindFirstOrThrowArgs> =
  z
    .object({
      select: SubscriptionPlanSelectSchema.optional(),
      include: SubscriptionPlanIncludeSchema.optional(),
      where: SubscriptionPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionPlanOrderByWithRelationInputSchema.array(),
          SubscriptionPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SubscriptionPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          SubscriptionPlanScalarFieldEnumSchema,
          SubscriptionPlanScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const SubscriptionPlanFindManyArgsSchema: z.ZodType<Prisma.SubscriptionPlanFindManyArgs> = z
  .object({
    select: SubscriptionPlanSelectSchema.optional(),
    include: SubscriptionPlanIncludeSchema.optional(),
    where: SubscriptionPlanWhereInputSchema.optional(),
    orderBy: z
      .union([
        SubscriptionPlanOrderByWithRelationInputSchema.array(),
        SubscriptionPlanOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: SubscriptionPlanWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([SubscriptionPlanScalarFieldEnumSchema, SubscriptionPlanScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const SubscriptionPlanAggregateArgsSchema: z.ZodType<Prisma.SubscriptionPlanAggregateArgs> =
  z
    .object({
      where: SubscriptionPlanWhereInputSchema.optional(),
      orderBy: z
        .union([
          SubscriptionPlanOrderByWithRelationInputSchema.array(),
          SubscriptionPlanOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: SubscriptionPlanWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const SubscriptionPlanGroupByArgsSchema: z.ZodType<Prisma.SubscriptionPlanGroupByArgs> = z
  .object({
    where: SubscriptionPlanWhereInputSchema.optional(),
    orderBy: z
      .union([
        SubscriptionPlanOrderByWithAggregationInputSchema.array(),
        SubscriptionPlanOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: SubscriptionPlanScalarFieldEnumSchema.array(),
    having: SubscriptionPlanScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const SubscriptionPlanFindUniqueArgsSchema: z.ZodType<Prisma.SubscriptionPlanFindUniqueArgs> =
  z
    .object({
      select: SubscriptionPlanSelectSchema.optional(),
      include: SubscriptionPlanIncludeSchema.optional(),
      where: SubscriptionPlanWhereUniqueInputSchema,
    })
    .strict();

export const SubscriptionPlanFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.SubscriptionPlanFindUniqueOrThrowArgs> =
  z
    .object({
      select: SubscriptionPlanSelectSchema.optional(),
      include: SubscriptionPlanIncludeSchema.optional(),
      where: SubscriptionPlanWhereUniqueInputSchema,
    })
    .strict();

export const UsageRecordFindFirstArgsSchema: z.ZodType<Prisma.UsageRecordFindFirstArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    where: UsageRecordWhereInputSchema.optional(),
    orderBy: z
      .union([
        UsageRecordOrderByWithRelationInputSchema.array(),
        UsageRecordOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UsageRecordWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UsageRecordScalarFieldEnumSchema, UsageRecordScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const UsageRecordFindFirstOrThrowArgsSchema: z.ZodType<Prisma.UsageRecordFindFirstOrThrowArgs> =
  z
    .object({
      select: UsageRecordSelectSchema.optional(),
      include: UsageRecordIncludeSchema.optional(),
      where: UsageRecordWhereInputSchema.optional(),
      orderBy: z
        .union([
          UsageRecordOrderByWithRelationInputSchema.array(),
          UsageRecordOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: UsageRecordWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([UsageRecordScalarFieldEnumSchema, UsageRecordScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const UsageRecordFindManyArgsSchema: z.ZodType<Prisma.UsageRecordFindManyArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    where: UsageRecordWhereInputSchema.optional(),
    orderBy: z
      .union([
        UsageRecordOrderByWithRelationInputSchema.array(),
        UsageRecordOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UsageRecordWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([UsageRecordScalarFieldEnumSchema, UsageRecordScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const UsageRecordAggregateArgsSchema: z.ZodType<Prisma.UsageRecordAggregateArgs> = z
  .object({
    where: UsageRecordWhereInputSchema.optional(),
    orderBy: z
      .union([
        UsageRecordOrderByWithRelationInputSchema.array(),
        UsageRecordOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: UsageRecordWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const UsageRecordGroupByArgsSchema: z.ZodType<Prisma.UsageRecordGroupByArgs> = z
  .object({
    where: UsageRecordWhereInputSchema.optional(),
    orderBy: z
      .union([
        UsageRecordOrderByWithAggregationInputSchema.array(),
        UsageRecordOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: UsageRecordScalarFieldEnumSchema.array(),
    having: UsageRecordScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const UsageRecordFindUniqueArgsSchema: z.ZodType<Prisma.UsageRecordFindUniqueArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    where: UsageRecordWhereUniqueInputSchema,
  })
  .strict();

export const UsageRecordFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.UsageRecordFindUniqueOrThrowArgs> =
  z
    .object({
      select: UsageRecordSelectSchema.optional(),
      include: UsageRecordIncludeSchema.optional(),
      where: UsageRecordWhereUniqueInputSchema,
    })
    .strict();

export const PaymentFindFirstArgsSchema: z.ZodType<Prisma.PaymentFindFirstArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereInputSchema.optional(),
    orderBy: z
      .union([PaymentOrderByWithRelationInputSchema.array(), PaymentOrderByWithRelationInputSchema])
      .optional(),
    cursor: PaymentWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([PaymentScalarFieldEnumSchema, PaymentScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const PaymentFindFirstOrThrowArgsSchema: z.ZodType<Prisma.PaymentFindFirstOrThrowArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereInputSchema.optional(),
    orderBy: z
      .union([PaymentOrderByWithRelationInputSchema.array(), PaymentOrderByWithRelationInputSchema])
      .optional(),
    cursor: PaymentWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([PaymentScalarFieldEnumSchema, PaymentScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const PaymentFindManyArgsSchema: z.ZodType<Prisma.PaymentFindManyArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereInputSchema.optional(),
    orderBy: z
      .union([PaymentOrderByWithRelationInputSchema.array(), PaymentOrderByWithRelationInputSchema])
      .optional(),
    cursor: PaymentWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([PaymentScalarFieldEnumSchema, PaymentScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const PaymentAggregateArgsSchema: z.ZodType<Prisma.PaymentAggregateArgs> = z
  .object({
    where: PaymentWhereInputSchema.optional(),
    orderBy: z
      .union([PaymentOrderByWithRelationInputSchema.array(), PaymentOrderByWithRelationInputSchema])
      .optional(),
    cursor: PaymentWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const PaymentGroupByArgsSchema: z.ZodType<Prisma.PaymentGroupByArgs> = z
  .object({
    where: PaymentWhereInputSchema.optional(),
    orderBy: z
      .union([
        PaymentOrderByWithAggregationInputSchema.array(),
        PaymentOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: PaymentScalarFieldEnumSchema.array(),
    having: PaymentScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const PaymentFindUniqueArgsSchema: z.ZodType<Prisma.PaymentFindUniqueArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereUniqueInputSchema,
  })
  .strict();

export const PaymentFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.PaymentFindUniqueOrThrowArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereUniqueInputSchema,
  })
  .strict();

export const RequirementTypeFindFirstArgsSchema: z.ZodType<Prisma.RequirementTypeFindFirstArgs> = z
  .object({
    select: RequirementTypeSelectSchema.optional(),
    include: RequirementTypeIncludeSchema.optional(),
    where: RequirementTypeWhereInputSchema.optional(),
    orderBy: z
      .union([
        RequirementTypeOrderByWithRelationInputSchema.array(),
        RequirementTypeOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: RequirementTypeWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([RequirementTypeScalarFieldEnumSchema, RequirementTypeScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const RequirementTypeFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RequirementTypeFindFirstOrThrowArgs> =
  z
    .object({
      select: RequirementTypeSelectSchema.optional(),
      include: RequirementTypeIncludeSchema.optional(),
      where: RequirementTypeWhereInputSchema.optional(),
      orderBy: z
        .union([
          RequirementTypeOrderByWithRelationInputSchema.array(),
          RequirementTypeOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RequirementTypeWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([RequirementTypeScalarFieldEnumSchema, RequirementTypeScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const RequirementTypeFindManyArgsSchema: z.ZodType<Prisma.RequirementTypeFindManyArgs> = z
  .object({
    select: RequirementTypeSelectSchema.optional(),
    include: RequirementTypeIncludeSchema.optional(),
    where: RequirementTypeWhereInputSchema.optional(),
    orderBy: z
      .union([
        RequirementTypeOrderByWithRelationInputSchema.array(),
        RequirementTypeOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: RequirementTypeWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([RequirementTypeScalarFieldEnumSchema, RequirementTypeScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const RequirementTypeAggregateArgsSchema: z.ZodType<Prisma.RequirementTypeAggregateArgs> = z
  .object({
    where: RequirementTypeWhereInputSchema.optional(),
    orderBy: z
      .union([
        RequirementTypeOrderByWithRelationInputSchema.array(),
        RequirementTypeOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: RequirementTypeWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const RequirementTypeGroupByArgsSchema: z.ZodType<Prisma.RequirementTypeGroupByArgs> = z
  .object({
    where: RequirementTypeWhereInputSchema.optional(),
    orderBy: z
      .union([
        RequirementTypeOrderByWithAggregationInputSchema.array(),
        RequirementTypeOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: RequirementTypeScalarFieldEnumSchema.array(),
    having: RequirementTypeScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const RequirementTypeFindUniqueArgsSchema: z.ZodType<Prisma.RequirementTypeFindUniqueArgs> =
  z
    .object({
      select: RequirementTypeSelectSchema.optional(),
      include: RequirementTypeIncludeSchema.optional(),
      where: RequirementTypeWhereUniqueInputSchema,
    })
    .strict();

export const RequirementTypeFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RequirementTypeFindUniqueOrThrowArgs> =
  z
    .object({
      select: RequirementTypeSelectSchema.optional(),
      include: RequirementTypeIncludeSchema.optional(),
      where: RequirementTypeWhereUniqueInputSchema,
    })
    .strict();

export const RequirementSubmissionFindFirstArgsSchema: z.ZodType<Prisma.RequirementSubmissionFindFirstArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RequirementSubmissionOrderByWithRelationInputSchema.array(),
          RequirementSubmissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RequirementSubmissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RequirementSubmissionScalarFieldEnumSchema,
          RequirementSubmissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.RequirementSubmissionFindFirstOrThrowArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RequirementSubmissionOrderByWithRelationInputSchema.array(),
          RequirementSubmissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RequirementSubmissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RequirementSubmissionScalarFieldEnumSchema,
          RequirementSubmissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionFindManyArgsSchema: z.ZodType<Prisma.RequirementSubmissionFindManyArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RequirementSubmissionOrderByWithRelationInputSchema.array(),
          RequirementSubmissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RequirementSubmissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          RequirementSubmissionScalarFieldEnumSchema,
          RequirementSubmissionScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const RequirementSubmissionAggregateArgsSchema: z.ZodType<Prisma.RequirementSubmissionAggregateArgs> =
  z
    .object({
      where: RequirementSubmissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RequirementSubmissionOrderByWithRelationInputSchema.array(),
          RequirementSubmissionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: RequirementSubmissionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const RequirementSubmissionGroupByArgsSchema: z.ZodType<Prisma.RequirementSubmissionGroupByArgs> =
  z
    .object({
      where: RequirementSubmissionWhereInputSchema.optional(),
      orderBy: z
        .union([
          RequirementSubmissionOrderByWithAggregationInputSchema.array(),
          RequirementSubmissionOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: RequirementSubmissionScalarFieldEnumSchema.array(),
      having: RequirementSubmissionScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const RequirementSubmissionFindUniqueArgsSchema: z.ZodType<Prisma.RequirementSubmissionFindUniqueArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereUniqueInputSchema,
    })
    .strict();

export const RequirementSubmissionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.RequirementSubmissionFindUniqueOrThrowArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereUniqueInputSchema,
    })
    .strict();

export const ServiceFindFirstArgsSchema: z.ZodType<Prisma.ServiceFindFirstArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereInputSchema.optional(),
    orderBy: z
      .union([ServiceOrderByWithRelationInputSchema.array(), ServiceOrderByWithRelationInputSchema])
      .optional(),
    cursor: ServiceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ServiceScalarFieldEnumSchema, ServiceScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ServiceFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ServiceFindFirstOrThrowArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereInputSchema.optional(),
    orderBy: z
      .union([ServiceOrderByWithRelationInputSchema.array(), ServiceOrderByWithRelationInputSchema])
      .optional(),
    cursor: ServiceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ServiceScalarFieldEnumSchema, ServiceScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ServiceFindManyArgsSchema: z.ZodType<Prisma.ServiceFindManyArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereInputSchema.optional(),
    orderBy: z
      .union([ServiceOrderByWithRelationInputSchema.array(), ServiceOrderByWithRelationInputSchema])
      .optional(),
    cursor: ServiceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ServiceScalarFieldEnumSchema, ServiceScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ServiceAggregateArgsSchema: z.ZodType<Prisma.ServiceAggregateArgs> = z
  .object({
    where: ServiceWhereInputSchema.optional(),
    orderBy: z
      .union([ServiceOrderByWithRelationInputSchema.array(), ServiceOrderByWithRelationInputSchema])
      .optional(),
    cursor: ServiceWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ServiceGroupByArgsSchema: z.ZodType<Prisma.ServiceGroupByArgs> = z
  .object({
    where: ServiceWhereInputSchema.optional(),
    orderBy: z
      .union([
        ServiceOrderByWithAggregationInputSchema.array(),
        ServiceOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: ServiceScalarFieldEnumSchema.array(),
    having: ServiceScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ServiceFindUniqueArgsSchema: z.ZodType<Prisma.ServiceFindUniqueArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereUniqueInputSchema,
  })
  .strict();

export const ServiceFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ServiceFindUniqueOrThrowArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereUniqueInputSchema,
  })
  .strict();

export const ServiceAvailabilityConfigFindFirstArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigFindFirstArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceAvailabilityConfigOrderByWithRelationInputSchema.array(),
          ServiceAvailabilityConfigOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceAvailabilityConfigWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ServiceAvailabilityConfigScalarFieldEnumSchema,
          ServiceAvailabilityConfigScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigFindFirstOrThrowArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceAvailabilityConfigOrderByWithRelationInputSchema.array(),
          ServiceAvailabilityConfigOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceAvailabilityConfigWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ServiceAvailabilityConfigScalarFieldEnumSchema,
          ServiceAvailabilityConfigScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigFindManyArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigFindManyArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceAvailabilityConfigOrderByWithRelationInputSchema.array(),
          ServiceAvailabilityConfigOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceAvailabilityConfigWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          ServiceAvailabilityConfigScalarFieldEnumSchema,
          ServiceAvailabilityConfigScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const ServiceAvailabilityConfigAggregateArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigAggregateArgs> =
  z
    .object({
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceAvailabilityConfigOrderByWithRelationInputSchema.array(),
          ServiceAvailabilityConfigOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: ServiceAvailabilityConfigWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigGroupByArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigGroupByArgs> =
  z
    .object({
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
      orderBy: z
        .union([
          ServiceAvailabilityConfigOrderByWithAggregationInputSchema.array(),
          ServiceAvailabilityConfigOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: ServiceAvailabilityConfigScalarFieldEnumSchema.array(),
      having: ServiceAvailabilityConfigScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigFindUniqueArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigFindUniqueArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereUniqueInputSchema,
    })
    .strict();

export const ServiceAvailabilityConfigFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigFindUniqueOrThrowArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereUniqueInputSchema,
    })
    .strict();

export const AvailabilityFindFirstArgsSchema: z.ZodType<Prisma.AvailabilityFindFirstArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    where: AvailabilityWhereInputSchema.optional(),
    orderBy: z
      .union([
        AvailabilityOrderByWithRelationInputSchema.array(),
        AvailabilityOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: AvailabilityWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([AvailabilityScalarFieldEnumSchema, AvailabilityScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const AvailabilityFindFirstOrThrowArgsSchema: z.ZodType<Prisma.AvailabilityFindFirstOrThrowArgs> =
  z
    .object({
      select: AvailabilitySelectSchema.optional(),
      include: AvailabilityIncludeSchema.optional(),
      where: AvailabilityWhereInputSchema.optional(),
      orderBy: z
        .union([
          AvailabilityOrderByWithRelationInputSchema.array(),
          AvailabilityOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: AvailabilityWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([AvailabilityScalarFieldEnumSchema, AvailabilityScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const AvailabilityFindManyArgsSchema: z.ZodType<Prisma.AvailabilityFindManyArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    where: AvailabilityWhereInputSchema.optional(),
    orderBy: z
      .union([
        AvailabilityOrderByWithRelationInputSchema.array(),
        AvailabilityOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: AvailabilityWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([AvailabilityScalarFieldEnumSchema, AvailabilityScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const AvailabilityAggregateArgsSchema: z.ZodType<Prisma.AvailabilityAggregateArgs> = z
  .object({
    where: AvailabilityWhereInputSchema.optional(),
    orderBy: z
      .union([
        AvailabilityOrderByWithRelationInputSchema.array(),
        AvailabilityOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: AvailabilityWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const AvailabilityGroupByArgsSchema: z.ZodType<Prisma.AvailabilityGroupByArgs> = z
  .object({
    where: AvailabilityWhereInputSchema.optional(),
    orderBy: z
      .union([
        AvailabilityOrderByWithAggregationInputSchema.array(),
        AvailabilityOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: AvailabilityScalarFieldEnumSchema.array(),
    having: AvailabilityScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const AvailabilityFindUniqueArgsSchema: z.ZodType<Prisma.AvailabilityFindUniqueArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    where: AvailabilityWhereUniqueInputSchema,
  })
  .strict();

export const AvailabilityFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.AvailabilityFindUniqueOrThrowArgs> =
  z
    .object({
      select: AvailabilitySelectSchema.optional(),
      include: AvailabilityIncludeSchema.optional(),
      where: AvailabilityWhereUniqueInputSchema,
    })
    .strict();

export const CalculatedAvailabilitySlotFindFirstArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotFindFirstArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema.array(),
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalculatedAvailabilitySlotWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalculatedAvailabilitySlotScalarFieldEnumSchema,
          CalculatedAvailabilitySlotScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotFindFirstOrThrowArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema.array(),
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalculatedAvailabilitySlotWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalculatedAvailabilitySlotScalarFieldEnumSchema,
          CalculatedAvailabilitySlotScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotFindManyArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotFindManyArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema.array(),
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalculatedAvailabilitySlotWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalculatedAvailabilitySlotScalarFieldEnumSchema,
          CalculatedAvailabilitySlotScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotAggregateArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotAggregateArgs> =
  z
    .object({
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema.array(),
          CalculatedAvailabilitySlotOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalculatedAvailabilitySlotWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotGroupByArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotGroupByArgs> =
  z
    .object({
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalculatedAvailabilitySlotOrderByWithAggregationInputSchema.array(),
          CalculatedAvailabilitySlotOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CalculatedAvailabilitySlotScalarFieldEnumSchema.array(),
      having: CalculatedAvailabilitySlotScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotFindUniqueArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotFindUniqueArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereUniqueInputSchema,
    })
    .strict();

export const CalculatedAvailabilitySlotFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotFindUniqueOrThrowArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereUniqueInputSchema,
    })
    .strict();

export const BookingFindFirstArgsSchema: z.ZodType<Prisma.BookingFindFirstArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereInputSchema.optional(),
    orderBy: z
      .union([BookingOrderByWithRelationInputSchema.array(), BookingOrderByWithRelationInputSchema])
      .optional(),
    cursor: BookingWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([BookingScalarFieldEnumSchema, BookingScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const BookingFindFirstOrThrowArgsSchema: z.ZodType<Prisma.BookingFindFirstOrThrowArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereInputSchema.optional(),
    orderBy: z
      .union([BookingOrderByWithRelationInputSchema.array(), BookingOrderByWithRelationInputSchema])
      .optional(),
    cursor: BookingWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([BookingScalarFieldEnumSchema, BookingScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const BookingFindManyArgsSchema: z.ZodType<Prisma.BookingFindManyArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereInputSchema.optional(),
    orderBy: z
      .union([BookingOrderByWithRelationInputSchema.array(), BookingOrderByWithRelationInputSchema])
      .optional(),
    cursor: BookingWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([BookingScalarFieldEnumSchema, BookingScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const BookingAggregateArgsSchema: z.ZodType<Prisma.BookingAggregateArgs> = z
  .object({
    where: BookingWhereInputSchema.optional(),
    orderBy: z
      .union([BookingOrderByWithRelationInputSchema.array(), BookingOrderByWithRelationInputSchema])
      .optional(),
    cursor: BookingWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const BookingGroupByArgsSchema: z.ZodType<Prisma.BookingGroupByArgs> = z
  .object({
    where: BookingWhereInputSchema.optional(),
    orderBy: z
      .union([
        BookingOrderByWithAggregationInputSchema.array(),
        BookingOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: BookingScalarFieldEnumSchema.array(),
    having: BookingScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const BookingFindUniqueArgsSchema: z.ZodType<Prisma.BookingFindUniqueArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereUniqueInputSchema,
  })
  .strict();

export const BookingFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.BookingFindUniqueOrThrowArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereUniqueInputSchema,
  })
  .strict();

export const CommunicationPreferenceFindFirstArgsSchema: z.ZodType<Prisma.CommunicationPreferenceFindFirstArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationPreferenceOrderByWithRelationInputSchema.array(),
          CommunicationPreferenceOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationPreferenceWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommunicationPreferenceScalarFieldEnumSchema,
          CommunicationPreferenceScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CommunicationPreferenceFindFirstOrThrowArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationPreferenceOrderByWithRelationInputSchema.array(),
          CommunicationPreferenceOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationPreferenceWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommunicationPreferenceScalarFieldEnumSchema,
          CommunicationPreferenceScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceFindManyArgsSchema: z.ZodType<Prisma.CommunicationPreferenceFindManyArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationPreferenceOrderByWithRelationInputSchema.array(),
          CommunicationPreferenceOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationPreferenceWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommunicationPreferenceScalarFieldEnumSchema,
          CommunicationPreferenceScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationPreferenceAggregateArgsSchema: z.ZodType<Prisma.CommunicationPreferenceAggregateArgs> =
  z
    .object({
      where: CommunicationPreferenceWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationPreferenceOrderByWithRelationInputSchema.array(),
          CommunicationPreferenceOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationPreferenceWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CommunicationPreferenceGroupByArgsSchema: z.ZodType<Prisma.CommunicationPreferenceGroupByArgs> =
  z
    .object({
      where: CommunicationPreferenceWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationPreferenceOrderByWithAggregationInputSchema.array(),
          CommunicationPreferenceOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CommunicationPreferenceScalarFieldEnumSchema.array(),
      having: CommunicationPreferenceScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CommunicationPreferenceFindUniqueArgsSchema: z.ZodType<Prisma.CommunicationPreferenceFindUniqueArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereUniqueInputSchema,
    })
    .strict();

export const CommunicationPreferenceFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CommunicationPreferenceFindUniqueOrThrowArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereUniqueInputSchema,
    })
    .strict();

export const CommunicationLogFindFirstArgsSchema: z.ZodType<Prisma.CommunicationLogFindFirstArgs> =
  z
    .object({
      select: CommunicationLogSelectSchema.optional(),
      include: CommunicationLogIncludeSchema.optional(),
      where: CommunicationLogWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationLogOrderByWithRelationInputSchema.array(),
          CommunicationLogOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationLogWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommunicationLogScalarFieldEnumSchema,
          CommunicationLogScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationLogFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CommunicationLogFindFirstOrThrowArgs> =
  z
    .object({
      select: CommunicationLogSelectSchema.optional(),
      include: CommunicationLogIncludeSchema.optional(),
      where: CommunicationLogWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationLogOrderByWithRelationInputSchema.array(),
          CommunicationLogOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationLogWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CommunicationLogScalarFieldEnumSchema,
          CommunicationLogScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CommunicationLogFindManyArgsSchema: z.ZodType<Prisma.CommunicationLogFindManyArgs> = z
  .object({
    select: CommunicationLogSelectSchema.optional(),
    include: CommunicationLogIncludeSchema.optional(),
    where: CommunicationLogWhereInputSchema.optional(),
    orderBy: z
      .union([
        CommunicationLogOrderByWithRelationInputSchema.array(),
        CommunicationLogOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CommunicationLogWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CommunicationLogScalarFieldEnumSchema, CommunicationLogScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const CommunicationLogAggregateArgsSchema: z.ZodType<Prisma.CommunicationLogAggregateArgs> =
  z
    .object({
      where: CommunicationLogWhereInputSchema.optional(),
      orderBy: z
        .union([
          CommunicationLogOrderByWithRelationInputSchema.array(),
          CommunicationLogOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CommunicationLogWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CommunicationLogGroupByArgsSchema: z.ZodType<Prisma.CommunicationLogGroupByArgs> = z
  .object({
    where: CommunicationLogWhereInputSchema.optional(),
    orderBy: z
      .union([
        CommunicationLogOrderByWithAggregationInputSchema.array(),
        CommunicationLogOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: CommunicationLogScalarFieldEnumSchema.array(),
    having: CommunicationLogScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const CommunicationLogFindUniqueArgsSchema: z.ZodType<Prisma.CommunicationLogFindUniqueArgs> =
  z
    .object({
      select: CommunicationLogSelectSchema.optional(),
      include: CommunicationLogIncludeSchema.optional(),
      where: CommunicationLogWhereUniqueInputSchema,
    })
    .strict();

export const CommunicationLogFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CommunicationLogFindUniqueOrThrowArgs> =
  z
    .object({
      select: CommunicationLogSelectSchema.optional(),
      include: CommunicationLogIncludeSchema.optional(),
      where: CommunicationLogWhereUniqueInputSchema,
    })
    .strict();

export const CalendarIntegrationFindFirstArgsSchema: z.ZodType<Prisma.CalendarIntegrationFindFirstArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarIntegrationOrderByWithRelationInputSchema.array(),
          CalendarIntegrationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarIntegrationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalendarIntegrationScalarFieldEnumSchema,
          CalendarIntegrationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CalendarIntegrationFindFirstOrThrowArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarIntegrationOrderByWithRelationInputSchema.array(),
          CalendarIntegrationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarIntegrationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalendarIntegrationScalarFieldEnumSchema,
          CalendarIntegrationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationFindManyArgsSchema: z.ZodType<Prisma.CalendarIntegrationFindManyArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarIntegrationOrderByWithRelationInputSchema.array(),
          CalendarIntegrationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarIntegrationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalendarIntegrationScalarFieldEnumSchema,
          CalendarIntegrationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarIntegrationAggregateArgsSchema: z.ZodType<Prisma.CalendarIntegrationAggregateArgs> =
  z
    .object({
      where: CalendarIntegrationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarIntegrationOrderByWithRelationInputSchema.array(),
          CalendarIntegrationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarIntegrationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CalendarIntegrationGroupByArgsSchema: z.ZodType<Prisma.CalendarIntegrationGroupByArgs> =
  z
    .object({
      where: CalendarIntegrationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarIntegrationOrderByWithAggregationInputSchema.array(),
          CalendarIntegrationOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CalendarIntegrationScalarFieldEnumSchema.array(),
      having: CalendarIntegrationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CalendarIntegrationFindUniqueArgsSchema: z.ZodType<Prisma.CalendarIntegrationFindUniqueArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarIntegrationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CalendarIntegrationFindUniqueOrThrowArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarEventFindFirstArgsSchema: z.ZodType<Prisma.CalendarEventFindFirstArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    where: CalendarEventWhereInputSchema.optional(),
    orderBy: z
      .union([
        CalendarEventOrderByWithRelationInputSchema.array(),
        CalendarEventOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CalendarEventWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CalendarEventScalarFieldEnumSchema, CalendarEventScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const CalendarEventFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CalendarEventFindFirstOrThrowArgs> =
  z
    .object({
      select: CalendarEventSelectSchema.optional(),
      include: CalendarEventIncludeSchema.optional(),
      where: CalendarEventWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarEventOrderByWithRelationInputSchema.array(),
          CalendarEventOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarEventWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([CalendarEventScalarFieldEnumSchema, CalendarEventScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const CalendarEventFindManyArgsSchema: z.ZodType<Prisma.CalendarEventFindManyArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    where: CalendarEventWhereInputSchema.optional(),
    orderBy: z
      .union([
        CalendarEventOrderByWithRelationInputSchema.array(),
        CalendarEventOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CalendarEventWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([CalendarEventScalarFieldEnumSchema, CalendarEventScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const CalendarEventAggregateArgsSchema: z.ZodType<Prisma.CalendarEventAggregateArgs> = z
  .object({
    where: CalendarEventWhereInputSchema.optional(),
    orderBy: z
      .union([
        CalendarEventOrderByWithRelationInputSchema.array(),
        CalendarEventOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: CalendarEventWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const CalendarEventGroupByArgsSchema: z.ZodType<Prisma.CalendarEventGroupByArgs> = z
  .object({
    where: CalendarEventWhereInputSchema.optional(),
    orderBy: z
      .union([
        CalendarEventOrderByWithAggregationInputSchema.array(),
        CalendarEventOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: CalendarEventScalarFieldEnumSchema.array(),
    having: CalendarEventScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const CalendarEventFindUniqueArgsSchema: z.ZodType<Prisma.CalendarEventFindUniqueArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    where: CalendarEventWhereUniqueInputSchema,
  })
  .strict();

export const CalendarEventFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CalendarEventFindUniqueOrThrowArgs> =
  z
    .object({
      select: CalendarEventSelectSchema.optional(),
      include: CalendarEventIncludeSchema.optional(),
      where: CalendarEventWhereUniqueInputSchema,
    })
    .strict();

export const CalendarSyncOperationFindFirstArgsSchema: z.ZodType<Prisma.CalendarSyncOperationFindFirstArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarSyncOperationOrderByWithRelationInputSchema.array(),
          CalendarSyncOperationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarSyncOperationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalendarSyncOperationScalarFieldEnumSchema,
          CalendarSyncOperationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationFindFirstOrThrowArgsSchema: z.ZodType<Prisma.CalendarSyncOperationFindFirstOrThrowArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarSyncOperationOrderByWithRelationInputSchema.array(),
          CalendarSyncOperationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarSyncOperationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalendarSyncOperationScalarFieldEnumSchema,
          CalendarSyncOperationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationFindManyArgsSchema: z.ZodType<Prisma.CalendarSyncOperationFindManyArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarSyncOperationOrderByWithRelationInputSchema.array(),
          CalendarSyncOperationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarSyncOperationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([
          CalendarSyncOperationScalarFieldEnumSchema,
          CalendarSyncOperationScalarFieldEnumSchema.array(),
        ])
        .optional(),
    })
    .strict();

export const CalendarSyncOperationAggregateArgsSchema: z.ZodType<Prisma.CalendarSyncOperationAggregateArgs> =
  z
    .object({
      where: CalendarSyncOperationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarSyncOperationOrderByWithRelationInputSchema.array(),
          CalendarSyncOperationOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: CalendarSyncOperationWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CalendarSyncOperationGroupByArgsSchema: z.ZodType<Prisma.CalendarSyncOperationGroupByArgs> =
  z
    .object({
      where: CalendarSyncOperationWhereInputSchema.optional(),
      orderBy: z
        .union([
          CalendarSyncOperationOrderByWithAggregationInputSchema.array(),
          CalendarSyncOperationOrderByWithAggregationInputSchema,
        ])
        .optional(),
      by: CalendarSyncOperationScalarFieldEnumSchema.array(),
      having: CalendarSyncOperationScalarWhereWithAggregatesInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
    })
    .strict();

export const CalendarSyncOperationFindUniqueArgsSchema: z.ZodType<Prisma.CalendarSyncOperationFindUniqueArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarSyncOperationFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.CalendarSyncOperationFindUniqueOrThrowArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereUniqueInputSchema,
    })
    .strict();

export const MeetSessionFindFirstArgsSchema: z.ZodType<Prisma.MeetSessionFindFirstArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    where: MeetSessionWhereInputSchema.optional(),
    orderBy: z
      .union([
        MeetSessionOrderByWithRelationInputSchema.array(),
        MeetSessionOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: MeetSessionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([MeetSessionScalarFieldEnumSchema, MeetSessionScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const MeetSessionFindFirstOrThrowArgsSchema: z.ZodType<Prisma.MeetSessionFindFirstOrThrowArgs> =
  z
    .object({
      select: MeetSessionSelectSchema.optional(),
      include: MeetSessionIncludeSchema.optional(),
      where: MeetSessionWhereInputSchema.optional(),
      orderBy: z
        .union([
          MeetSessionOrderByWithRelationInputSchema.array(),
          MeetSessionOrderByWithRelationInputSchema,
        ])
        .optional(),
      cursor: MeetSessionWhereUniqueInputSchema.optional(),
      take: z.number().optional(),
      skip: z.number().optional(),
      distinct: z
        .union([MeetSessionScalarFieldEnumSchema, MeetSessionScalarFieldEnumSchema.array()])
        .optional(),
    })
    .strict();

export const MeetSessionFindManyArgsSchema: z.ZodType<Prisma.MeetSessionFindManyArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    where: MeetSessionWhereInputSchema.optional(),
    orderBy: z
      .union([
        MeetSessionOrderByWithRelationInputSchema.array(),
        MeetSessionOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: MeetSessionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([MeetSessionScalarFieldEnumSchema, MeetSessionScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const MeetSessionAggregateArgsSchema: z.ZodType<Prisma.MeetSessionAggregateArgs> = z
  .object({
    where: MeetSessionWhereInputSchema.optional(),
    orderBy: z
      .union([
        MeetSessionOrderByWithRelationInputSchema.array(),
        MeetSessionOrderByWithRelationInputSchema,
      ])
      .optional(),
    cursor: MeetSessionWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const MeetSessionGroupByArgsSchema: z.ZodType<Prisma.MeetSessionGroupByArgs> = z
  .object({
    where: MeetSessionWhereInputSchema.optional(),
    orderBy: z
      .union([
        MeetSessionOrderByWithAggregationInputSchema.array(),
        MeetSessionOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: MeetSessionScalarFieldEnumSchema.array(),
    having: MeetSessionScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const MeetSessionFindUniqueArgsSchema: z.ZodType<Prisma.MeetSessionFindUniqueArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    where: MeetSessionWhereUniqueInputSchema,
  })
  .strict();

export const MeetSessionFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.MeetSessionFindUniqueOrThrowArgs> =
  z
    .object({
      select: MeetSessionSelectSchema.optional(),
      include: MeetSessionIncludeSchema.optional(),
      where: MeetSessionWhereUniqueInputSchema,
    })
    .strict();

export const ReviewFindFirstArgsSchema: z.ZodType<Prisma.ReviewFindFirstArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereInputSchema.optional(),
    orderBy: z
      .union([ReviewOrderByWithRelationInputSchema.array(), ReviewOrderByWithRelationInputSchema])
      .optional(),
    cursor: ReviewWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ReviewScalarFieldEnumSchema, ReviewScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ReviewFindFirstOrThrowArgsSchema: z.ZodType<Prisma.ReviewFindFirstOrThrowArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereInputSchema.optional(),
    orderBy: z
      .union([ReviewOrderByWithRelationInputSchema.array(), ReviewOrderByWithRelationInputSchema])
      .optional(),
    cursor: ReviewWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ReviewScalarFieldEnumSchema, ReviewScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ReviewFindManyArgsSchema: z.ZodType<Prisma.ReviewFindManyArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereInputSchema.optional(),
    orderBy: z
      .union([ReviewOrderByWithRelationInputSchema.array(), ReviewOrderByWithRelationInputSchema])
      .optional(),
    cursor: ReviewWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
    distinct: z
      .union([ReviewScalarFieldEnumSchema, ReviewScalarFieldEnumSchema.array()])
      .optional(),
  })
  .strict();

export const ReviewAggregateArgsSchema: z.ZodType<Prisma.ReviewAggregateArgs> = z
  .object({
    where: ReviewWhereInputSchema.optional(),
    orderBy: z
      .union([ReviewOrderByWithRelationInputSchema.array(), ReviewOrderByWithRelationInputSchema])
      .optional(),
    cursor: ReviewWhereUniqueInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ReviewGroupByArgsSchema: z.ZodType<Prisma.ReviewGroupByArgs> = z
  .object({
    where: ReviewWhereInputSchema.optional(),
    orderBy: z
      .union([
        ReviewOrderByWithAggregationInputSchema.array(),
        ReviewOrderByWithAggregationInputSchema,
      ])
      .optional(),
    by: ReviewScalarFieldEnumSchema.array(),
    having: ReviewScalarWhereWithAggregatesInputSchema.optional(),
    take: z.number().optional(),
    skip: z.number().optional(),
  })
  .strict();

export const ReviewFindUniqueArgsSchema: z.ZodType<Prisma.ReviewFindUniqueArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereUniqueInputSchema,
  })
  .strict();

export const ReviewFindUniqueOrThrowArgsSchema: z.ZodType<Prisma.ReviewFindUniqueOrThrowArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereUniqueInputSchema,
  })
  .strict();

export const UserCreateArgsSchema: z.ZodType<Prisma.UserCreateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
  })
  .strict();

export const UserUpsertArgsSchema: z.ZodType<Prisma.UserUpsertArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
    create: z.union([UserCreateInputSchema, UserUncheckedCreateInputSchema]),
    update: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
  })
  .strict();

export const UserCreateManyArgsSchema: z.ZodType<Prisma.UserCreateManyArgs> = z
  .object({
    data: z.union([UserCreateManyInputSchema, UserCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const UserCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UserCreateManyAndReturnArgs> = z
  .object({
    data: z.union([UserCreateManyInputSchema, UserCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const UserDeleteArgsSchema: z.ZodType<Prisma.UserDeleteArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const UserUpdateArgsSchema: z.ZodType<Prisma.UserUpdateArgs> = z
  .object({
    select: UserSelectSchema.optional(),
    include: UserIncludeSchema.optional(),
    data: z.union([UserUpdateInputSchema, UserUncheckedUpdateInputSchema]),
    where: UserWhereUniqueInputSchema,
  })
  .strict();

export const UserUpdateManyArgsSchema: z.ZodType<Prisma.UserUpdateManyArgs> = z
  .object({
    data: z.union([UserUpdateManyMutationInputSchema, UserUncheckedUpdateManyInputSchema]),
    where: UserWhereInputSchema.optional(),
  })
  .strict();

export const UserDeleteManyArgsSchema: z.ZodType<Prisma.UserDeleteManyArgs> = z
  .object({
    where: UserWhereInputSchema.optional(),
  })
  .strict();

export const AccountCreateArgsSchema: z.ZodType<Prisma.AccountCreateArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    data: z.union([AccountCreateInputSchema, AccountUncheckedCreateInputSchema]),
  })
  .strict();

export const AccountUpsertArgsSchema: z.ZodType<Prisma.AccountUpsertArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
    create: z.union([AccountCreateInputSchema, AccountUncheckedCreateInputSchema]),
    update: z.union([AccountUpdateInputSchema, AccountUncheckedUpdateInputSchema]),
  })
  .strict();

export const AccountCreateManyArgsSchema: z.ZodType<Prisma.AccountCreateManyArgs> = z
  .object({
    data: z.union([AccountCreateManyInputSchema, AccountCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const AccountCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AccountCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([AccountCreateManyInputSchema, AccountCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AccountDeleteArgsSchema: z.ZodType<Prisma.AccountDeleteArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    where: AccountWhereUniqueInputSchema,
  })
  .strict();

export const AccountUpdateArgsSchema: z.ZodType<Prisma.AccountUpdateArgs> = z
  .object({
    select: AccountSelectSchema.optional(),
    include: AccountIncludeSchema.optional(),
    data: z.union([AccountUpdateInputSchema, AccountUncheckedUpdateInputSchema]),
    where: AccountWhereUniqueInputSchema,
  })
  .strict();

export const AccountUpdateManyArgsSchema: z.ZodType<Prisma.AccountUpdateManyArgs> = z
  .object({
    data: z.union([AccountUpdateManyMutationInputSchema, AccountUncheckedUpdateManyInputSchema]),
    where: AccountWhereInputSchema.optional(),
  })
  .strict();

export const AccountDeleteManyArgsSchema: z.ZodType<Prisma.AccountDeleteManyArgs> = z
  .object({
    where: AccountWhereInputSchema.optional(),
  })
  .strict();

export const ServiceProviderTypeCreateArgsSchema: z.ZodType<Prisma.ServiceProviderTypeCreateArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      data: z.union([
        ServiceProviderTypeCreateInputSchema,
        ServiceProviderTypeUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const ServiceProviderTypeUpsertArgsSchema: z.ZodType<Prisma.ServiceProviderTypeUpsertArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereUniqueInputSchema,
      create: z.union([
        ServiceProviderTypeCreateInputSchema,
        ServiceProviderTypeUncheckedCreateInputSchema,
      ]),
      update: z.union([
        ServiceProviderTypeUpdateInputSchema,
        ServiceProviderTypeUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const ServiceProviderTypeCreateManyArgsSchema: z.ZodType<Prisma.ServiceProviderTypeCreateManyArgs> =
  z
    .object({
      data: z.union([
        ServiceProviderTypeCreateManyInputSchema,
        ServiceProviderTypeCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderTypeCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ServiceProviderTypeCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ServiceProviderTypeCreateManyInputSchema,
        ServiceProviderTypeCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderTypeDeleteArgsSchema: z.ZodType<Prisma.ServiceProviderTypeDeleteArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      where: ServiceProviderTypeWhereUniqueInputSchema,
    })
    .strict();

export const ServiceProviderTypeUpdateArgsSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateArgs> =
  z
    .object({
      select: ServiceProviderTypeSelectSchema.optional(),
      include: ServiceProviderTypeIncludeSchema.optional(),
      data: z.union([
        ServiceProviderTypeUpdateInputSchema,
        ServiceProviderTypeUncheckedUpdateInputSchema,
      ]),
      where: ServiceProviderTypeWhereUniqueInputSchema,
    })
    .strict();

export const ServiceProviderTypeUpdateManyArgsSchema: z.ZodType<Prisma.ServiceProviderTypeUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ServiceProviderTypeUpdateManyMutationInputSchema,
        ServiceProviderTypeUncheckedUpdateManyInputSchema,
      ]),
      where: ServiceProviderTypeWhereInputSchema.optional(),
    })
    .strict();

export const ServiceProviderTypeDeleteManyArgsSchema: z.ZodType<Prisma.ServiceProviderTypeDeleteManyArgs> =
  z
    .object({
      where: ServiceProviderTypeWhereInputSchema.optional(),
    })
    .strict();

export const ServiceProviderCreateArgsSchema: z.ZodType<Prisma.ServiceProviderCreateArgs> = z
  .object({
    select: ServiceProviderSelectSchema.optional(),
    include: ServiceProviderIncludeSchema.optional(),
    data: z.union([ServiceProviderCreateInputSchema, ServiceProviderUncheckedCreateInputSchema]),
  })
  .strict();

export const ServiceProviderUpsertArgsSchema: z.ZodType<Prisma.ServiceProviderUpsertArgs> = z
  .object({
    select: ServiceProviderSelectSchema.optional(),
    include: ServiceProviderIncludeSchema.optional(),
    where: ServiceProviderWhereUniqueInputSchema,
    create: z.union([ServiceProviderCreateInputSchema, ServiceProviderUncheckedCreateInputSchema]),
    update: z.union([ServiceProviderUpdateInputSchema, ServiceProviderUncheckedUpdateInputSchema]),
  })
  .strict();

export const ServiceProviderCreateManyArgsSchema: z.ZodType<Prisma.ServiceProviderCreateManyArgs> =
  z
    .object({
      data: z.union([
        ServiceProviderCreateManyInputSchema,
        ServiceProviderCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ServiceProviderCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ServiceProviderCreateManyInputSchema,
        ServiceProviderCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceProviderDeleteArgsSchema: z.ZodType<Prisma.ServiceProviderDeleteArgs> = z
  .object({
    select: ServiceProviderSelectSchema.optional(),
    include: ServiceProviderIncludeSchema.optional(),
    where: ServiceProviderWhereUniqueInputSchema,
  })
  .strict();

export const ServiceProviderUpdateArgsSchema: z.ZodType<Prisma.ServiceProviderUpdateArgs> = z
  .object({
    select: ServiceProviderSelectSchema.optional(),
    include: ServiceProviderIncludeSchema.optional(),
    data: z.union([ServiceProviderUpdateInputSchema, ServiceProviderUncheckedUpdateInputSchema]),
    where: ServiceProviderWhereUniqueInputSchema,
  })
  .strict();

export const ServiceProviderUpdateManyArgsSchema: z.ZodType<Prisma.ServiceProviderUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ServiceProviderUpdateManyMutationInputSchema,
        ServiceProviderUncheckedUpdateManyInputSchema,
      ]),
      where: ServiceProviderWhereInputSchema.optional(),
    })
    .strict();

export const ServiceProviderDeleteManyArgsSchema: z.ZodType<Prisma.ServiceProviderDeleteManyArgs> =
  z
    .object({
      where: ServiceProviderWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationCreateArgsSchema: z.ZodType<Prisma.OrganizationCreateArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    data: z.union([OrganizationCreateInputSchema, OrganizationUncheckedCreateInputSchema]),
  })
  .strict();

export const OrganizationUpsertArgsSchema: z.ZodType<Prisma.OrganizationUpsertArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    where: OrganizationWhereUniqueInputSchema,
    create: z.union([OrganizationCreateInputSchema, OrganizationUncheckedCreateInputSchema]),
    update: z.union([OrganizationUpdateInputSchema, OrganizationUncheckedUpdateInputSchema]),
  })
  .strict();

export const OrganizationCreateManyArgsSchema: z.ZodType<Prisma.OrganizationCreateManyArgs> = z
  .object({
    data: z.union([OrganizationCreateManyInputSchema, OrganizationCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const OrganizationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrganizationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([OrganizationCreateManyInputSchema, OrganizationCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationDeleteArgsSchema: z.ZodType<Prisma.OrganizationDeleteArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    where: OrganizationWhereUniqueInputSchema,
  })
  .strict();

export const OrganizationUpdateArgsSchema: z.ZodType<Prisma.OrganizationUpdateArgs> = z
  .object({
    select: OrganizationSelectSchema.optional(),
    include: OrganizationIncludeSchema.optional(),
    data: z.union([OrganizationUpdateInputSchema, OrganizationUncheckedUpdateInputSchema]),
    where: OrganizationWhereUniqueInputSchema,
  })
  .strict();

export const OrganizationUpdateManyArgsSchema: z.ZodType<Prisma.OrganizationUpdateManyArgs> = z
  .object({
    data: z.union([
      OrganizationUpdateManyMutationInputSchema,
      OrganizationUncheckedUpdateManyInputSchema,
    ]),
    where: OrganizationWhereInputSchema.optional(),
  })
  .strict();

export const OrganizationDeleteManyArgsSchema: z.ZodType<Prisma.OrganizationDeleteManyArgs> = z
  .object({
    where: OrganizationWhereInputSchema.optional(),
  })
  .strict();

export const OrganizationInvitationCreateArgsSchema: z.ZodType<Prisma.OrganizationInvitationCreateArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      data: z.union([
        OrganizationInvitationCreateInputSchema,
        OrganizationInvitationUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const OrganizationInvitationUpsertArgsSchema: z.ZodType<Prisma.OrganizationInvitationUpsertArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereUniqueInputSchema,
      create: z.union([
        OrganizationInvitationCreateInputSchema,
        OrganizationInvitationUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrganizationInvitationUpdateInputSchema,
        OrganizationInvitationUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const OrganizationInvitationCreateManyArgsSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationInvitationCreateManyInputSchema,
        OrganizationInvitationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationInvitationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrganizationInvitationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrganizationInvitationCreateManyInputSchema,
        OrganizationInvitationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationInvitationDeleteArgsSchema: z.ZodType<Prisma.OrganizationInvitationDeleteArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      where: OrganizationInvitationWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationInvitationUpdateArgsSchema: z.ZodType<Prisma.OrganizationInvitationUpdateArgs> =
  z
    .object({
      select: OrganizationInvitationSelectSchema.optional(),
      include: OrganizationInvitationIncludeSchema.optional(),
      data: z.union([
        OrganizationInvitationUpdateInputSchema,
        OrganizationInvitationUncheckedUpdateInputSchema,
      ]),
      where: OrganizationInvitationWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationInvitationUpdateManyArgsSchema: z.ZodType<Prisma.OrganizationInvitationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationInvitationUpdateManyMutationInputSchema,
        OrganizationInvitationUncheckedUpdateManyInputSchema,
      ]),
      where: OrganizationInvitationWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationInvitationDeleteManyArgsSchema: z.ZodType<Prisma.OrganizationInvitationDeleteManyArgs> =
  z
    .object({
      where: OrganizationInvitationWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationMembershipCreateArgsSchema: z.ZodType<Prisma.OrganizationMembershipCreateArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      data: z.union([
        OrganizationMembershipCreateInputSchema,
        OrganizationMembershipUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const OrganizationMembershipUpsertArgsSchema: z.ZodType<Prisma.OrganizationMembershipUpsertArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereUniqueInputSchema,
      create: z.union([
        OrganizationMembershipCreateInputSchema,
        OrganizationMembershipUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrganizationMembershipUpdateInputSchema,
        OrganizationMembershipUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const OrganizationMembershipCreateManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationMembershipCreateManyInputSchema,
        OrganizationMembershipCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrganizationMembershipCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrganizationMembershipCreateManyInputSchema,
        OrganizationMembershipCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipDeleteArgsSchema: z.ZodType<Prisma.OrganizationMembershipDeleteArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      where: OrganizationMembershipWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipUpdateArgsSchema: z.ZodType<Prisma.OrganizationMembershipUpdateArgs> =
  z
    .object({
      select: OrganizationMembershipSelectSchema.optional(),
      include: OrganizationMembershipIncludeSchema.optional(),
      data: z.union([
        OrganizationMembershipUpdateInputSchema,
        OrganizationMembershipUncheckedUpdateInputSchema,
      ]),
      where: OrganizationMembershipWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipUpdateManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationMembershipUpdateManyMutationInputSchema,
        OrganizationMembershipUncheckedUpdateManyInputSchema,
      ]),
      where: OrganizationMembershipWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationMembershipDeleteManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipDeleteManyArgs> =
  z
    .object({
      where: OrganizationMembershipWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      data: z.union([
        OrganizationMembershipHistoryCreateInputSchema,
        OrganizationMembershipHistoryUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryUpsertArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpsertArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereUniqueInputSchema,
      create: z.union([
        OrganizationMembershipHistoryCreateInputSchema,
        OrganizationMembershipHistoryUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrganizationMembershipHistoryUpdateInputSchema,
        OrganizationMembershipHistoryUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationMembershipHistoryCreateManyInputSchema,
        OrganizationMembershipHistoryCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrganizationMembershipHistoryCreateManyInputSchema,
        OrganizationMembershipHistoryCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationMembershipHistoryDeleteArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryDeleteArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      where: OrganizationMembershipHistoryWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipHistoryUpdateArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateArgs> =
  z
    .object({
      select: OrganizationMembershipHistorySelectSchema.optional(),
      include: OrganizationMembershipHistoryIncludeSchema.optional(),
      data: z.union([
        OrganizationMembershipHistoryUpdateInputSchema,
        OrganizationMembershipHistoryUncheckedUpdateInputSchema,
      ]),
      where: OrganizationMembershipHistoryWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationMembershipHistoryUpdateManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationMembershipHistoryUpdateManyMutationInputSchema,
        OrganizationMembershipHistoryUncheckedUpdateManyInputSchema,
      ]),
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationMembershipHistoryDeleteManyArgsSchema: z.ZodType<Prisma.OrganizationMembershipHistoryDeleteManyArgs> =
  z
    .object({
      where: OrganizationMembershipHistoryWhereInputSchema.optional(),
    })
    .strict();

export const LocationCreateArgsSchema: z.ZodType<Prisma.LocationCreateArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    data: z.union([LocationCreateInputSchema, LocationUncheckedCreateInputSchema]),
  })
  .strict();

export const LocationUpsertArgsSchema: z.ZodType<Prisma.LocationUpsertArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    where: LocationWhereUniqueInputSchema,
    create: z.union([LocationCreateInputSchema, LocationUncheckedCreateInputSchema]),
    update: z.union([LocationUpdateInputSchema, LocationUncheckedUpdateInputSchema]),
  })
  .strict();

export const LocationCreateManyArgsSchema: z.ZodType<Prisma.LocationCreateManyArgs> = z
  .object({
    data: z.union([LocationCreateManyInputSchema, LocationCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const LocationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.LocationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([LocationCreateManyInputSchema, LocationCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const LocationDeleteArgsSchema: z.ZodType<Prisma.LocationDeleteArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    where: LocationWhereUniqueInputSchema,
  })
  .strict();

export const LocationUpdateArgsSchema: z.ZodType<Prisma.LocationUpdateArgs> = z
  .object({
    select: LocationSelectSchema.optional(),
    include: LocationIncludeSchema.optional(),
    data: z.union([LocationUpdateInputSchema, LocationUncheckedUpdateInputSchema]),
    where: LocationWhereUniqueInputSchema,
  })
  .strict();

export const LocationUpdateManyArgsSchema: z.ZodType<Prisma.LocationUpdateManyArgs> = z
  .object({
    data: z.union([LocationUpdateManyMutationInputSchema, LocationUncheckedUpdateManyInputSchema]),
    where: LocationWhereInputSchema.optional(),
  })
  .strict();

export const LocationDeleteManyArgsSchema: z.ZodType<Prisma.LocationDeleteManyArgs> = z
  .object({
    where: LocationWhereInputSchema.optional(),
  })
  .strict();

export const OrganizationProviderConnectionCreateArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      data: z.union([
        OrganizationProviderConnectionCreateInputSchema,
        OrganizationProviderConnectionUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const OrganizationProviderConnectionUpsertArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpsertArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereUniqueInputSchema,
      create: z.union([
        OrganizationProviderConnectionCreateInputSchema,
        OrganizationProviderConnectionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        OrganizationProviderConnectionUpdateInputSchema,
        OrganizationProviderConnectionUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationProviderConnectionCreateManyInputSchema,
        OrganizationProviderConnectionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationProviderConnectionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        OrganizationProviderConnectionCreateManyInputSchema,
        OrganizationProviderConnectionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const OrganizationProviderConnectionDeleteArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionDeleteArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      where: OrganizationProviderConnectionWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationProviderConnectionUpdateArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateArgs> =
  z
    .object({
      select: OrganizationProviderConnectionSelectSchema.optional(),
      include: OrganizationProviderConnectionIncludeSchema.optional(),
      data: z.union([
        OrganizationProviderConnectionUpdateInputSchema,
        OrganizationProviderConnectionUncheckedUpdateInputSchema,
      ]),
      where: OrganizationProviderConnectionWhereUniqueInputSchema,
    })
    .strict();

export const OrganizationProviderConnectionUpdateManyArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        OrganizationProviderConnectionUpdateManyMutationInputSchema,
        OrganizationProviderConnectionUncheckedUpdateManyInputSchema,
      ]),
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
    })
    .strict();

export const OrganizationProviderConnectionDeleteManyArgsSchema: z.ZodType<Prisma.OrganizationProviderConnectionDeleteManyArgs> =
  z
    .object({
      where: OrganizationProviderConnectionWhereInputSchema.optional(),
    })
    .strict();

export const SubscriptionCreateArgsSchema: z.ZodType<Prisma.SubscriptionCreateArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    data: z.union([SubscriptionCreateInputSchema, SubscriptionUncheckedCreateInputSchema]),
  })
  .strict();

export const SubscriptionUpsertArgsSchema: z.ZodType<Prisma.SubscriptionUpsertArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    where: SubscriptionWhereUniqueInputSchema,
    create: z.union([SubscriptionCreateInputSchema, SubscriptionUncheckedCreateInputSchema]),
    update: z.union([SubscriptionUpdateInputSchema, SubscriptionUncheckedUpdateInputSchema]),
  })
  .strict();

export const SubscriptionCreateManyArgsSchema: z.ZodType<Prisma.SubscriptionCreateManyArgs> = z
  .object({
    data: z.union([SubscriptionCreateManyInputSchema, SubscriptionCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const SubscriptionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SubscriptionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([SubscriptionCreateManyInputSchema, SubscriptionCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SubscriptionDeleteArgsSchema: z.ZodType<Prisma.SubscriptionDeleteArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    where: SubscriptionWhereUniqueInputSchema,
  })
  .strict();

export const SubscriptionUpdateArgsSchema: z.ZodType<Prisma.SubscriptionUpdateArgs> = z
  .object({
    select: SubscriptionSelectSchema.optional(),
    include: SubscriptionIncludeSchema.optional(),
    data: z.union([SubscriptionUpdateInputSchema, SubscriptionUncheckedUpdateInputSchema]),
    where: SubscriptionWhereUniqueInputSchema,
  })
  .strict();

export const SubscriptionUpdateManyArgsSchema: z.ZodType<Prisma.SubscriptionUpdateManyArgs> = z
  .object({
    data: z.union([
      SubscriptionUpdateManyMutationInputSchema,
      SubscriptionUncheckedUpdateManyInputSchema,
    ]),
    where: SubscriptionWhereInputSchema.optional(),
  })
  .strict();

export const SubscriptionDeleteManyArgsSchema: z.ZodType<Prisma.SubscriptionDeleteManyArgs> = z
  .object({
    where: SubscriptionWhereInputSchema.optional(),
  })
  .strict();

export const SubscriptionPlanCreateArgsSchema: z.ZodType<Prisma.SubscriptionPlanCreateArgs> = z
  .object({
    select: SubscriptionPlanSelectSchema.optional(),
    include: SubscriptionPlanIncludeSchema.optional(),
    data: z.union([SubscriptionPlanCreateInputSchema, SubscriptionPlanUncheckedCreateInputSchema]),
  })
  .strict();

export const SubscriptionPlanUpsertArgsSchema: z.ZodType<Prisma.SubscriptionPlanUpsertArgs> = z
  .object({
    select: SubscriptionPlanSelectSchema.optional(),
    include: SubscriptionPlanIncludeSchema.optional(),
    where: SubscriptionPlanWhereUniqueInputSchema,
    create: z.union([
      SubscriptionPlanCreateInputSchema,
      SubscriptionPlanUncheckedCreateInputSchema,
    ]),
    update: z.union([
      SubscriptionPlanUpdateInputSchema,
      SubscriptionPlanUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const SubscriptionPlanCreateManyArgsSchema: z.ZodType<Prisma.SubscriptionPlanCreateManyArgs> =
  z
    .object({
      data: z.union([
        SubscriptionPlanCreateManyInputSchema,
        SubscriptionPlanCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SubscriptionPlanCreateManyAndReturnArgsSchema: z.ZodType<Prisma.SubscriptionPlanCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        SubscriptionPlanCreateManyInputSchema,
        SubscriptionPlanCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const SubscriptionPlanDeleteArgsSchema: z.ZodType<Prisma.SubscriptionPlanDeleteArgs> = z
  .object({
    select: SubscriptionPlanSelectSchema.optional(),
    include: SubscriptionPlanIncludeSchema.optional(),
    where: SubscriptionPlanWhereUniqueInputSchema,
  })
  .strict();

export const SubscriptionPlanUpdateArgsSchema: z.ZodType<Prisma.SubscriptionPlanUpdateArgs> = z
  .object({
    select: SubscriptionPlanSelectSchema.optional(),
    include: SubscriptionPlanIncludeSchema.optional(),
    data: z.union([SubscriptionPlanUpdateInputSchema, SubscriptionPlanUncheckedUpdateInputSchema]),
    where: SubscriptionPlanWhereUniqueInputSchema,
  })
  .strict();

export const SubscriptionPlanUpdateManyArgsSchema: z.ZodType<Prisma.SubscriptionPlanUpdateManyArgs> =
  z
    .object({
      data: z.union([
        SubscriptionPlanUpdateManyMutationInputSchema,
        SubscriptionPlanUncheckedUpdateManyInputSchema,
      ]),
      where: SubscriptionPlanWhereInputSchema.optional(),
    })
    .strict();

export const SubscriptionPlanDeleteManyArgsSchema: z.ZodType<Prisma.SubscriptionPlanDeleteManyArgs> =
  z
    .object({
      where: SubscriptionPlanWhereInputSchema.optional(),
    })
    .strict();

export const UsageRecordCreateArgsSchema: z.ZodType<Prisma.UsageRecordCreateArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    data: z.union([UsageRecordCreateInputSchema, UsageRecordUncheckedCreateInputSchema]),
  })
  .strict();

export const UsageRecordUpsertArgsSchema: z.ZodType<Prisma.UsageRecordUpsertArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    where: UsageRecordWhereUniqueInputSchema,
    create: z.union([UsageRecordCreateInputSchema, UsageRecordUncheckedCreateInputSchema]),
    update: z.union([UsageRecordUpdateInputSchema, UsageRecordUncheckedUpdateInputSchema]),
  })
  .strict();

export const UsageRecordCreateManyArgsSchema: z.ZodType<Prisma.UsageRecordCreateManyArgs> = z
  .object({
    data: z.union([UsageRecordCreateManyInputSchema, UsageRecordCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const UsageRecordCreateManyAndReturnArgsSchema: z.ZodType<Prisma.UsageRecordCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([UsageRecordCreateManyInputSchema, UsageRecordCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const UsageRecordDeleteArgsSchema: z.ZodType<Prisma.UsageRecordDeleteArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    where: UsageRecordWhereUniqueInputSchema,
  })
  .strict();

export const UsageRecordUpdateArgsSchema: z.ZodType<Prisma.UsageRecordUpdateArgs> = z
  .object({
    select: UsageRecordSelectSchema.optional(),
    include: UsageRecordIncludeSchema.optional(),
    data: z.union([UsageRecordUpdateInputSchema, UsageRecordUncheckedUpdateInputSchema]),
    where: UsageRecordWhereUniqueInputSchema,
  })
  .strict();

export const UsageRecordUpdateManyArgsSchema: z.ZodType<Prisma.UsageRecordUpdateManyArgs> = z
  .object({
    data: z.union([
      UsageRecordUpdateManyMutationInputSchema,
      UsageRecordUncheckedUpdateManyInputSchema,
    ]),
    where: UsageRecordWhereInputSchema.optional(),
  })
  .strict();

export const UsageRecordDeleteManyArgsSchema: z.ZodType<Prisma.UsageRecordDeleteManyArgs> = z
  .object({
    where: UsageRecordWhereInputSchema.optional(),
  })
  .strict();

export const PaymentCreateArgsSchema: z.ZodType<Prisma.PaymentCreateArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    data: z.union([PaymentCreateInputSchema, PaymentUncheckedCreateInputSchema]),
  })
  .strict();

export const PaymentUpsertArgsSchema: z.ZodType<Prisma.PaymentUpsertArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereUniqueInputSchema,
    create: z.union([PaymentCreateInputSchema, PaymentUncheckedCreateInputSchema]),
    update: z.union([PaymentUpdateInputSchema, PaymentUncheckedUpdateInputSchema]),
  })
  .strict();

export const PaymentCreateManyArgsSchema: z.ZodType<Prisma.PaymentCreateManyArgs> = z
  .object({
    data: z.union([PaymentCreateManyInputSchema, PaymentCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const PaymentCreateManyAndReturnArgsSchema: z.ZodType<Prisma.PaymentCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([PaymentCreateManyInputSchema, PaymentCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const PaymentDeleteArgsSchema: z.ZodType<Prisma.PaymentDeleteArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    where: PaymentWhereUniqueInputSchema,
  })
  .strict();

export const PaymentUpdateArgsSchema: z.ZodType<Prisma.PaymentUpdateArgs> = z
  .object({
    select: PaymentSelectSchema.optional(),
    include: PaymentIncludeSchema.optional(),
    data: z.union([PaymentUpdateInputSchema, PaymentUncheckedUpdateInputSchema]),
    where: PaymentWhereUniqueInputSchema,
  })
  .strict();

export const PaymentUpdateManyArgsSchema: z.ZodType<Prisma.PaymentUpdateManyArgs> = z
  .object({
    data: z.union([PaymentUpdateManyMutationInputSchema, PaymentUncheckedUpdateManyInputSchema]),
    where: PaymentWhereInputSchema.optional(),
  })
  .strict();

export const PaymentDeleteManyArgsSchema: z.ZodType<Prisma.PaymentDeleteManyArgs> = z
  .object({
    where: PaymentWhereInputSchema.optional(),
  })
  .strict();

export const RequirementTypeCreateArgsSchema: z.ZodType<Prisma.RequirementTypeCreateArgs> = z
  .object({
    select: RequirementTypeSelectSchema.optional(),
    include: RequirementTypeIncludeSchema.optional(),
    data: z.union([RequirementTypeCreateInputSchema, RequirementTypeUncheckedCreateInputSchema]),
  })
  .strict();

export const RequirementTypeUpsertArgsSchema: z.ZodType<Prisma.RequirementTypeUpsertArgs> = z
  .object({
    select: RequirementTypeSelectSchema.optional(),
    include: RequirementTypeIncludeSchema.optional(),
    where: RequirementTypeWhereUniqueInputSchema,
    create: z.union([RequirementTypeCreateInputSchema, RequirementTypeUncheckedCreateInputSchema]),
    update: z.union([RequirementTypeUpdateInputSchema, RequirementTypeUncheckedUpdateInputSchema]),
  })
  .strict();

export const RequirementTypeCreateManyArgsSchema: z.ZodType<Prisma.RequirementTypeCreateManyArgs> =
  z
    .object({
      data: z.union([
        RequirementTypeCreateManyInputSchema,
        RequirementTypeCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementTypeCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RequirementTypeCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RequirementTypeCreateManyInputSchema,
        RequirementTypeCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementTypeDeleteArgsSchema: z.ZodType<Prisma.RequirementTypeDeleteArgs> = z
  .object({
    select: RequirementTypeSelectSchema.optional(),
    include: RequirementTypeIncludeSchema.optional(),
    where: RequirementTypeWhereUniqueInputSchema,
  })
  .strict();

export const RequirementTypeUpdateArgsSchema: z.ZodType<Prisma.RequirementTypeUpdateArgs> = z
  .object({
    select: RequirementTypeSelectSchema.optional(),
    include: RequirementTypeIncludeSchema.optional(),
    data: z.union([RequirementTypeUpdateInputSchema, RequirementTypeUncheckedUpdateInputSchema]),
    where: RequirementTypeWhereUniqueInputSchema,
  })
  .strict();

export const RequirementTypeUpdateManyArgsSchema: z.ZodType<Prisma.RequirementTypeUpdateManyArgs> =
  z
    .object({
      data: z.union([
        RequirementTypeUpdateManyMutationInputSchema,
        RequirementTypeUncheckedUpdateManyInputSchema,
      ]),
      where: RequirementTypeWhereInputSchema.optional(),
    })
    .strict();

export const RequirementTypeDeleteManyArgsSchema: z.ZodType<Prisma.RequirementTypeDeleteManyArgs> =
  z
    .object({
      where: RequirementTypeWhereInputSchema.optional(),
    })
    .strict();

export const RequirementSubmissionCreateArgsSchema: z.ZodType<Prisma.RequirementSubmissionCreateArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      data: z.union([
        RequirementSubmissionCreateInputSchema,
        RequirementSubmissionUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const RequirementSubmissionUpsertArgsSchema: z.ZodType<Prisma.RequirementSubmissionUpsertArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereUniqueInputSchema,
      create: z.union([
        RequirementSubmissionCreateInputSchema,
        RequirementSubmissionUncheckedCreateInputSchema,
      ]),
      update: z.union([
        RequirementSubmissionUpdateInputSchema,
        RequirementSubmissionUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const RequirementSubmissionCreateManyArgsSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyArgs> =
  z
    .object({
      data: z.union([
        RequirementSubmissionCreateManyInputSchema,
        RequirementSubmissionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementSubmissionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.RequirementSubmissionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        RequirementSubmissionCreateManyInputSchema,
        RequirementSubmissionCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const RequirementSubmissionDeleteArgsSchema: z.ZodType<Prisma.RequirementSubmissionDeleteArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      where: RequirementSubmissionWhereUniqueInputSchema,
    })
    .strict();

export const RequirementSubmissionUpdateArgsSchema: z.ZodType<Prisma.RequirementSubmissionUpdateArgs> =
  z
    .object({
      select: RequirementSubmissionSelectSchema.optional(),
      include: RequirementSubmissionIncludeSchema.optional(),
      data: z.union([
        RequirementSubmissionUpdateInputSchema,
        RequirementSubmissionUncheckedUpdateInputSchema,
      ]),
      where: RequirementSubmissionWhereUniqueInputSchema,
    })
    .strict();

export const RequirementSubmissionUpdateManyArgsSchema: z.ZodType<Prisma.RequirementSubmissionUpdateManyArgs> =
  z
    .object({
      data: z.union([
        RequirementSubmissionUpdateManyMutationInputSchema,
        RequirementSubmissionUncheckedUpdateManyInputSchema,
      ]),
      where: RequirementSubmissionWhereInputSchema.optional(),
    })
    .strict();

export const RequirementSubmissionDeleteManyArgsSchema: z.ZodType<Prisma.RequirementSubmissionDeleteManyArgs> =
  z
    .object({
      where: RequirementSubmissionWhereInputSchema.optional(),
    })
    .strict();

export const ServiceCreateArgsSchema: z.ZodType<Prisma.ServiceCreateArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    data: z.union([ServiceCreateInputSchema, ServiceUncheckedCreateInputSchema]),
  })
  .strict();

export const ServiceUpsertArgsSchema: z.ZodType<Prisma.ServiceUpsertArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereUniqueInputSchema,
    create: z.union([ServiceCreateInputSchema, ServiceUncheckedCreateInputSchema]),
    update: z.union([ServiceUpdateInputSchema, ServiceUncheckedUpdateInputSchema]),
  })
  .strict();

export const ServiceCreateManyArgsSchema: z.ZodType<Prisma.ServiceCreateManyArgs> = z
  .object({
    data: z.union([ServiceCreateManyInputSchema, ServiceCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const ServiceCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ServiceCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([ServiceCreateManyInputSchema, ServiceCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceDeleteArgsSchema: z.ZodType<Prisma.ServiceDeleteArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    where: ServiceWhereUniqueInputSchema,
  })
  .strict();

export const ServiceUpdateArgsSchema: z.ZodType<Prisma.ServiceUpdateArgs> = z
  .object({
    select: ServiceSelectSchema.optional(),
    include: ServiceIncludeSchema.optional(),
    data: z.union([ServiceUpdateInputSchema, ServiceUncheckedUpdateInputSchema]),
    where: ServiceWhereUniqueInputSchema,
  })
  .strict();

export const ServiceUpdateManyArgsSchema: z.ZodType<Prisma.ServiceUpdateManyArgs> = z
  .object({
    data: z.union([ServiceUpdateManyMutationInputSchema, ServiceUncheckedUpdateManyInputSchema]),
    where: ServiceWhereInputSchema.optional(),
  })
  .strict();

export const ServiceDeleteManyArgsSchema: z.ZodType<Prisma.ServiceDeleteManyArgs> = z
  .object({
    where: ServiceWhereInputSchema.optional(),
  })
  .strict();

export const ServiceAvailabilityConfigCreateArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      data: z.union([
        ServiceAvailabilityConfigCreateInputSchema,
        ServiceAvailabilityConfigUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigUpsertArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpsertArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereUniqueInputSchema,
      create: z.union([
        ServiceAvailabilityConfigCreateInputSchema,
        ServiceAvailabilityConfigUncheckedCreateInputSchema,
      ]),
      update: z.union([
        ServiceAvailabilityConfigUpdateInputSchema,
        ServiceAvailabilityConfigUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyArgs> =
  z
    .object({
      data: z.union([
        ServiceAvailabilityConfigCreateManyInputSchema,
        ServiceAvailabilityConfigCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        ServiceAvailabilityConfigCreateManyInputSchema,
        ServiceAvailabilityConfigCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ServiceAvailabilityConfigDeleteArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigDeleteArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      where: ServiceAvailabilityConfigWhereUniqueInputSchema,
    })
    .strict();

export const ServiceAvailabilityConfigUpdateArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateArgs> =
  z
    .object({
      select: ServiceAvailabilityConfigSelectSchema.optional(),
      include: ServiceAvailabilityConfigIncludeSchema.optional(),
      data: z.union([
        ServiceAvailabilityConfigUpdateInputSchema,
        ServiceAvailabilityConfigUncheckedUpdateInputSchema,
      ]),
      where: ServiceAvailabilityConfigWhereUniqueInputSchema,
    })
    .strict();

export const ServiceAvailabilityConfigUpdateManyArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigUpdateManyArgs> =
  z
    .object({
      data: z.union([
        ServiceAvailabilityConfigUpdateManyMutationInputSchema,
        ServiceAvailabilityConfigUncheckedUpdateManyInputSchema,
      ]),
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
    })
    .strict();

export const ServiceAvailabilityConfigDeleteManyArgsSchema: z.ZodType<Prisma.ServiceAvailabilityConfigDeleteManyArgs> =
  z
    .object({
      where: ServiceAvailabilityConfigWhereInputSchema.optional(),
    })
    .strict();

export const AvailabilityCreateArgsSchema: z.ZodType<Prisma.AvailabilityCreateArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    data: z.union([AvailabilityCreateInputSchema, AvailabilityUncheckedCreateInputSchema]),
  })
  .strict();

export const AvailabilityUpsertArgsSchema: z.ZodType<Prisma.AvailabilityUpsertArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    where: AvailabilityWhereUniqueInputSchema,
    create: z.union([AvailabilityCreateInputSchema, AvailabilityUncheckedCreateInputSchema]),
    update: z.union([AvailabilityUpdateInputSchema, AvailabilityUncheckedUpdateInputSchema]),
  })
  .strict();

export const AvailabilityCreateManyArgsSchema: z.ZodType<Prisma.AvailabilityCreateManyArgs> = z
  .object({
    data: z.union([AvailabilityCreateManyInputSchema, AvailabilityCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const AvailabilityCreateManyAndReturnArgsSchema: z.ZodType<Prisma.AvailabilityCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([AvailabilityCreateManyInputSchema, AvailabilityCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const AvailabilityDeleteArgsSchema: z.ZodType<Prisma.AvailabilityDeleteArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    where: AvailabilityWhereUniqueInputSchema,
  })
  .strict();

export const AvailabilityUpdateArgsSchema: z.ZodType<Prisma.AvailabilityUpdateArgs> = z
  .object({
    select: AvailabilitySelectSchema.optional(),
    include: AvailabilityIncludeSchema.optional(),
    data: z.union([AvailabilityUpdateInputSchema, AvailabilityUncheckedUpdateInputSchema]),
    where: AvailabilityWhereUniqueInputSchema,
  })
  .strict();

export const AvailabilityUpdateManyArgsSchema: z.ZodType<Prisma.AvailabilityUpdateManyArgs> = z
  .object({
    data: z.union([
      AvailabilityUpdateManyMutationInputSchema,
      AvailabilityUncheckedUpdateManyInputSchema,
    ]),
    where: AvailabilityWhereInputSchema.optional(),
  })
  .strict();

export const AvailabilityDeleteManyArgsSchema: z.ZodType<Prisma.AvailabilityDeleteManyArgs> = z
  .object({
    where: AvailabilityWhereInputSchema.optional(),
  })
  .strict();

export const CalculatedAvailabilitySlotCreateArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      data: z.union([
        CalculatedAvailabilitySlotCreateInputSchema,
        CalculatedAvailabilitySlotUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotUpsertArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpsertArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereUniqueInputSchema,
      create: z.union([
        CalculatedAvailabilitySlotCreateInputSchema,
        CalculatedAvailabilitySlotUncheckedCreateInputSchema,
      ]),
      update: z.union([
        CalculatedAvailabilitySlotUpdateInputSchema,
        CalculatedAvailabilitySlotUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyArgs> =
  z
    .object({
      data: z.union([
        CalculatedAvailabilitySlotCreateManyInputSchema,
        CalculatedAvailabilitySlotCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CalculatedAvailabilitySlotCreateManyInputSchema,
        CalculatedAvailabilitySlotCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotDeleteArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotDeleteArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      where: CalculatedAvailabilitySlotWhereUniqueInputSchema,
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateArgs> =
  z
    .object({
      select: CalculatedAvailabilitySlotSelectSchema.optional(),
      include: CalculatedAvailabilitySlotIncludeSchema.optional(),
      data: z.union([
        CalculatedAvailabilitySlotUpdateInputSchema,
        CalculatedAvailabilitySlotUncheckedUpdateInputSchema,
      ]),
      where: CalculatedAvailabilitySlotWhereUniqueInputSchema,
    })
    .strict();

export const CalculatedAvailabilitySlotUpdateManyArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CalculatedAvailabilitySlotUpdateManyMutationInputSchema,
        CalculatedAvailabilitySlotUncheckedUpdateManyInputSchema,
      ]),
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
    })
    .strict();

export const CalculatedAvailabilitySlotDeleteManyArgsSchema: z.ZodType<Prisma.CalculatedAvailabilitySlotDeleteManyArgs> =
  z
    .object({
      where: CalculatedAvailabilitySlotWhereInputSchema.optional(),
    })
    .strict();

export const BookingCreateArgsSchema: z.ZodType<Prisma.BookingCreateArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    data: z.union([BookingCreateInputSchema, BookingUncheckedCreateInputSchema]),
  })
  .strict();

export const BookingUpsertArgsSchema: z.ZodType<Prisma.BookingUpsertArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereUniqueInputSchema,
    create: z.union([BookingCreateInputSchema, BookingUncheckedCreateInputSchema]),
    update: z.union([BookingUpdateInputSchema, BookingUncheckedUpdateInputSchema]),
  })
  .strict();

export const BookingCreateManyArgsSchema: z.ZodType<Prisma.BookingCreateManyArgs> = z
  .object({
    data: z.union([BookingCreateManyInputSchema, BookingCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const BookingCreateManyAndReturnArgsSchema: z.ZodType<Prisma.BookingCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([BookingCreateManyInputSchema, BookingCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const BookingDeleteArgsSchema: z.ZodType<Prisma.BookingDeleteArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    where: BookingWhereUniqueInputSchema,
  })
  .strict();

export const BookingUpdateArgsSchema: z.ZodType<Prisma.BookingUpdateArgs> = z
  .object({
    select: BookingSelectSchema.optional(),
    include: BookingIncludeSchema.optional(),
    data: z.union([BookingUpdateInputSchema, BookingUncheckedUpdateInputSchema]),
    where: BookingWhereUniqueInputSchema,
  })
  .strict();

export const BookingUpdateManyArgsSchema: z.ZodType<Prisma.BookingUpdateManyArgs> = z
  .object({
    data: z.union([BookingUpdateManyMutationInputSchema, BookingUncheckedUpdateManyInputSchema]),
    where: BookingWhereInputSchema.optional(),
  })
  .strict();

export const BookingDeleteManyArgsSchema: z.ZodType<Prisma.BookingDeleteManyArgs> = z
  .object({
    where: BookingWhereInputSchema.optional(),
  })
  .strict();

export const CommunicationPreferenceCreateArgsSchema: z.ZodType<Prisma.CommunicationPreferenceCreateArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      data: z.union([
        CommunicationPreferenceCreateInputSchema,
        CommunicationPreferenceUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const CommunicationPreferenceUpsertArgsSchema: z.ZodType<Prisma.CommunicationPreferenceUpsertArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereUniqueInputSchema,
      create: z.union([
        CommunicationPreferenceCreateInputSchema,
        CommunicationPreferenceUncheckedCreateInputSchema,
      ]),
      update: z.union([
        CommunicationPreferenceUpdateInputSchema,
        CommunicationPreferenceUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const CommunicationPreferenceCreateManyArgsSchema: z.ZodType<Prisma.CommunicationPreferenceCreateManyArgs> =
  z
    .object({
      data: z.union([
        CommunicationPreferenceCreateManyInputSchema,
        CommunicationPreferenceCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CommunicationPreferenceCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CommunicationPreferenceCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CommunicationPreferenceCreateManyInputSchema,
        CommunicationPreferenceCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CommunicationPreferenceDeleteArgsSchema: z.ZodType<Prisma.CommunicationPreferenceDeleteArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      where: CommunicationPreferenceWhereUniqueInputSchema,
    })
    .strict();

export const CommunicationPreferenceUpdateArgsSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateArgs> =
  z
    .object({
      select: CommunicationPreferenceSelectSchema.optional(),
      include: CommunicationPreferenceIncludeSchema.optional(),
      data: z.union([
        CommunicationPreferenceUpdateInputSchema,
        CommunicationPreferenceUncheckedUpdateInputSchema,
      ]),
      where: CommunicationPreferenceWhereUniqueInputSchema,
    })
    .strict();

export const CommunicationPreferenceUpdateManyArgsSchema: z.ZodType<Prisma.CommunicationPreferenceUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CommunicationPreferenceUpdateManyMutationInputSchema,
        CommunicationPreferenceUncheckedUpdateManyInputSchema,
      ]),
      where: CommunicationPreferenceWhereInputSchema.optional(),
    })
    .strict();

export const CommunicationPreferenceDeleteManyArgsSchema: z.ZodType<Prisma.CommunicationPreferenceDeleteManyArgs> =
  z
    .object({
      where: CommunicationPreferenceWhereInputSchema.optional(),
    })
    .strict();

export const CommunicationLogCreateArgsSchema: z.ZodType<Prisma.CommunicationLogCreateArgs> = z
  .object({
    select: CommunicationLogSelectSchema.optional(),
    include: CommunicationLogIncludeSchema.optional(),
    data: z.union([CommunicationLogCreateInputSchema, CommunicationLogUncheckedCreateInputSchema]),
  })
  .strict();

export const CommunicationLogUpsertArgsSchema: z.ZodType<Prisma.CommunicationLogUpsertArgs> = z
  .object({
    select: CommunicationLogSelectSchema.optional(),
    include: CommunicationLogIncludeSchema.optional(),
    where: CommunicationLogWhereUniqueInputSchema,
    create: z.union([
      CommunicationLogCreateInputSchema,
      CommunicationLogUncheckedCreateInputSchema,
    ]),
    update: z.union([
      CommunicationLogUpdateInputSchema,
      CommunicationLogUncheckedUpdateInputSchema,
    ]),
  })
  .strict();

export const CommunicationLogCreateManyArgsSchema: z.ZodType<Prisma.CommunicationLogCreateManyArgs> =
  z
    .object({
      data: z.union([
        CommunicationLogCreateManyInputSchema,
        CommunicationLogCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CommunicationLogCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CommunicationLogCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CommunicationLogCreateManyInputSchema,
        CommunicationLogCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CommunicationLogDeleteArgsSchema: z.ZodType<Prisma.CommunicationLogDeleteArgs> = z
  .object({
    select: CommunicationLogSelectSchema.optional(),
    include: CommunicationLogIncludeSchema.optional(),
    where: CommunicationLogWhereUniqueInputSchema,
  })
  .strict();

export const CommunicationLogUpdateArgsSchema: z.ZodType<Prisma.CommunicationLogUpdateArgs> = z
  .object({
    select: CommunicationLogSelectSchema.optional(),
    include: CommunicationLogIncludeSchema.optional(),
    data: z.union([CommunicationLogUpdateInputSchema, CommunicationLogUncheckedUpdateInputSchema]),
    where: CommunicationLogWhereUniqueInputSchema,
  })
  .strict();

export const CommunicationLogUpdateManyArgsSchema: z.ZodType<Prisma.CommunicationLogUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CommunicationLogUpdateManyMutationInputSchema,
        CommunicationLogUncheckedUpdateManyInputSchema,
      ]),
      where: CommunicationLogWhereInputSchema.optional(),
    })
    .strict();

export const CommunicationLogDeleteManyArgsSchema: z.ZodType<Prisma.CommunicationLogDeleteManyArgs> =
  z
    .object({
      where: CommunicationLogWhereInputSchema.optional(),
    })
    .strict();

export const CalendarIntegrationCreateArgsSchema: z.ZodType<Prisma.CalendarIntegrationCreateArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      data: z.union([
        CalendarIntegrationCreateInputSchema,
        CalendarIntegrationUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const CalendarIntegrationUpsertArgsSchema: z.ZodType<Prisma.CalendarIntegrationUpsertArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereUniqueInputSchema,
      create: z.union([
        CalendarIntegrationCreateInputSchema,
        CalendarIntegrationUncheckedCreateInputSchema,
      ]),
      update: z.union([
        CalendarIntegrationUpdateInputSchema,
        CalendarIntegrationUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const CalendarIntegrationCreateManyArgsSchema: z.ZodType<Prisma.CalendarIntegrationCreateManyArgs> =
  z
    .object({
      data: z.union([
        CalendarIntegrationCreateManyInputSchema,
        CalendarIntegrationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarIntegrationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CalendarIntegrationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CalendarIntegrationCreateManyInputSchema,
        CalendarIntegrationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarIntegrationDeleteArgsSchema: z.ZodType<Prisma.CalendarIntegrationDeleteArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      where: CalendarIntegrationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarIntegrationUpdateArgsSchema: z.ZodType<Prisma.CalendarIntegrationUpdateArgs> =
  z
    .object({
      select: CalendarIntegrationSelectSchema.optional(),
      include: CalendarIntegrationIncludeSchema.optional(),
      data: z.union([
        CalendarIntegrationUpdateInputSchema,
        CalendarIntegrationUncheckedUpdateInputSchema,
      ]),
      where: CalendarIntegrationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarIntegrationUpdateManyArgsSchema: z.ZodType<Prisma.CalendarIntegrationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CalendarIntegrationUpdateManyMutationInputSchema,
        CalendarIntegrationUncheckedUpdateManyInputSchema,
      ]),
      where: CalendarIntegrationWhereInputSchema.optional(),
    })
    .strict();

export const CalendarIntegrationDeleteManyArgsSchema: z.ZodType<Prisma.CalendarIntegrationDeleteManyArgs> =
  z
    .object({
      where: CalendarIntegrationWhereInputSchema.optional(),
    })
    .strict();

export const CalendarEventCreateArgsSchema: z.ZodType<Prisma.CalendarEventCreateArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    data: z.union([CalendarEventCreateInputSchema, CalendarEventUncheckedCreateInputSchema]),
  })
  .strict();

export const CalendarEventUpsertArgsSchema: z.ZodType<Prisma.CalendarEventUpsertArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    where: CalendarEventWhereUniqueInputSchema,
    create: z.union([CalendarEventCreateInputSchema, CalendarEventUncheckedCreateInputSchema]),
    update: z.union([CalendarEventUpdateInputSchema, CalendarEventUncheckedUpdateInputSchema]),
  })
  .strict();

export const CalendarEventCreateManyArgsSchema: z.ZodType<Prisma.CalendarEventCreateManyArgs> = z
  .object({
    data: z.union([CalendarEventCreateManyInputSchema, CalendarEventCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const CalendarEventCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CalendarEventCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CalendarEventCreateManyInputSchema,
        CalendarEventCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarEventDeleteArgsSchema: z.ZodType<Prisma.CalendarEventDeleteArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    where: CalendarEventWhereUniqueInputSchema,
  })
  .strict();

export const CalendarEventUpdateArgsSchema: z.ZodType<Prisma.CalendarEventUpdateArgs> = z
  .object({
    select: CalendarEventSelectSchema.optional(),
    include: CalendarEventIncludeSchema.optional(),
    data: z.union([CalendarEventUpdateInputSchema, CalendarEventUncheckedUpdateInputSchema]),
    where: CalendarEventWhereUniqueInputSchema,
  })
  .strict();

export const CalendarEventUpdateManyArgsSchema: z.ZodType<Prisma.CalendarEventUpdateManyArgs> = z
  .object({
    data: z.union([
      CalendarEventUpdateManyMutationInputSchema,
      CalendarEventUncheckedUpdateManyInputSchema,
    ]),
    where: CalendarEventWhereInputSchema.optional(),
  })
  .strict();

export const CalendarEventDeleteManyArgsSchema: z.ZodType<Prisma.CalendarEventDeleteManyArgs> = z
  .object({
    where: CalendarEventWhereInputSchema.optional(),
  })
  .strict();

export const CalendarSyncOperationCreateArgsSchema: z.ZodType<Prisma.CalendarSyncOperationCreateArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      data: z.union([
        CalendarSyncOperationCreateInputSchema,
        CalendarSyncOperationUncheckedCreateInputSchema,
      ]),
    })
    .strict();

export const CalendarSyncOperationUpsertArgsSchema: z.ZodType<Prisma.CalendarSyncOperationUpsertArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereUniqueInputSchema,
      create: z.union([
        CalendarSyncOperationCreateInputSchema,
        CalendarSyncOperationUncheckedCreateInputSchema,
      ]),
      update: z.union([
        CalendarSyncOperationUpdateInputSchema,
        CalendarSyncOperationUncheckedUpdateInputSchema,
      ]),
    })
    .strict();

export const CalendarSyncOperationCreateManyArgsSchema: z.ZodType<Prisma.CalendarSyncOperationCreateManyArgs> =
  z
    .object({
      data: z.union([
        CalendarSyncOperationCreateManyInputSchema,
        CalendarSyncOperationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarSyncOperationCreateManyAndReturnArgsSchema: z.ZodType<Prisma.CalendarSyncOperationCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([
        CalendarSyncOperationCreateManyInputSchema,
        CalendarSyncOperationCreateManyInputSchema.array(),
      ]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const CalendarSyncOperationDeleteArgsSchema: z.ZodType<Prisma.CalendarSyncOperationDeleteArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      where: CalendarSyncOperationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarSyncOperationUpdateArgsSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateArgs> =
  z
    .object({
      select: CalendarSyncOperationSelectSchema.optional(),
      include: CalendarSyncOperationIncludeSchema.optional(),
      data: z.union([
        CalendarSyncOperationUpdateInputSchema,
        CalendarSyncOperationUncheckedUpdateInputSchema,
      ]),
      where: CalendarSyncOperationWhereUniqueInputSchema,
    })
    .strict();

export const CalendarSyncOperationUpdateManyArgsSchema: z.ZodType<Prisma.CalendarSyncOperationUpdateManyArgs> =
  z
    .object({
      data: z.union([
        CalendarSyncOperationUpdateManyMutationInputSchema,
        CalendarSyncOperationUncheckedUpdateManyInputSchema,
      ]),
      where: CalendarSyncOperationWhereInputSchema.optional(),
    })
    .strict();

export const CalendarSyncOperationDeleteManyArgsSchema: z.ZodType<Prisma.CalendarSyncOperationDeleteManyArgs> =
  z
    .object({
      where: CalendarSyncOperationWhereInputSchema.optional(),
    })
    .strict();

export const MeetSessionCreateArgsSchema: z.ZodType<Prisma.MeetSessionCreateArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    data: z.union([MeetSessionCreateInputSchema, MeetSessionUncheckedCreateInputSchema]),
  })
  .strict();

export const MeetSessionUpsertArgsSchema: z.ZodType<Prisma.MeetSessionUpsertArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    where: MeetSessionWhereUniqueInputSchema,
    create: z.union([MeetSessionCreateInputSchema, MeetSessionUncheckedCreateInputSchema]),
    update: z.union([MeetSessionUpdateInputSchema, MeetSessionUncheckedUpdateInputSchema]),
  })
  .strict();

export const MeetSessionCreateManyArgsSchema: z.ZodType<Prisma.MeetSessionCreateManyArgs> = z
  .object({
    data: z.union([MeetSessionCreateManyInputSchema, MeetSessionCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const MeetSessionCreateManyAndReturnArgsSchema: z.ZodType<Prisma.MeetSessionCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([MeetSessionCreateManyInputSchema, MeetSessionCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const MeetSessionDeleteArgsSchema: z.ZodType<Prisma.MeetSessionDeleteArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    where: MeetSessionWhereUniqueInputSchema,
  })
  .strict();

export const MeetSessionUpdateArgsSchema: z.ZodType<Prisma.MeetSessionUpdateArgs> = z
  .object({
    select: MeetSessionSelectSchema.optional(),
    include: MeetSessionIncludeSchema.optional(),
    data: z.union([MeetSessionUpdateInputSchema, MeetSessionUncheckedUpdateInputSchema]),
    where: MeetSessionWhereUniqueInputSchema,
  })
  .strict();

export const MeetSessionUpdateManyArgsSchema: z.ZodType<Prisma.MeetSessionUpdateManyArgs> = z
  .object({
    data: z.union([
      MeetSessionUpdateManyMutationInputSchema,
      MeetSessionUncheckedUpdateManyInputSchema,
    ]),
    where: MeetSessionWhereInputSchema.optional(),
  })
  .strict();

export const MeetSessionDeleteManyArgsSchema: z.ZodType<Prisma.MeetSessionDeleteManyArgs> = z
  .object({
    where: MeetSessionWhereInputSchema.optional(),
  })
  .strict();

export const ReviewCreateArgsSchema: z.ZodType<Prisma.ReviewCreateArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    data: z.union([ReviewCreateInputSchema, ReviewUncheckedCreateInputSchema]),
  })
  .strict();

export const ReviewUpsertArgsSchema: z.ZodType<Prisma.ReviewUpsertArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereUniqueInputSchema,
    create: z.union([ReviewCreateInputSchema, ReviewUncheckedCreateInputSchema]),
    update: z.union([ReviewUpdateInputSchema, ReviewUncheckedUpdateInputSchema]),
  })
  .strict();

export const ReviewCreateManyArgsSchema: z.ZodType<Prisma.ReviewCreateManyArgs> = z
  .object({
    data: z.union([ReviewCreateManyInputSchema, ReviewCreateManyInputSchema.array()]),
    skipDuplicates: z.boolean().optional(),
  })
  .strict();

export const ReviewCreateManyAndReturnArgsSchema: z.ZodType<Prisma.ReviewCreateManyAndReturnArgs> =
  z
    .object({
      data: z.union([ReviewCreateManyInputSchema, ReviewCreateManyInputSchema.array()]),
      skipDuplicates: z.boolean().optional(),
    })
    .strict();

export const ReviewDeleteArgsSchema: z.ZodType<Prisma.ReviewDeleteArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    where: ReviewWhereUniqueInputSchema,
  })
  .strict();

export const ReviewUpdateArgsSchema: z.ZodType<Prisma.ReviewUpdateArgs> = z
  .object({
    select: ReviewSelectSchema.optional(),
    include: ReviewIncludeSchema.optional(),
    data: z.union([ReviewUpdateInputSchema, ReviewUncheckedUpdateInputSchema]),
    where: ReviewWhereUniqueInputSchema,
  })
  .strict();

export const ReviewUpdateManyArgsSchema: z.ZodType<Prisma.ReviewUpdateManyArgs> = z
  .object({
    data: z.union([ReviewUpdateManyMutationInputSchema, ReviewUncheckedUpdateManyInputSchema]),
    where: ReviewWhereInputSchema.optional(),
  })
  .strict();

export const ReviewDeleteManyArgsSchema: z.ZodType<Prisma.ReviewDeleteManyArgs> = z
  .object({
    where: ReviewWhereInputSchema.optional(),
  })
  .strict();
