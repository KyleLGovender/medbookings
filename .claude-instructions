# Claude Code Instructions for MedBookings Platform

## üî¥ CRITICAL RULES - ALWAYS ENFORCE

### 1. FUNDAMENTAL PRINCIPLES
- **MAXIMUM COGNITIVE EFFORT**: Think hardest - use full analytical capacity
- **95% CONFIDENCE RULE**: Ask questions when confidence < 95%
- **VERIFY EVERYTHING**: Never skip because it "looks fine" - check EVERYTHING
- **NO ASSUMPTIONS**: Don't trust comments saying "this works" - test EVERYTHING
- **PREFER EDITING**: Always edit existing code over creating new
- **EXPLICIT CONFIRMATION**: Require user satisfaction before marking complete

### 2. NEVER VIOLATE
- Add legacy fallback code (unless explicitly requested)
- Implement when uncertain - clarify first
- Create new code when existing code can be modified
- Mark tasks complete without user satisfaction confirmation
- Skip security for speed
- Assume previous implementation is secure
- Trust without verification
- Deploy without complete testing

### 3. FILE OPERATIONS
**ALWAYS:**
- Check if file exists before writing
- Offer Overwrite/Rename/Cancel options for conflicts
- Get explicit user approval for overwrites
- Double-check response accuracy against raw command output

**NEVER:**
- Silently overwrite files without user confirmation
- Assume file does, or does not exist - check first
- Delete or move files without user consent

### 4. BUILD & QUALITY GATES
```bash
# MANDATORY BEFORE MARKING COMPLETE
npx tsc --noEmit              # TypeScript validation
npm run lint                   # Linting check
npm run build                  # Build verification
npm run test                   # Test execution
grep -n "console.log" src/    # Security check for logs
```

**ALWAYS:**
- Fix ALL compilation errors (even in other files)
- Run syntax validation after each modification
- Use `grep -n` or `rg` to find all instances of modified functions
- Review adjacent files that import modified modules
- Ensure each code block compiles before proceeding

**NEVER:**
- Mark tasks complete with failing builds
- Use trial-and-error to fix compilation errors
- Proceed to next phase with build failures

## üìÅ FILE HIERARCHY & PROTECTION

### CRITICAL FILES (NEVER MODIFY WITHOUT EXPLICIT PERMISSION)
```
prisma/schema.prisma          # Database schema - additive only
src/server/trpc.ts           # tRPC configuration
src/lib/auth.ts              # Authentication core
src/lib/prisma.ts            # Database client
src/utils/api.ts             # API utilities
src/config/env/server.ts     # Environment validation
src/types/next-auth.d.ts     # Auth types
.env                         # Environment variables (NEVER COMMIT)
src/lib/cache.ts             # Caching patterns - affects data flow
src/lib/utils.ts             # Shared utilities - can introduce anti-patterns
```

### HIGH-RISK FILES (REQUIRE CAREFUL REVIEW)
```
src/middleware.ts            # Route protection
src/server/api/root.ts       # API root
src/server/api/routers/*     # API endpoints
src/app/layout.tsx           # App shell
src/app/api/auth/*           # Auth routes
src/app/api/trpc/*           # tRPC routes
src/components/providers.tsx # App providers
src/lib/permissions/*        # Permission systems
src/lib/communications/*     # Notification systems
src/hooks/use-permissions.ts # Permission hooks
src/hooks/*                  # Global hooks - can break feature isolation
src/components/*             # Shared components - risk of tight coupling
src/components/ui/*          # UI library - changes affect all features
src/components/layout/*      # Layout components - app structure
src/app/globals.css          # Global styles - affects all features
tailwind.config.ts           # Tailwind config - design system changes
next.config.*               # Next.js config
package.json                # Dependencies
```

### MODERATE FILES (STANDARD CAUTION)
```
tsconfig.json               # TypeScript config
package-lock.json          # Lock file
playwright.config.ts       # Test config
.github/workflows/*        # CI/CD
scripts/*                  # Build scripts
src/features/*/types/*     # Feature types
src/features/*/lib/actions.ts # Server actions
src/lib/constants.ts        # App constants - business logic leakage risk
src/lib/helper.ts           # Generic helpers - feature logic risk
src/lib/server-helper.ts    # Server utilities - API patterns
src/lib/timezone-helper.ts  # Timezone handling - data consistency
src/lib/subscription-utils.ts # Subscription logic - billing patterns
```

## üîÑ WORKFLOW SEQUENCE

### MANDATORY ORDER
```
1. Technical Planning ‚Üí 2. Requirements ‚Üí 3. Implementation ‚Üí 4. Verification
     ‚Üë START HERE           ‚Üë Get approval    ‚Üë Build & test    ‚Üë User confirms
```

**NEVER:**
- Jump ahead in the workflow sequence
- Start implementation without approved technical plan

### CONTEXT LOADING SEQUENCE
```
1. Read core files (layout.tsx, schema.prisma, root.ts)
2. Read entire feature folder before modifications
3. Understand existing patterns from similar features
4. Check for existing implementations
5. Verify all imports and dependencies
```

### CONTEXT AWARENESS
**ALWAYS:**
- Read core architecture files first (layout.tsx, schema.prisma, root.ts)
- Read entire feature folders before modifications
- Understand existing patterns before implementing
- Double-check what you include in your response to the user against the actual raw command output

**NEVER:**
- Modify files without reading them completely first
- Assume patterns without checking existing implementations
- Make partial edits without checking FULL file scope
- Assume variable names without verifying declarations
- Modify interfaces without checking all implementations
- Skip context loading even if familiar with codebase

## üèóÔ∏è ARCHITECTURE PATTERNS

### DATABASE OPERATIONS
```typescript
// ALWAYS use transactions for multi-table operations
await prisma.$transaction(async (tx) => {
  // Atomic operations only
}, {
  maxWait: 10000,  // Max wait time
  timeout: 20000   // Transaction timeout
});
```

### PRISMA SCHEMA MODIFICATIONS
- **Additive Only**: New models/fields added, never removed (require explicit approval for removal)
- **Relation Integrity**: Follow naming patterns (userId, providerId)
- **Enum Extensions**: Add values to existing enums, never remove or rename

### DATABASE EVOLUTION RULES
**When modifying schema:**
1. Check master's version first: `git show master:prisma/schema.prisma`
2. Only add new fields/models, never remove without explicit approval
3. New relations must follow existing naming patterns
4. Enum values can be added but never removed/renamed
5. Major changes require full regression test

### API PATTERN (tRPC)
```typescript
// REQUIRED STRUCTURE - NEVER DEVIATE
export const featureRouter = createTRPCRouter({
  procedureName: protectedProcedure  // or publicProcedure
    .input(z.object({...}))          // Zod validation REQUIRED
    .query(async ({ ctx, input }) => {
      // 1. Authorization check first
      // 2. Business logic
      // 3. Error handling
    }),
});
```

**API DEVELOPMENT STANDARDS:**
- **NEVER** create REST endpoints when tRPC procedure would suffice
- **NEVER** bypass Zod validation for "simple" endpoints
- **NEVER** mix authentication strategies (stick to existing NextAuth)

### TYPE SAFETY CHAIN
```
Database ‚Üí Prisma Types ‚Üí Zod Schemas ‚Üí tRPC Types ‚Üí Component Props
         ‚Üë Never break this chain
```

### COMPONENT ARCHITECTURE
- Server Components by default, Client Components only when needed
- Data fetching via tRPC hooks (api.feature.procedure.useQuery)
- Form handling with react-hook-form + zodResolver
- Error boundaries around data-dependent sections

### FEATURE-BASED STRUCTURE
```
/app/[feature-name]/
‚îú‚îÄ‚îÄ components/    # Feature UI
‚îú‚îÄ‚îÄ hooks/        # Feature hooks
‚îú‚îÄ‚îÄ utils/        # Feature utilities
‚îú‚îÄ‚îÄ actions/      # Server actions
‚îî‚îÄ‚îÄ types/        # Feature types
```

Each feature owns its complete vertical slice - no cross-feature imports except shared libs.

### ARCHITECTURAL INTEGRITY RULES

**CROSS-FEATURE IMPORTS (FORBIDDEN):**
```typescript
// ‚ùå NEVER import from other features
import { something } from '@/features/otherFeature'

// ‚úÖ ONLY allowed shared imports
import { ui } from '@/components/ui'
import { utils } from '@/lib'
import { api } from '@/utils/api'
```

**GLOBAL STATE PATTERNS (MONITOR):**
- NO Redux/Zustand/Context in features
- State MUST live in tRPC/React Query
- Global providers only for app-wide concerns (theme, auth)

**SHARED COMPONENT RULES:**
- `/src/components/` = truly generic components only
- Feature-specific components MUST stay in `/features/[feature]/components/`
- No business logic in shared components

**BUSINESS LOGIC BOUNDARIES:**
- NO business logic in `/src/lib/*`
- NO feature-specific logic in shared components
- Domain logic MUST stay in features
- Database access ONLY through tRPC procedures

**DATABASE ACCESS PATTERNS:**
```typescript
// ‚ùå FORBIDDEN in components/features
import { prisma } from '@/lib/prisma'

// ‚úÖ ONLY in tRPC procedures
// src/server/api/routers/[feature].ts
import { prisma } from '@/lib/prisma'
```

## üîç VERIFICATION PROTOCOLS

### ROUTE & NAVIGATION VALIDATION
```bash
# Find all valid routes
find app -type f -name "page.tsx" | sed 's/page.tsx//' | sort

# Verify ALL href targets exist
grep -r "href=\|navigate\|push(" --include="*.tsx" | grep -v "^//" | sort -u

# Check route definitions
grep -r "path.*${route_path}" --include="*.ts" --include="*.tsx"

# Verify middleware coverage
cat src/middleware.ts | grep "matcher:"

# Identify duplicate route handlers
find app -name "*.tsx" -exec grep -l "availability\|calendar" {} \; | sort
```

**ALWAYS:**
- Verify ALL href/navigation targets exist
- Check route definitions in app directory, API routes, middleware.ts
- Trace navigation flow: source ‚Üí middleware ‚Üí destination
- Identify duplicate route handlers (e.g., /calendar/availability vs /availability)
- Run: `find app -type f -name "page.tsx" | sed 's/page.tsx//' | sort` to list all valid routes

**NEVER:**
- Assume a route exists based on href usage
- Create navigation links without verifying destination exists
- Ignore route middleware or guards

### DATA SOURCE VERIFICATION
```bash
# Find mock/hardcoded data
grep -r "Mock\|TODO\|hardcoded\|placeholder\|9-11 AM\|30 min" --include="*.tsx"

# Verify API endpoint existence
grep -r "router.*${endpoint_name}" server/

# Check for console.log (security risk)
grep -r "console\.(log|error|warn)" --include="*.ts*" | grep -v "// eslint-ignore"

# Find type safety issues
grep -r "any\|as any" --include="*.ts*"
```

**ALWAYS:**
- Trace data origin: API, database, or hardcoded?
- Flag ALL hardcoded/mock data with: `// TODO: Mock data - replace with API`
- Verify API endpoint existence
- Check for data inconsistencies between similar components
- Identify static vs dynamic content explicitly

**NEVER:**
- Accept hardcoded values without questioning source
- Assume data is real without tracing to database query
- Mix mock and real data without clear separation

### PERFORMANCE & API MONITORING
```bash
# Find N+1 queries
grep -r "findMany.*include" --include="*.ts" -A 5

# Check for missing pagination
grep -r "findMany" --include="*.ts" | grep -v "take:"

# Find polling patterns
grep -r "useQuery.*{" -A 5 | grep -E "(refetch|poll|interval)"

# Check useEffect cleanup
grep -r "useEffect" -A 10 --include="*.tsx" | grep -E "interval|timeout" | grep -v "return.*clear"

# Find missing indexes
grep -r "where.*{" prisma/ -A 3
```

**ALWAYS:**
- Check React Query settings: `refetchInterval`, `refetchOnWindowFocus`, `staleTime`
- Search for polling patterns
- Identify duplicate API calls in console logs
- Check for missing debounce/throttle on frequent operations
- Verify proper cleanup: `useEffect` return statements, query cancellation

**NEVER:**
- Ignore repeated API calls in terminal output
- Implement queries without considering cache strategy
- Add polling without explicit requirement

### FLASH/LOADING STATE ANALYSIS
**ALWAYS:**
- Check for race conditions between similar pages
- Verify loading states: `grep -r "isLoading\|isPending" ${file}`
- Identify authentication/permission checks causing redirects
- Test navigation between related pages (availability ‚Üí calendar ‚Üí manage)
- Look for duplicate permission checks across route transitions

**NEVER:**
- Ignore brief UI flashes as "normal" behavior
- Assume loading states are properly handled without verification

## üö® SECURITY CHECKLIST

### AUTHENTICATION & AUTHORIZATION
- [ ] ALL routes have authentication checks
- [ ] ALL API endpoints have proper authorization
- [ ] Role-based access control enforced
- [ ] Session timeout configured (30 min for medical data)
- [ ] CSRF protection implemented
- [ ] Rate limiting on auth endpoints
- [ ] OAuth implementations secure
- [ ] No authentication bypass possibilities

### INPUT VALIDATION & SANITIZATION
- [ ] ALL user inputs sanitized (XSS prevention)
- [ ] EVERY database field has validation
- [ ] File upload size/type restrictions
- [ ] All request parameters against Zod schemas
- [ ] No SQL injection vectors (even with Prisma raw queries)
- [ ] Webhook authentication implemented

### DATA PROTECTION
- [ ] NO credentials in code
- [ ] NO sensitive data in console.logs
- [ ] NO PHI data in error messages
- [ ] Sensitive data encrypted at rest
- [ ] CSRF tokens implemented
- [ ] Audit logging for PHI data access
- [ ] External API calls use secure methods

## üè• HEALTHCARE COMPLIANCE (MEDBOOKINGS SPECIFIC)

### POPIA REQUIREMENTS
- [ ] Audit trail for all PHI access
- [ ] Consent tracking mechanism
- [ ] Encryption for PHI fields
- [ ] Session timeout enforcement

### PROVIDER AUTHENTICATION FLOW
- [ ] Provider verification flow complete
- [ ] All provider routes have role verification
- [ ] Provider approval workflow intact
- [ ] Check for PHI data exposure in console logs
- [ ] Validate appointment booking state machines

### APPOINTMENT BOOKING
- [ ] No double-booking possibilities
- [ ] State machine validated
- [ ] Calendar/availability sync across all views
- [ ] Timezone handling (UTC in database)
- [ ] Ensure calendar/availability sync across all views

### BOOKING INTEGRITY
```typescript
// PREVENT DOUBLE-BOOKING - REQUIRED PATTERN
const slot = await tx.calculatedAvailabilitySlot.findUnique({
  where: { id: slotId },
  // Use SELECT FOR UPDATE or optimistic locking
});

if (slot.booking || slot.status !== 'AVAILABLE') {
  throw new Error('Slot unavailable');
}
```

### MEDBOOKINGS SPECIFIC RULES
**ALWAYS:**
- Verify provider authentication flow completeness
- Check for PHI data exposure in console logs
- Validate appointment booking state machines
- Ensure calendar/availability sync across all views

**NEVER:**
- Display mock healthcare data in production builds
- Create provider routes without role verification
- Implement calendar features without timezone handling

## ‚úÖ DATA INTEGRITY VERIFICATION

### DATABASE CONSISTENCY
- [ ] No race conditions in appointment booking
- [ ] Transactions for atomic operations
- [ ] No double-booking possibilities
- [ ] Foreign key constraints present
- [ ] Cascade deletes configured
- [ ] Timezone handling (UTC in DB)
- [ ] Optimistic locking where needed
- [ ] Idempotent critical operations
- [ ] No orphaned records possibilities
- [ ] Data consistency between related tables
- [ ] Missing cascade deletes that could leave orphan records

## üêõ BUG DETECTION PATTERNS

### REACT ISSUES
```typescript
// Memory Leak Pattern - DETECT & FIX
useEffect(() => {
  const timer = setInterval(...);
  // MISSING: return () => clearInterval(timer);
}, []);

// Infinite Loop Pattern - PREVENT
useEffect(() => {
  setState(value);  // Causes re-render
}, [value]);  // Dependency causes loop

// Stale Closure - AVOID
const [count, setCount] = useState(0);
useEffect(() => {
  setTimeout(() => console.log(count), 1000); // Stale count
}, []);

// Missing Error Boundaries
// Unhandled promise rejections in components
```

### DATABASE ISSUES
```typescript
// N+1 Problem - NEVER ALLOW
const users = await prisma.user.findMany();
for (const user of users) {
  const posts = await prisma.post.findMany({  // BAD: N queries
    where: { userId: user.id }
  });
}

// Race Condition - ALWAYS USE TRANSACTIONS
// BAD: No transaction or locking
const slot = await prisma.slot.findUnique(...);
if (slot.available) {
  await prisma.booking.create(...);
}
```

## üéØ ISSUE DETECTION & DEBUGGING

### ISSUE DETECTION CHECKLIST
```bash
# Find all routes and verify they exist
grep -r "href=\|navigate\|push(" --include="*.tsx" | grep -v "^//" | sort -u

# Find mock/hardcoded data
grep -r "Mock\|TODO\|hardcoded\|placeholder\|9-11 AM\|30 min" --include="*.tsx"

# Check for deleted routes still referenced
git log --diff-filter=D --summary | grep "delete mode" | grep -E "(page|route)"

# Find potential infinite loops/excessive polling
grep -r "useEffect\|useQuery" -A 10 --include="*.tsx" | grep -E "interval|timeout|refetch"

# Security scan
grep -r "console.log\|console.error" --include="*.tsx" --include="*.ts" | grep -v "// eslint-ignore"
grep -r "any\|as any" --include="*.ts" --include="*.tsx"
grep -r "TODO\|FIXME\|HACK\|XXX" --include="*.tsx" --include="*.ts"

# Check for route guards/middleware
cat middleware.ts 2>/dev/null || echo "No middleware found"
```

### DEBUGGING PROTOCOL (USER REPORTS ISSUE)
1. **REPRODUCE**: Follow exact user click path
2. **TRACE**: Follow complete data and navigation flow
3. **VERIFY**: Check if routes/APIs actually exist
4. **IDENTIFY**: Distinguish between mock and real data
5. **MONITOR**: Watch terminal for unusual patterns
6. **REPORT**: List all findings with specific file:line numbers

### RED FLAGS - REPORT IMMEDIATELY
üî¥ **CRITICAL**:
- Authentication bypass, SQL injection, exposed credentials
- Hardcoded values like "9-11 AM", "30 min", "5%"
- PHI data in console logs
- Navigation to paths containing /providers/[id]/ without route verification

üü† **HIGH**:
- Race conditions, infinite loops, PHI in logs
- Multiple similar pages with slight variations (availability vs calendar/availability)
- API calls firing continuously in terminal
- Flash content before redirects
- Missing error boundaries on data-dependent components

üü° **MEDIUM**:
- Missing validation, no error handling, hardcoded data
- Missing error boundaries on data-dependent components

## üìã CRITICAL PATH TESTING

### BEFORE MARKING ANY FEATURE COMPLETE
1. **Route Test**: Click all navigation links and verify destinations
2. **Data Test**: Confirm all displayed data sources (API vs mock)
3. **Performance Test**: Monitor network tab for excessive requests
4. **State Test**: Navigate between related pages checking for flashes
5. **Console Test**: Check for errors, warnings, and excessive logs
6. **Security Test**: Verify authentication/authorization on all operations
7. **Error Test**: Trigger error conditions and verify handling
8. **Edge Case Test**: Test boundary conditions and empty states

## ‚ö° PERFORMANCE REQUIREMENTS

### DATABASE
- [ ] Pagination for lists > 20 items (REQUIRED)
- [ ] No unbounded queries (always use take:)
- [ ] No SELECT * statements
- [ ] No N+1 queries (eager loading used)
- [ ] Indexes on frequently queried columns
- [ ] Transactions for multi-table operations

### FRONTEND
- [ ] No unnecessary re-renders (memo/useMemo/useCallback)
- [ ] Code splitting implemented (route-based mandatory)
- [ ] No synchronous UI blocking operations
- [ ] Images use Next.js Image component (ALL images)
- [ ] Large bundle detection (> 10% regression needs justification)
- [ ] Lazy loading for routes
- [ ] Debounce/throttle for frequent operations
- [ ] Missing lazy loading for below-fold content

### API
- [ ] No API calls in loops
- [ ] Cache GET requests (min 5 seconds REQUIRED)
- [ ] Rate limiting on all endpoints
- [ ] No synchronous external calls in request path
- [ ] Request batching where possible
- [ ] React Query settings optimized

### CORE PERFORMANCE PRINCIPLES (NEVER VIOLATE)
1. **No N+1 Queries**: Every feature must use eager loading
2. **Pagination Required**: Lists > 20 items must paginate
3. **Image Optimization**: All images through Next.js Image
4. **Code Splitting**: Route-based splitting mandatory
5. **Caching Strategy**: All GET requests cached minimum 5 seconds

## üë§ USER EXPERIENCE VERIFICATION

### FORMS
- [ ] Clear submission feedback
- [ ] UI state updates after submission
- [ ] Validation errors display clearly
- [ ] Success messages confirm actions

### NAVIGATION
- [ ] All links navigate correctly
- [ ] Back button works properly
- [ ] Deep linking functions
- [ ] 404 handling implemented

### LOADING STATES
- [ ] Every async operation shows loading state
- [ ] Loading states resolve properly
- [ ] Error states provide actionable information
- [ ] No infinite loading scenarios

### RESPONSIVENESS
- [ ] Mobile layouts work correctly
- [ ] Touch interactions function properly
- [ ] Viewport meta tags configured
- [ ] Critical content above fold
- [ ] Accessibility violations checked

## üöÄ PRODUCTION READINESS

### CODE CLEANLINESS
- [ ] NO console.log statements in production
- [ ] NO development dependencies in build
- [ ] NO commented-out code blocks
- [ ] NO debug flags enabled
- [ ] NO TODO/FIXME in critical paths
- [ ] NO hardcoded/mock data in production code
- [ ] NO placeholder implementations

### DEPLOYMENT SAFETY
```bash
# Security scan
grep -r "console.log\|TODO\|FIXME" src/ && echo "‚ùå Clean up required"

# Type safety
npx tsc --noEmit || echo "‚ùå Type errors exist"

# Build check
npm run build || echo "‚ùå Build failed"

# Route verification
find app -name "page.tsx" | wc -l  # Count routes

# Credential check
grep -r "SECRET\|KEY\|TOKEN" src/ --include="*.ts*" | grep -v ".env"
```

### ENVIRONMENT & CONFIGURATION
- [ ] All environment variables configured
- [ ] No development values in production config
- [ ] Secrets properly managed (not in code)
- [ ] Database connection pooling configured
- [ ] Health check endpoints implemented
- [ ] Database migrations tested and reversible
- [ ] Rollback procedures documented
- [ ] Error tracking configured

## üîÑ BREAKING CHANGE PREVENTION

### BEFORE MERGING TO MASTER
```bash
# Check master's version first
git show master:package.json | grep "[dependency-name]"

# Run compatibility check
npm run test:integration

# Verify migration reversibility
npx prisma migrate diff

# Test provider workflow end-to-end
npm run test:e2e:provider-flow

# Confirm API backward compatibility
# Test provider workflow end-to-end
# Validate no core pattern violations
```

### ARCHITECTURE REVIEW TRIGGERS
- Changes to: src/lib/auth.ts, src/server/trpc.ts, src/lib/prisma.ts
- Changes to: src/app/api/auth/*, src/lib/auth/*
- Prisma schema structural changes (vs additive)
- New authentication/authorization patterns
- Alternative state management (outside tRPC)
- Custom routing logic bypassing Next.js
- Major dependency version changes (require architecture review)
- Bundle size regression > 10% without justification

### DEPENDENCY MANAGEMENT PROTOCOL
```bash
# When updating dependencies:
# Check master's version first
git show master:package.json | grep "[dependency-name]"
# Major version changes require architecture review
# Prisma updates need full regression test
```

## üìù FINAL VERIFICATION CHECKLIST

### TASK COMPLETION CRITERIA
1. **Build Passes**: `npm run build` succeeds
2. **Types Valid**: `npx tsc --noEmit` passes
3. **Lint Clean**: `npm run lint` has no errors
4. **Tests Pass**: Relevant tests execute successfully
5. **Security Check**: No exposed credentials or PHI
6. **Performance**: No N+1 queries or unbounded fetches
7. **User Confirms**: Explicit satisfaction from user

### USER SATISFACTION REQUIRED
- [ ] Feature works as requested
- [ ] No console errors
- [ ] Performance acceptable
- [ ] Security verified
- [ ] Build passes all checks
- [ ] Types compile without errors
- [ ] Lint passes without warnings
- [ ] All tests pass
- [ ] User explicitly confirms completion

---

**REMEMBER**: Think hardest. Verify everything. Never assume. Always confirm.
**NO EXCEPTIONS**: These rules are non-negotiable. User safety and data integrity depend on following them.
