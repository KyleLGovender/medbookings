# Claude Code Instructions

### Core Principles

**ALWAYS:**
- Think hardest - use maximum cognitive effort for technical analysis
- Ask questions when confidence is below 95%
- Prefer editing existing code over creating new
- Require explicit user confirmation before marking any task complete

**NEVER:**
- Add legacy fallback code (unless explicitly requested)
- Implement when uncertain - clarify first
- Create new code when existing code can be modified
- Mark tasks complete without user satisfaction confirmation

### File Operations

**ALWAYS:**
- Check if file exists before writing
- Offer Overwrite/Rename/Cancel options for conflicts
- Get explicit user approval for overwrites

**NEVER:**
- Silently overwrite files without user confirmation
- Assume file doesn't exist - check first
- Delete or move files without user consent

### Build & Quality

**ALWAYS:**
- Run build verification before marking tasks complete
- Fix build errors systematically
- Run syntax validation after each modification
- Use `grep -n` or `rg` to find all instances of modified functions/variables
- Execute `npx tsc --noEmit` after TypeScript changes
- Review adjacent files that import modified modules
- Ensure each code block compiles before proceeding
- Fix all Linting, Build, TypeScript, JSX and Compilation errors observed even if they are in other files and not necessarily in the files you just edited and/or created

**NEVER:**
- Mark tasks complete with failing builds
- Use trial-and-error to fix compilation errors
- Proceed to next phase with build failures

### Workflow Order

**ALWAYS:**
- Start with technical planning as mandatory entry point
- Follow sequence: Technical Plan → Requirements → Implementation
- Complete each phase before moving to next

**NEVER:**
- Jump ahead in the workflow sequence
- Start implementation without approved technical plan

### Context Awareness

**ALWAYS:**
- Read core architecture files first (layout.tsx, schema.prisma, root.ts)
- Read entire feature folders before modifications
- Understand existing patterns before implementing
- Double-check what you include in your response to the user against the actual raw command output to ensure completeness and accuracy of your responses

**NEVER:**
- Modify files without reading them completely first
- Assume patterns without checking existing implementations
- Make partial edits without checking FULL file and function scope
- Assume variable names without verifying declarations
- Modify interfaces without checking all implementations
- Skip context loading even if familiar with codebase

### Route & Navigation Validation

**ALWAYS:**
- Verify ALL href/navigation targets exist: `grep -r "path.*${route_path}" --include="*.ts" --include="*.tsx"`
- Check route definitions in: app directory structure, API routes, middleware.ts
- Trace navigation flow: source → middleware → destination
- Identify duplicate route handlers (e.g., /calendar/availability vs /availability)
- Run: `find app -type f -name "page.tsx" | sed 's/page.tsx//' | sort` to list all valid routes

**NEVER:**
- Assume a route exists based on href usage
- Create navigation links without verifying destination exists
- Ignore route middleware or guards

### Data Source Verification

**ALWAYS:**
- Trace data origin: Is it from API, database, or hardcoded?
- Flag ALL hardcoded/mock data with comment: `// TODO: Mock data - replace with API`
- Verify API endpoint existence: `grep -r "router.*${endpoint_name}" server/`
- Check for data inconsistencies between similar components
- Identify static vs dynamic content explicitly

**NEVER:**
- Accept hardcoded values without questioning source
- Assume data is real without tracing to database query
- Mix mock and real data without clear separation

### Performance & API Monitoring

**ALWAYS:**
- Check React Query settings: `refetchInterval`, `refetchOnWindowFocus`, `staleTime`
- Search for polling patterns: `grep -r "useQuery.*{" -A 5 | grep -E "(refetch|poll|interval)"`
- Identify duplicate API calls in console logs
- Check for missing debounce/throttle on frequent operations
- Verify proper cleanup: `useEffect` return statements, query cancellation

**NEVER:**
- Ignore repeated API calls in terminal output
- Implement queries without considering cache strategy
- Add polling without explicit requirement

### Flash/Loading State Analysis

**ALWAYS:**
- Check for race conditions between similar pages
- Verify loading states: `grep -r "isLoading\|isPending" ${file}`
- Identify authentication/permission checks causing redirects
- Test navigation between related pages (availability → calendar → manage)
- Look for duplicate permission checks across route transitions

**NEVER:**
- Ignore brief UI flashes as "normal" behavior
- Assume loading states are properly handled without verification

### Critical Path Testing

**BEFORE MARKING ANY FEATURE COMPLETE:**
1. **Route Test**: Click all navigation links and verify destinations
2. **Data Test**: Confirm all displayed data sources (API vs mock)
3. **Performance Test**: Monitor network tab for excessive requests
4. **State Test**: Navigate between related pages checking for flashes
5. **Console Test**: Check for errors, warnings, and excessive logs

### Issue Detection Checklist

When analyzing existing code, ALWAYS check:
```bash
# 1. Find all routes and verify they exist
grep -r "href=\|navigate\|push(" --include="*.tsx" | grep -v "^//" | sort -u

# 2. Find mock/hardcoded data
grep -r "Mock\|TODO\|hardcoded\|placeholder\|9-11 AM\|30 min" --include="*.tsx"

# 3. Check for deleted routes still referenced
git log --diff-filter=D --summary | grep "delete mode" | grep -E "(page|route)"

# 4. Find potential infinite loops/excessive polling
grep -r "useEffect\|useQuery" -A 10 --include="*.tsx" | grep -E "interval|timeout|refetch"

# 5. Identify duplicate route handling
find app -name "*.tsx" -exec grep -l "availability\|calendar" {} \; | sort

# 6. Check for route guards/middleware
cat middleware.ts 2>/dev/null || echo "No middleware found"
```

### Red Flags to Always Report

**IMMEDIATELY flag when you see:**
- Hardcoded values that look like sample data e.g. "9-11 AM", "30 min", "5%"
- Navigation to paths containing /providers/[id]/ without route verification
- Multiple similar pages with slight variations (availability vs calendar/availability)
- API calls firing continuously in terminal
- Flash content before redirects
- Missing error boundaries on data-dependent components

### MedBookings Specific Rules

**ALWAYS:**
- Verify provider authentication flow completeness
- Check for PHI data exposure in console logs
- Validate appointment booking state machines
- Ensure calendar/availability sync across all views

**NEVER:**
- Display mock healthcare data in production builds
- Create provider routes without role verification
- Implement calendar features without timezone handling

### Debugging Protocol for Issues

**When user reports an issue:**
- **Reproduce:** Try exact click path user described
- **Trace:** Follow data and navigation flow completely
- **Verify:** Check if routes/APIs actually exist
- **Identify:** Distinguish between mock and real data
- **Monitor:** Watch terminal for unusual patterns
- **Report:** List all findings with specific line numbers


### MedBookings Core Architecture Preservation

**FOUNDATIONAL PATTERNS (Master Branch Standards)**

**ALWAYS MAINTAIN:**
- **Prisma Schema Integrity**: All database modifications MUST extend, never restructure, the core schema
- **Next.js 14 + tRPC Pattern**: Every API endpoint follows server/api/routers pattern with strict type safety
- **Feature-Based Structure**: New features create folders under /app with dedicated components/, hooks/, and utils/
- **Authentication Flow**: All provider routes use existing withAuth() middleware - no custom auth implementations
- **Type System**: Extend existing Zod schemas and tRPC types - never bypass type validation

**NEVER VIOLATE:**
- Core authentication/authorization patterns established in server/auth/
- tRPC router structure in server/api/root.ts and server/api/trpc.ts
- Prisma client singleton pattern in server/db.ts
- Feature folder structure: each feature is self-contained with its own routing
- Existing type definitions in server/api/schemas/

### Architectural Decision Record

**WHEN ADDING FEATURES & MAKING CODE EDITS:**
1. **Enforce Feature-Based Architecture**: 
   - Create isolated feature folder: /app/[feature-name]/
   - Include mandatory subdirectories: components/, hooks/, utils/, actions/
   - Colocate all feature logic - no cross-feature imports except shared libs
   - Each feature owns its complete vertical slice
2. **Extend Existing Patterns**: Reference similar features for consistency
3. **Maintain Type Chain**: Database → Prisma → Zod → tRPC → Component props
4. **Preserve API Structure**: /api/trpc/[procedure] naming convention

### CORE FILE PROTECTION

Catch architectural drift while maintaining the flexibility needed for feature development.

**1. CRITICAL FILES:**
- 'prisma/schema.prisma'
- 'src/server/trpc.ts'
- 'src/lib/auth.ts'
- 'src/lib/prisma.ts'
- 'src/utils/api.ts'
- 'src/env.js'
- 'src/config/env/server.ts'
- 'src/types/next-auth.d.ts'

Why These Are **Critical**:
- Authentication/Authorization: Core security patterns that affect entire application
- Database: Schema and client patterns that impact all data operations
- Type System: tRPC and API type safety foundation
- Environment: Configuration that affects runtime behavior

**2. HIGH-RISK FILES:**
- 'src/middleware.ts'
- 'src/server/api/root.ts'
- 'src/server/api/routers/'
- 'src/app/layout.tsx'
- 'src/app/api/auth/'
- 'src/app/api/trpc/'
- 'src/app/providers.tsx'
- 'src/lib/permissions/'
- 'src/lib/communications/'
- 'src/lib/crypto/'
- 'src/hooks/use-permissions.ts'
- 'next.config.'
- 'package.json'

Why These Are **High-Risk**:
- API Structure: Changes affect client-server contracts
- Security: Permission systems and encryption
- Core Business Logic: Feature-specific server actions and validation

**3. MODERATE FILES:**
- 'tsconfig.json'
- 'package-lock.json'
- 'playwright.config.ts'
- '.github/workflows/'
- 'scripts/'
- 'src/features/*/types/schemas.ts'
- 'src/features/*/types/types.ts'
- 'src/features/*/lib/actions.ts'

Why These Are **Moderate**:
- Configuration: Build, test, and development environment setup
- Dependencies: Package management and tooling
- Feature Types: Domain-specific type definitions

### Database Evolution Rules
**PRISMA SCHEMA MODIFICATIONS:**

**Additive Only:** New models/fields are added, existing ones never removed. If necessary, require explicit approval by the user.
**Relation Integrity:** New relations must follow existing naming patterns (e.g., userId, providerId)
**Enum Extensions:** Add values to existing enums, never remove or rename

### API Development Standards
**tRPC PROCEDURE PATTERNS:**
```typescript
// ALWAYS follow this structure from master:
export const featureRouter = createTRPCRouter({
  procedureName: protectedProcedure // or publicProcedure
    .input(z.object({...})) // Zod validation required
    .query(async ({ ctx, input }) => {
      // Business logic here
    }),
});
```

**NEVER:**
- Create REST endpoints when tRPC procedure would suffice
- Bypass Zod validation for "simple" endpoints
- Mix authentication strategies (stick to existing NextAuth setup)

### Component Architecture Consistency
**MAINTAIN MASTER'S PATTERNS:**

- Server Components by default, Client Components only when needed
- Data fetching via tRPC hooks (api.feature.procedure.useQuery)
- Form handling with react-hook-form + zodResolver
- Error boundaries around data-dependent sections

### Workflow Enhancement Constraints
**WHILE kyle-dev-branch ADDS WORKFLOWS:**

- Workflow scripts enhance but don't replace core development patterns
- CI/CD additions must respect existing build/test/deploy pipeline
- Template management (Twilio) extends existing notification system
- New scripts in package.json preserve existing script functionality

### Testing Architecture Alignment
**TEST STRUCTURE FROM MASTER:**
__tests__/
├── unit/          # Pure function tests
├── integration/   # API endpoint tests  
└── e2e/          # User journey tests

**NEW TESTS MUST:**

- Follow existing test file naming: [feature].test.ts
- Use established test utilities from test/utils/
- Maintain test database isolation pattern


### Core Performance Principles (Never Violate)

**ALWAYS MAINTAIN:**
1. **No N+1 Queries**: Every feature must use eager loading
2. **Pagination Required**: Lists > 20 items must paginate
3. **Image Optimization**: All images through Next.js Image
4. **Code Splitting**: Route-based splitting mandatory
5. **Caching Strategy**: All GET requests cached minimum 5 seconds

**NEVER ALLOW:**
- Unindexed database queries in production paths
- Synchronous external API calls in request path
- Bundle size regression > 10% without justification
- Memory leaks (monitor heap growth)

### Dependency Management Protocol
**WHEN UPDATING DEPENDENCIES:**
```bash
# Check master's version first
git show master:package.json | grep "[dependency-name]"
# Major version changes require architecture review
# Prisma updates need full regression test
```

### Breaking Change Prevention
**BEFORE MERGING TO MASTER:**

- Run full compatibility check: npm run test:integration
- Verify database migration reversibility
- Confirm API backward compatibility
- Test provider workflow end-to-end
- Validate no core pattern violations

### RED FLAGS FOR ARCHITECTURE REVIEW:

- Changes to: server/auth/, server/api/trpc.ts, server/db.ts
- Prisma schema structural changes (vs additive)
- New authentication/authorization patterns
- Alternative state management (outside tRPC)
- Custom routing logic bypassing Next.js
